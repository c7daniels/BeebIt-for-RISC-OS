;>riscos.s
;
; BeebIt - BBC Micro Model B Emulator
;
; (C) Copyright Michael J Foot, 1998-2025
;
; Email: <mjfoot.nz@gmail.com>
;

  GET h.6502zmaps

  GET h.hostmaps

  GET h.6502cmaps

; Use the GET directive to include register definitions as if typed here

  GET     h.RegNames

; Use the GET directive to include a list of SWI names as if typed here

  GET     h.SWInames

; Area name C$$code advisable as wanted to link with C output

  AREA    |C$$code|, CODE, READONLY

; Import global symbols

  IMPORT |beebit_exit|
  IMPORT |lprintscreen|
  IMPORT |beebit_trace|
  IMPORT |hostmap|

  IMPORT |nwimpmode| ;jdl** from c.main, so we can restore screen on crash

; Export global symbols

  EXPORT |inttohex4|
  EXPORT |inttohex8|
  EXPORT |bbcvdu|
  EXPORT |getword|
  EXPORT |setword|
  EXPORT |swappages|
  EXPORT |breakdisable|
  EXPORT |breakenable|
  EXPORT |escapedisable|
  EXPORT |escapeenable|
  EXPORT |cursordisable|
  EXPORT |cursorenable|
  EXPORT |zeribeepattach|
  EXPORT |zeribeepwrite|
  EXPORT |zeribeepdetach|

  EXPORT |keyupdown|
  EXPORT |keyclaim|
  EXPORT |keyrelease|

  EXPORT |screenstartandlinelength|
  EXPORT |vsync|

  ;EXPORT |quit|
  EXPORT |keylookup|
  ;EXPORT |lastkey|
  EXPORT |nhostscreen|
  EXPORT |nhostscreenlinelength|

ScreenBlanker_Control EQU &43100
ZeriBeep_Attach EQU &55E40
ZeriBeep_Detach EQU &55E41
XScreenBlanker_Control EQU &73100
XZeriBeep_Attach EQU &75E40
XZeriBeep_Detach EQU &75E41

;
;RISC OS
;
|bbcvdu|
  ;STMFD sp!,{lr}
  SWI OS_WriteC
  MOV pc,lr
  ;LDMFD sp!,{pc}

|inttohex4|
  STMFD sp!,{r0-r2,lr}
  LDR r1,=inttohexb
  MOV r2,#16
  SWI OS_ConvertHex4 ;BinaryToDecimal
  SWI OS_Write0
  LDMFD sp!,{r0-r2,pc}

|inttohex8|
  STMFD sp!,{r0-r2,lr}
  LDR r1,=inttohexb
  MOV r2,#16
  SWI OS_ConvertHex8 ;BinaryToDecimal
  SWI OS_Write0
  LDMFD sp!,{r0-r2,pc}

inttohexb
  DCD 0
  DCD 0
  DCD 0
  DCD 0

|getword|
  ;r0=address
  ;r0=value
  LDR r0,[r0]
  MOV pc,lr

|setword|
  ;r0=address
  ;r1=value
  STR r1,[r0]
  MOV pc,lr

|swappages|
;r0=first address
;r1=second address
;r2=number of pages
  STMFD sp!,{r4-r10,lr}
  MOVS r2,r2,LSL #4
swappages1
  LDMEQFD sp!,{r4-r10,pc}
  LDMIA r0,{r3-r6}
  LDMIA r1,{r7-r10}
  STMIA r1!,{r3-r6}
  STMIA r0!,{r7-r10}
  SUBS r2,r2,#1
  B swappages1

|breakdisable|
 ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  MOV r0,#&F7
  MOV r1,#&FF
  MOV r2,#&00
  SWI OS_Byte
  LDR r12,=nbreakstatus
  STR r1,[r12] ;save the existing break status
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|breakenable|
  ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  LDR r12,=nbreakstatus
  MOV r0,#&F7
  LDR r1,[r12]
  MOV r2,#&00
  SWI OS_Byte
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|escapedisable|
  ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  MOV r0,#&E5
  MOV r1,#&FF
  MOV r2,#&00
  SWI OS_Byte
  LDR r12,=nescapestatus
  STR r1,[r12] ;save the existing break status
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|escapeenable|
  ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  LDR r12,=nescapestatus
  MOV r0,#&E5
  LDR r1,[r12]
  MOV r2,#&00
  SWI OS_Byte
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|cursordisable|
  ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  SWI OS_RemoveCursors
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|cursorenable|
  ;STMFD sp!,{lr}
  STR lr,[sp, #-4]!
  SWI OS_RestoreCursors
  ;LDMFD sp!,{pc}
  LDR pc, [sp], #4

|zeribeepattach|
  SWI XZeriBeep_Attach
  MOVVS pc,lr ;error
  LDR r3, =hostmap
  STR r0,[r3,#:INDEX:HOST_ZERIBEEPWRITEBYTE]
  STR r1,[r3,#:INDEX:HOST_ZERIBEEPWORKSPACE]
  MOV pc,lr

|zeribeepwrite|
  ;r0=6502 workspace
  ;r1=byte to write to SN76489
  LDR r2,[r0,#:INDEX:HOST_ZERIBEEPWRITEBYTE]
  CMP r2,#0
  MOVEQ pc,lr ;error
  MOV r3,r0
  STMFD sp!,{r0,lr}
  MOV r0,r1
  LDR r1,[r3,#:INDEX:HOST_CYCLES+:INDEX:HOSTCYCLES_ORIGINAL]
  LDR r12,[r3,#:INDEX:HOST_CYCLES+:INDEX:HOSTCYCLES_TOGO]
  SUB r1,r1,r12
  LDR r12,[r3,#:INDEX:HOST_CYCLES+:INDEX:HOSTCYCLES_MONOTONIC]
  ADD r1,r1,r12
  LDR r12,[r3,#:INDEX:HOST_ZERIBEEPWORKSPACE]
  MOV lr,pc
  MOV pc,r2
  LDMFD sp!,{r0,pc}

|zeribeepdetach|
  SWI XZeriBeep_Detach
  MOV pc,lr

|keyupdown|
  ;r0=event number (&0B)
  ;r1=0 for up, 1 for down
  ;r2=keyboard code

  CMP r0,#&0B
  ;LDMNEFD sp!,{r10-r12,pc} ;exit
  ;LDMNEFD r13!,{pc}
  MOVNE pc,lr  ;jdl** changed for 32bit

  STMFD sp!,{r0-r3,r8-r12,lr}
  ;LDR r12,=lastkey
  ;STRB r2,[r12]
  ;STRB r2,[r12,#1]

  ;CMP r1,#1
  ;LDREQ r0,=keydown
  ;SWIEQ OS_Write0
  ;CMP r1,#0
  ;LDREQ r0,=keyup
  ;SWIEQ OS_Write0

  ;CMP r2,#&0B ;F11
  ;MOVEQ r9,#&FF
  ;LDREQ r10,=ltrace
  ;STREQ r9,[r10]
  ;LDMEQFD sp!,{r0-r3,r8-r12,pc} ;exit

  LDR r11,=keylookup
  LDRB r9,[r11,r2] ;get bbc key code

  ;check for <Break>
  ;CMP r2,#&0F ;Break
  CMP r9,#&80
  BNE keyupdownF12

  LDR r11,=hostmap
  MOV r9,#&00
  STR r9,[r11,#R6502_LBREAK]
  CMP r1,#&00 ;if key is down
  MOVNE r9,#&FF

  ;STR lr,[sp, #-4]!  ;STMFD sp!,{lr}
  MOV r0,#129 ;scan kbd for single key
  MOV r1,#&F7 ;(8 EOR &FF) right alt
  MOV r2,#&FF
  SWI OS_Byte
  ;LDR lr, [sp], #4   ;LDMFD sp!,{lr}

  TEQ r1,#&FF ;pressed?
  LDMEQFD sp!,{r0-r3,r8-r12,pc} ;yes pass event on for watchdog.

  ;STR lr,[sp, #-4]!  ;STMFD sp!,{lr}
  MOV r0,#129 ;scan kbd for single key
  MOV r1,#&FA ;(5 EOR &FF) right alt
  MOV r2,#&FF
  SWI OS_Byte
  ;LDR lr, [sp], #4   ;LDMFD sp!,{lr}

  TEQ r1,#&FF ;pressed?
  LDMEQFD sp!,{r0-r3,r8-r12,pc} ;yes pass event on for watchdog.

  TST r9,r9 ;key is up?
  LDMEQFD sp!,{r0-r3,r8-r12,pc} ;yes exit

  LDR r2,[r11,#R6502_RESETACTION]
  STR r9,[r11,#R6502_LBREAK]
  STR r2,[r11,#R6502_TRANSITION1ACTION]

  LDMFD sp!,{r0-r3,r8-r12,pc} ;exit

keyupdownF12
  ;check for <F12> (quit)
  CMP r2,#&0C ;F12
  BNE keyupdownIns
  MOV r9,#&FF
  LDR r11,=beebit_exit ;quit
  STR r9,[r11]
  LDMFD sp!,{r0-r3,r8-r12,pc} ;exit

keyupdownIns
  ;check for <Ins> (trace on/off)
  CMP r2,#&1F ;Ins
  BNE keyupdownPrn
  CMP r1,#&00 ;if key is up
  BEQ keyupdownPrn
  LDR r11,=beebit_trace ;quit
  LDR r9,[r11]
  EOR r9,r9,#&FF
  STR r9,[r11]
  LDMFD sp!,{r0-r3,r8-r12,pc} ;exit

keyupdownPrn
  ;check for <Pr> (screen save)
  CMP r2,#&0D ;Print Screen
  BNE keyupdown3
  CMP r1,#00  ;if key is up
  BEQ keyupdown3

  ;LDR r0,=do_screendump
  ;SWI XOS_AddCallBack
  MOV r9,#&FF
  LDR r11,=lprintscreen
  STR r9,[r11]
  LDMFD sp!,{r0-r3,r8-r12,pc} ;exit

keyupdown3
  ;write key code to screen
  ;MOV r0,r2
  ;LDR r1,=vduvar2
  ;MOV r2,#8
  ;SWI OS_BinaryToDecimal
  ;MOV r0,r1
  ;MOV r1,r2
  ;SWI OS_WriteN

  ;stop the screen blanker from kicking in
  ;STR lr,[sp, #-4]!  ;STMFD sp!,{lr}
  LDR r11,=screenblankdelay
  CMP r1,#0
  MOVNE r0,#1
  LDRNE r8,[r11]
  CMPNE r8,#0
  SWINE XScreenBlanker_Control
  ;LDR lr, [sp], #4   ;LDMFD sp!,{lr}

  ;;LDR r11,=keylookup
  ;;LDRB r9,[r11,r2] ;get bbc key code

  ;LDR r12,=lastkey
  ;STRB r11,[r12,#1]

  MOV r11,#1
  AND r8,r9,#&0F
  MOV r9,r9,LSR #4
  MOV r9,r11,LSL r9
  LDR r11,=hostmap+:INDEX:HOST_KEYSTATUS
  CMP r1,#&00 ;if key is up
  LDRB r8,[r11,r8]!
  BICEQ r8,r8,r9
  ORRNE r8,r8,r9
  STRB r8,[r11]
  LDMFD sp!,{r0-r3,r8-r12,pc} ; exit

;do_screendump
;  STMFD sp!,{r0-r3,r14}
;  LDR r0,=screendump
;  MOV r0,#&2
;  MOV r1,#0
;  LDR r2,=screendump
;  MOV r3,#1
;  SWI XOS_SpriteOp
;  LDMFD sp!,{r0-r3,pc}

;screendump
;  DCB "<Beebit$Dir>.BBCScreen",0
;  ALIGN

|keyclaim|
  STMFD sp!,{r0-r2,lr}
;  MOV r0,#&C9 ;201
;  MOV r1,#&0
;  MOV r2,#&FF
;  SWI OS_Byte
;  LDR r2,=nkeyboarddisable
;  STR r1,[r2]
;  MOV r0,#&C9 ;201
;  MOV r1,#&FF
;  MOV r2,#0
;  SWI OS_Byte

  MOV r0,#4
  SWI XScreenBlanker_Control
  LDR r3,=screenblankdelay
  STRVC r1,[r3]

  MOV r0,#&0b ;exit handler
  LDR r1,=tidy_exit
  MOV r2,#0
  MOV r3,#0
  SWI XOS_ChangeEnvironment

  LDR r3,=old_exit
  STR r1,[r3]
  LDR r3,=old_r12
  STR r2,[r3]

  MOV r0,#&10
  LDR r1,=keyupdown
  MOV r2,r1 ;#0
  SWI OS_Claim ;claim event
  MOV r0,#&0E ;enable event
  MOV r1,#&0B
  SWI OS_Byte
  LDMFD sp!,{r0-r2,pc}

Wimp_SetMode EQU &400e3

tidy_exit
  BL keyrelease
  LDR r1,=nwimpmode
  LDR r0,[r1]

  SWI Wimp_SetMode
  SWI OS_Exit

|keyrelease|
  STMFD sp!,{r0-r2,lr}
keyrelease1
  MOV r0,#&81 ;129
  MOV r1,#&7F ;127
  MOV r2,#&FF ;255
  SWI OS_Byte
  CMP r1,#&FF
  BNE keyrelease1

  MOV r0,#21
  MOV r0,#0
  SWI OS_Byte

  MOV r0,#&0D ;disable event
  MOV r1,#&0B
  SWI OS_Byte
  MOV r0,#&10
  LDR r1,=keyupdown
  MOV r2,r1 ;#0
  SWI OS_Release ;release event


  MOV r0,#&0b ;exit handler
  LDR r3,=old_exit
  LDR r1,[r3]
  LDR r3,=old_r12
  LDR r2,[r3]
  MOV r3,#0
  SWI XOS_ChangeEnvironment

  MOV r0,#21 ;flush buffer
  MOV r1,#0  ;keyboard
  SWI OS_Byte

;  MOV r0,#&C9 ;201
;  LDR r2,=nkeyboarddisable
;  LDR r1,[r2]
;  MOV r2,#&0
;  SWI OS_Byte
  LDMFD sp!,{r0-r2,pc}

|screenstartandlinelength|
  STMFD sp!,{r0,r1,r11,r12,lr}
  LDR r0,=vduvar1
  LDR r1,=vduvar2
  SWI OS_ReadVduVariables
  LDR r11,[r1] ;get screen address
  LDR r12,=nhostscreen
  STR r11,[r12]
  LDR r11,[r1,#4] ;get screen line length
  LDR r12,=nhostscreenlinelength
  STR r11,[r12]
  LDMFD sp!,{r0,r1,r11,r12,pc}

|vsync|
  MOV r0,#19
  SWI OS_Byte
  MOV pc,lr

;Data Area

  AREA    |C$$data|, DATA

screenblankdelay
  DCD 0

nbreakstatus
  DCD 0
  ALIGN

nescapestatus
  DCD 0
  ALIGN

;|quit|
;  DCD 0
;  ALIGN

|keylookup|
  DCB &70,&71,&72,&73,&14,&74,&75,&16,&76,&77,&20,&20,&20,0,0,&80 ;00-0E <Esc><F1>..<F12><Pr><SL><Break>
  DCB &47,&30,&31,&11,&12,&13,&34,&24,&15,&26,&27,&17,&18,&48,&59,0 ;10-1E '1234567890'=.<Rgt><Ins>
  DCB 0,0,0,&68,&48,&17,&60,&10,&21,&22,&33,&23,&44,&35,&25,&36 ;20-2F <Hme><PgUp><NL>/*#<Tab>
  DCB &37,&38,&28,&58,&59,&69,0,&24,&15,&26,&17,&01,&41,&51,&32,&43 ;30-3F P[]#<Del><Cpy><PgD>789,<CrL>ASDF
  DCB &53,&54,&45,&46,&56,&57,&48,&49,&12,&13,&34,&57,0,&78,&61,&42 ;40-4F GHJKL:'<Ret>456+<ShL>
  DCB &52,&63,&64,&55,&65,&66,&67,&68,0,&39,&30,&31,&11,&40,&50,&62 ;50-5F CVBNM,./<ShR><Up>123<CapL><AltL><Spc>
  DCB 0,&01,&19,&29,&79,0,&67,&49,0,0,0,0,0,0,0,0 ;60-6F <AltR><CtlR>
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DCB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

old_exit DCD 0
old_r12 DCD 0

;|lastkey|
;  DCB 0,0
;  ALIGN

|nhostscreen|
  DCD 0
|nhostscreenlinelength|
  DCD 0
  ALIGN

vduvar1
  DCD 148
  DCD 6
  DCD -1
  ALIGN

vduvar2
  DCD 0
  DCD 0
  DCD 0
  ALIGN

  END
