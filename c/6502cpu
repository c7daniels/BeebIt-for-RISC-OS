/*>6502cpu.c
 *
 * Rockwell 6502 central processor unit
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Cycle-level CPU emulation
 *
 * (C) Copyright Crispian Daniels, 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <assert.h>
#include <stddef.h>
#include <string.h>
#include "6502cpu.h"
#include "beebit.h"

static_assert(offsetof(R6502ZONEMAP, AC) == 0, "Expecting zones at specific offsets");
static_assert(offsetof(R6502ZONEMAP, BC) == ((0x100>>2)+2) * sizeof(uintptr_t), "Expecting zones at specific offsets");
static_assert(offsetof(R6502ZONEMAP, CC) == (0x400>>2) * sizeof(uintptr_t), "Expecting zones at specific offsets");
static_assert(offsetof(R6502ZONEMAP, DC) == (0x1000>>2) * sizeof(uintptr_t), "Expecting zones at specific offsets");
static_assert(offsetof(R6502ZONEMAP, EC) == (0x1C00>>2) * sizeof(uintptr_t), "Expecting zones at specific offsets");
static_assert(sizeof(R6502ZONEMAP) == (0x4000>>2) * sizeof(uintptr_t), "Expecting zones at specific offsets");

static_assert(offsetof(R6502CPUMAP, keyboard_state) == offsetof(R6502ZONEMAP, keyboard_state), "Expecting consistent keyboard state offsets");
static_assert(offsetof(R6502CPUMAP, m_shift) == offsetof(R6502ZONEMAP, m_shift), "Expecting consistent data bus value offsets");
static_assert(offsetof(R6502CPUMAP, m) == offsetof(R6502ZONEMAP, m), "Expecting consistent data bus value offsets");

static_assert(offsetof(R6502CPUMAP, AP) == offsetof(R6502ZONEMAP, AP), "Expecting consistent zone offsets");
static_assert(offsetof(R6502CPUMAP, BP) == offsetof(R6502ZONEMAP, BP), "Expecting consistent zone offsets");
static_assert(offsetof(R6502CPUMAP, CP) == offsetof(R6502ZONEMAP, CP), "Expecting consistent zone offsets");
static_assert(offsetof(R6502CPUMAP, DP) == offsetof(R6502ZONEMAP, DP), "Expecting consistent zone offsets");
static_assert(sizeof(R6502CPUMAP) == sizeof(R6502ZONEMAP), "Expecting consistent zone offsets");

static_assert(R6502_SEQUENCE_COUNT <= R6502_SEQUENCE_ALLOWANCE, "Expecting R6502_SEQUENCE_COUNT not to exceed R6502_SEQUENCE_ALLOWANCE");

static_assert(offsetof(R6502CPUMAP, busops) == ((BUS_BASEFLAG-BUS_WRITEFLAG)*(64*sizeof(uintptr_t))), "Expacting busops at specific offset");


const R6502OP r6502_decodesequence[] = {r6502decodestep, NULL};
const R6502OP r6502_interruptdecodesequence[] = {r6502interruptdecodestep, NULL};

const R6502OP r6502_nopsequence[] = R6502_IMPLIED_SEQUENCE(r6502nopstep);
const R6502OP r6502_clcsequence[] = R6502_IMPLIED_SEQUENCE(r6502clcstep);
const R6502OP r6502_secsequence[] = R6502_IMPLIED_SEQUENCE(r6502secstep);
const R6502OP r6502_clisequence[] = R6502_IMPLIED_SEQUENCE(r6502clistep);
const R6502OP r6502_seisequence[] = R6502_IMPLIED_SEQUENCE(r6502seistep);
const R6502OP r6502_cldsequence[] = R6502_IMPLIED_SEQUENCE(r6502cldstep);
const R6502OP r6502_sedsequence[] = R6502_IMPLIED_SEQUENCE(r6502sedstep);
const R6502OP r6502_clvsequence[] = R6502_IMPLIED_SEQUENCE(r6502clvstep);
const R6502OP r6502_taxsequence[] = R6502_IMPLIED_SEQUENCE(r6502taxstep);
const R6502OP r6502_taysequence[] = R6502_IMPLIED_SEQUENCE(r6502taystep);
const R6502OP r6502_txasequence[] = R6502_IMPLIED_SEQUENCE(r6502txastep);
const R6502OP r6502_txssequence[] = R6502_IMPLIED_SEQUENCE(r6502txsstep);
const R6502OP r6502_tyasequence[] = R6502_IMPLIED_SEQUENCE(r6502tyastep);
const R6502OP r6502_tsxsequence[] = R6502_IMPLIED_SEQUENCE(r6502tsxstep);
const R6502OP r6502_phpsequence[] = R6502_PUSH_SEQUENCE(r6502topushpstep);
const R6502OP r6502_plpsequence[] = R6502_PULL_SEQUENCE(r6502pulledpstep);
const R6502OP r6502_phasequence[] = R6502_PUSH_SEQUENCE(r6502topushastep);
const R6502OP r6502_plasequence[] = R6502_PULL_SEQUENCE(r6502pulledastep);
const R6502OP r6502_hltsequence[] = {r6502tohltstep, r6502hltstep, NULL};
const R6502OP r6502_bitzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502bitstep);
const R6502OP r6502_bitabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502bitstep);
const R6502OP r6502_oraimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502oraimmediatestep);
const R6502OP r6502_orazpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502orastep);
const R6502OP r6502_oraabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502orastep);
const R6502OP r6502_orapreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502orastep);
const R6502OP r6502_orazpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502orastep);
const R6502OP r6502_oraabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502orastep);
const R6502OP r6502_oraabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502orastep);
const R6502OP r6502_orapostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502orastep);
const R6502OP r6502_andimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502andimmediatestep);
const R6502OP r6502_andzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502andstep);
const R6502OP r6502_andabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502andstep);
const R6502OP r6502_andpreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502andstep);
const R6502OP r6502_andzpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502andstep);
const R6502OP r6502_andabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502andstep);
const R6502OP r6502_andabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502andstep);
const R6502OP r6502_andpostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502andstep);
const R6502OP r6502_eorimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502eorimmediatestep);
const R6502OP r6502_eorzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorpreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorzpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502eorstep);
const R6502OP r6502_eorpostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502eorstep);
const R6502OP r6502_adcimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502adcimmediatestep);
const R6502OP r6502_adczpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502adcstep);
const R6502OP r6502_adcabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502adcstep);
const R6502OP r6502_adcpreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502adcstep);
const R6502OP r6502_adczpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502adcstep);
const R6502OP r6502_adcabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502adcstep);
const R6502OP r6502_adcabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502adcstep);
const R6502OP r6502_adcpostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502adcstep);
const R6502OP r6502_ldaimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502ldaimmediatestep);
const R6502OP r6502_ldazpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldaabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldapreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldazpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldaabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldaabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldapostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502ldastep);
const R6502OP r6502_ldximmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502ldximmediatestep);
const R6502OP r6502_ldxzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502ldxstep);
const R6502OP r6502_ldxabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502ldxstep);
const R6502OP r6502_ldxzpgysequence[] = R6502_LOAD_ZPGY_SEQUENCE(r6502ldxstep);
const R6502OP r6502_ldxabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502ldxstep);
const R6502OP r6502_ldyimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502ldyimmediatestep);
const R6502OP r6502_ldyzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502ldystep);
const R6502OP r6502_ldyabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502ldystep);
const R6502OP r6502_ldyzpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502ldystep);
const R6502OP r6502_ldyabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502ldystep);
const R6502OP r6502_cmpimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502cmpimmediatestep);
const R6502OP r6502_cmpzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmpabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmppreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmpzpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmpabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmpabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cmppostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502cmpstep);
const R6502OP r6502_cpximmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502cpximmediatestep);
const R6502OP r6502_cpxzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502cpxstep);
const R6502OP r6502_cpxabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502cpxstep);
const R6502OP r6502_cpyimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502cpyimmediatestep);
const R6502OP r6502_cpyzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502cpystep);
const R6502OP r6502_cpyabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502cpystep);
const R6502OP r6502_sbcimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502sbcimmediatestep);
const R6502OP r6502_sbczpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbcabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbcpreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbczpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbcabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbcabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502sbcstep);
const R6502OP r6502_sbcpostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502sbcstep);
const R6502OP r6502_skbimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502skipimmediatestep);
const R6502OP r6502_skbzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502skipstep);
const R6502OP r6502_skbzpgxsequence[] = R6502_LOAD_ZPGX_SEQUENCE(r6502skipstep);
const R6502OP r6502_skwabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502skipstep);
const R6502OP r6502_skwabsxsequence[] = R6502_LOAD_ABSX_SEQUENCE(r6502skipstep);
const R6502OP r6502_laxzpgsequence[] = R6502_LOAD_ZPG_SEQUENCE(r6502laxstep);
const R6502OP r6502_laxabssequence[] = R6502_LOAD_ABS_SEQUENCE(r6502laxstep);
const R6502OP r6502_laxpreindexedsequence[] = R6502_LOAD_PREINDEXED_SEQUENCE(r6502laxstep);
const R6502OP r6502_laxzpgysequence[] = R6502_LOAD_ZPGY_SEQUENCE(r6502laxstep);
const R6502OP r6502_laxabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502laxstep);
const R6502OP r6502_laxpostindexedsequence[] = R6502_LOAD_POSTINDEXED_SEQUENCE(r6502laxstep);
const R6502OP r6502_lasabsysequence[] = R6502_LOAD_ABSY_SEQUENCE(r6502lasstep);
const R6502OP r6502_ancimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502ancimmediatestep);
const R6502OP r6502_alrimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502alrimmediatestep);
const R6502OP r6502_arrimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502arrimmediatestep);
const R6502OP r6502_xaaimmsequence[] =  R6502_LOAD_IMM_SEQUENCE(r6502xaaimmediatestep);
const R6502OP r6502_oalimmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502oalimmediatestep);
const R6502OP r6502_sbximmsequence[] = R6502_LOAD_IMM_SEQUENCE(r6502sbximmediatestep);
const R6502OP r6502_aslasequence[] = R6502_IMPLIED_SEQUENCE(r6502aslastep);
const R6502OP r6502_aslzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502aslzpgstep);
const R6502OP r6502_aslabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502aslstep);
const R6502OP r6502_aslzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502aslzpgstep);
const R6502OP r6502_aslabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502aslstep);
const R6502OP r6502_rolasequence[] = R6502_IMPLIED_SEQUENCE(r6502rolastep);
const R6502OP r6502_rolzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502rolzpgstep);
const R6502OP r6502_rolabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502rolstep);
const R6502OP r6502_rolzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502rolzpgstep);
const R6502OP r6502_rolabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502rolstep);
const R6502OP r6502_lsrasequence[] = R6502_IMPLIED_SEQUENCE(r6502lsrastep);
const R6502OP r6502_lsrzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502lsrzpgstep);
const R6502OP r6502_lsrabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502lsrstep);
const R6502OP r6502_lsrzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502lsrzpgstep);
const R6502OP r6502_lsrabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502lsrstep);
const R6502OP r6502_rorasequence[] = R6502_IMPLIED_SEQUENCE(r6502rorastep);
const R6502OP r6502_rorzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502rorzpgstep);
const R6502OP r6502_rorabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502rorstep);
const R6502OP r6502_rorzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502rorzpgstep);
const R6502OP r6502_rorabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502rorstep);
const R6502OP r6502_dexsequence[] = R6502_IMPLIED_SEQUENCE(r6502dexstep);
const R6502OP r6502_deysequence[] = R6502_IMPLIED_SEQUENCE(r6502deystep);
const R6502OP r6502_deczpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502deczpgstep);
const R6502OP r6502_decabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502decstep);
const R6502OP r6502_deczpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502deczpgstep);
const R6502OP r6502_decabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502decstep);
const R6502OP r6502_inxsequence[] = R6502_IMPLIED_SEQUENCE(r6502inxstep);
const R6502OP r6502_inysequence[] = R6502_IMPLIED_SEQUENCE(r6502inystep);
const R6502OP r6502_inczpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502inczpgstep);
const R6502OP r6502_incabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502incstep);
const R6502OP r6502_inczpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502inczpgstep);
const R6502OP r6502_incabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502incstep);
const R6502OP r6502_asozpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502asozpgstep);
const R6502OP r6502_asoabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502asostep);
const R6502OP r6502_asozpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502asozpgstep);
const R6502OP r6502_asopreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502asostep);
const R6502OP r6502_asoabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502asostep);
const R6502OP r6502_asoabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502asostep);
const R6502OP r6502_asopostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502asostep);
const R6502OP r6502_rlazpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502rlazpgstep);
const R6502OP r6502_rlaabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502rlastep);
const R6502OP r6502_rlazpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502rlazpgstep);
const R6502OP r6502_rlapreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502rlastep);
const R6502OP r6502_rlaabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502rlastep);
const R6502OP r6502_rlaabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502rlastep);
const R6502OP r6502_rlapostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502rlastep);
const R6502OP r6502_lsezpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502lsezpgstep);
const R6502OP r6502_lseabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502lsestep);
const R6502OP r6502_lsezpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502lsezpgstep);
const R6502OP r6502_lsepreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502lsestep);
const R6502OP r6502_lseabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502lsestep);
const R6502OP r6502_lseabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502lsestep);
const R6502OP r6502_lsepostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502lsestep);
const R6502OP r6502_rrazpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502rrazpgstep);
const R6502OP r6502_rraabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502rrastep);
const R6502OP r6502_rrazpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502rrazpgstep);
const R6502OP r6502_rrapreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502rrastep);
const R6502OP r6502_rraabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502rrastep);
const R6502OP r6502_rraabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502rrastep);
const R6502OP r6502_rrapostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502rrastep);
const R6502OP r6502_dcpzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502dcpzpgstep);
const R6502OP r6502_dcpabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502dcpstep);
const R6502OP r6502_dcpzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502dcpzpgstep);
const R6502OP r6502_dcppreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502dcpstep);
const R6502OP r6502_dcpabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502dcpstep);
const R6502OP r6502_dcpabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502dcpstep);
const R6502OP r6502_dcppostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502dcpstep);
const R6502OP r6502_isbzpgsequence[] = R6502_MODIFY_ZPG_SEQUENCE(r6502isbzpgstep);
const R6502OP r6502_isbabssequence[] = R6502_MODIFY_ABS_SEQUENCE(r6502isbstep);
const R6502OP r6502_isbzpgxsequence[] = R6502_MODIFY_ZPGX_SEQUENCE(r6502isbzpgstep);
const R6502OP r6502_isbpreindexedsequence[] = R6502_MODIFY_PREINDEXED_SEQUENCE(r6502isbstep);
const R6502OP r6502_isbabsxsequence[] = R6502_MODIFY_ABSX_SEQUENCE(r6502isbstep);
const R6502OP r6502_isbabsysequence[] = R6502_MODIFY_ABSY_SEQUENCE(r6502isbstep);
const R6502OP r6502_isbpostindexedsequence[] = R6502_MODIFY_POSTINDEXED_SEQUENCE(r6502isbstep);
const R6502OP r6502_stazpgsequence[] = R6502_STORE_ZPG_SEQUENCE(r6502loadzpgtostastep);
const R6502OP r6502_staabssequence[] = R6502_STORE_ABS_SEQUENCE(r6502loadabstostastep);
const R6502OP r6502_stazpgxsequence[] = R6502_STORE_ZPGX_SEQUENCE(r6502loadzpgxtostastep);
const R6502OP r6502_stapreindexedsequence[] = R6502_STORE_PREINDEXED_SEQUENCE(r6502loadabstostastep);
const R6502OP r6502_staabsxsequence[] = R6502_STORE_ABSX_SEQUENCE(r6502fixindexedtostastep);
const R6502OP r6502_staabsysequence[] = R6502_STORE_ABSY_SEQUENCE(r6502fixindexedtostastep);
const R6502OP r6502_stapostindexedsequence[] = R6502_STORE_POSTINDEXED_SEQUENCE(r6502fixindexedtostastep);
const R6502OP r6502_stxzpgsequence[] = R6502_STORE_ZPG_SEQUENCE(r6502loadzpgtostxstep);
const R6502OP r6502_stxabssequence[] = R6502_STORE_ABS_SEQUENCE(r6502loadabstostxstep);
const R6502OP r6502_stxzpgysequence[] = R6502_STORE_ZPGY_SEQUENCE(r6502loadzpgytostxstep);
const R6502OP r6502_styzpgsequence[] = R6502_STORE_ZPG_SEQUENCE(r6502loadzpgtostystep);
const R6502OP r6502_styabssequence[] = R6502_STORE_ABS_SEQUENCE(r6502loadabstostystep);
const R6502OP r6502_styzpgxsequence[] = R6502_STORE_ZPGX_SEQUENCE(r6502loadzpgxtostystep);
const R6502OP r6502_saxzpgsequence[] = R6502_STORE_ZPG_SEQUENCE(r6502loadzpgtosaxstep);
const R6502OP r6502_saxabssequence[] = R6502_STORE_ABS_SEQUENCE(r6502loadabstosaxstep);
const R6502OP r6502_saxzpgysequence[] = R6502_STORE_ZPGY_SEQUENCE(r6502loadzpgytosaxstep);
const R6502OP r6502_saxpreindexedsequence[] = R6502_STORE_PREINDEXED_SEQUENCE(r6502loadabstosaxstep);
const R6502OP r6502_axaabsysequence[] = R6502_STORE_ABSY_SEQUENCE(r6502fixindexedtoaxastep);
const R6502OP r6502_axapostindexedsequence[] = R6502_STORE_POSTINDEXED_SEQUENCE(r6502fixindexedtoaxastep);
const R6502OP r6502_xasabsysequence[] = R6502_STORE_ABSY_SEQUENCE(r6502fixindexedtoxasstep);
const R6502OP r6502_sayabsxsequence[] = R6502_STORE_ABSX_SEQUENCE(r6502fixindexedtosaystep);
const R6502OP r6502_tasabsysequence[] = R6502_STORE_ABSY_SEQUENCE(r6502fixindexedtotasstep);
const R6502OP r6502_bplsequence[] = R6502_BRANCH_SEQUENCE(r6502bplstep);
const R6502OP r6502_bmisequence[] = R6502_BRANCH_SEQUENCE(r6502bmistep);
const R6502OP r6502_bvcsequence[] = R6502_BRANCH_SEQUENCE(r6502bvcstep);
const R6502OP r6502_bvssequence[] = R6502_BRANCH_SEQUENCE(r6502bvsstep);
const R6502OP r6502_bccsequence[] = R6502_BRANCH_SEQUENCE(r6502bccstep);
const R6502OP r6502_bcssequence[] = R6502_BRANCH_SEQUENCE(r6502bcsstep);
const R6502OP r6502_bnesequence[] = R6502_BRANCH_SEQUENCE(r6502bnestep);
const R6502OP r6502_beqsequence[] = R6502_BRANCH_SEQUENCE(r6502beqstep);
const R6502OP r6502_jmpabssequence[] = {r6502latchabslostep, r6502loadpchstep, NULL};
const R6502OP r6502_jmpabsindsequence[] = {r6502latchabslostep, r6502breadcrumbloadabsstep, r6502latchjmpabsindlostep, r6502loadpchstep, NULL};
const R6502OP r6502_resetsequence[] = {r6502waitonresetstep, r6502resetstep, r6502notpushedtonotpushstep, r6502notpushedtonotpushstep, r6502breadcrumbnotpushedtoresetlostep, r6502latchveclostep, r6502loadpchstep, NULL};
const R6502OP r6502_brksequence[] = {r6502tobrkpushpchstep, r6502pushedtopushpclstep, r6502pushedtopushpstep, r6502breadcrumbpushedtointerruptlostep, r6502latchveclostep, r6502loadpchstep, NULL};
const R6502OP r6502_interruptsequence[] = {r6502topushpchstep, r6502pushedtopushpclstep, r6502pushedtopushpwithoutbstep, r6502breadcrumbpushedtointerruptlostep, r6502latchveclostep, r6502loadpchstep, NULL};
const R6502OP r6502_jsrsequence[] = {r6502latchabslobeforepushstep, r6502tojsrpushpchstep, r6502pushedtojsrpushpclstep, r6502pushedtoloadpchstep, r6502loadpchstep, NULL};
const R6502OP r6502_rtisequence[] = R6502_PULL_SEQUENCE(r6502pulledptopullstep, r6502pulledpclstep, r6502loadpchstep);
const R6502OP r6502_rtssequence[] = R6502_PULL_SEQUENCE(r6502pulledpclstep, r6502loadpchtoincrementstep, r6502skipstep);


const R6502OP* const r6502sequences[R6502_MAIN_SEQUENCE_COUNT] =
{
  r6502_brksequence, //0x00
  r6502_orapreindexedsequence, //0x01
  r6502_hltsequence, //0x02
  r6502_asopreindexedsequence, //0x03
  r6502_skbzpgsequence, //0x04
  r6502_orazpgsequence, //0x05
  r6502_aslzpgsequence, //0x06
  r6502_asozpgsequence, //0x07
  r6502_phpsequence, //0x08
  r6502_oraimmsequence, //0x09
  r6502_aslasequence, //0x0A
  r6502_ancimmsequence, //0x0B
  r6502_skwabssequence, //0x0C
  r6502_oraabssequence, //0x0D
  r6502_aslabssequence, //0x0E
  r6502_asoabssequence, //0x0F

  r6502_bplsequence, //0x10
  r6502_orapostindexedsequence, //0x11
  r6502_hltsequence, //0x12
  r6502_asopostindexedsequence, //0x13
  r6502_skbzpgxsequence, //0x14
  r6502_orazpgxsequence, //0x15
  r6502_aslzpgxsequence, //0x16
  r6502_asozpgxsequence, //0x17
  r6502_clcsequence, //0x18
  r6502_oraabsysequence, //0x19
  r6502_nopsequence, //0x1A
  r6502_asoabsysequence, //0x1B
  r6502_skwabsxsequence, //0x1C
  r6502_oraabsxsequence, //0x1D
  r6502_aslabsxsequence, //0x1E
  r6502_asoabsxsequence, //0x1F

  r6502_jsrsequence, //0x20
  r6502_andpreindexedsequence, //0x21
  r6502_hltsequence, //0x22
  r6502_rlapreindexedsequence, //0x23
  r6502_bitzpgsequence, //0x24
  r6502_andzpgsequence, //0x25
  r6502_rolzpgsequence, //0x26
  r6502_rlazpgsequence, //0x27
  r6502_plpsequence, //0x28
  r6502_andimmsequence, //0x29
  r6502_rolasequence, //0x2A
  r6502_ancimmsequence, //0x2B
  r6502_bitabssequence, //0x2C
  r6502_andabssequence, //0x2D
  r6502_rolabssequence, //0x2E
  r6502_rlaabssequence, //0x2F

  r6502_bmisequence, //0x30
  r6502_andpostindexedsequence, //0x31
  r6502_hltsequence, //0x32
  r6502_rlapostindexedsequence, //0x33
  r6502_skbzpgxsequence, //0x34
  r6502_andzpgxsequence, //0x35
  r6502_rolzpgxsequence, //0x36
  r6502_rlazpgxsequence, //0x37
  r6502_secsequence, //0x38
  r6502_andabsysequence, //0x39
  r6502_nopsequence, //0x3A
  r6502_rlaabsysequence, //0x3B
  r6502_skwabsxsequence, //0x3C
  r6502_andabsxsequence, //0x3D
  r6502_rolabsxsequence, //0x3E
  r6502_rlaabsxsequence, //0x3F

  r6502_rtisequence, //0x40
  r6502_eorpreindexedsequence, //0x41
  r6502_hltsequence, //0x42
  r6502_lsepreindexedsequence, //0x43
  r6502_skbzpgsequence, //0x44
  r6502_eorzpgsequence, //0x45
  r6502_lsrzpgsequence, //0x46
  r6502_lsezpgsequence, //0x47
  r6502_phasequence, //0x48
  r6502_eorimmsequence, //0x49
  r6502_lsrasequence, //0x4A
  r6502_alrimmsequence, //0x4B
  r6502_jmpabssequence, //0x4C
  r6502_eorabssequence, //0x4D
  r6502_lsrabssequence, //0x4E
  r6502_lseabssequence, //0x4F

  r6502_bvcsequence, //0x50
  r6502_eorpostindexedsequence, //0x51
  r6502_hltsequence, //0x52
  r6502_lsepostindexedsequence, //0x53
  r6502_skbzpgxsequence, //0x54
  r6502_eorzpgxsequence, //0x55
  r6502_lsrzpgxsequence, //0x56
  r6502_lsezpgxsequence, //0x57
  r6502_clisequence, //0x58
  r6502_eorabsysequence, //0x59
  r6502_nopsequence, //0x5A
  r6502_lseabsysequence, //0x5B
  r6502_skwabsxsequence, //0x5C
  r6502_eorabsxsequence, //0x5D
  r6502_lsrabsxsequence, //0x5E
  r6502_lseabsxsequence, //0x5F

  r6502_rtssequence, //0x60
  r6502_adcpreindexedsequence, //0x61
  r6502_hltsequence, //0x62
  r6502_rrapreindexedsequence, //0x63
  r6502_skbzpgsequence, //0x64
  r6502_adczpgsequence, //0x65
  r6502_rorzpgsequence, //0x66
  r6502_rrazpgsequence, //0x67
  r6502_plasequence, //0x68
  r6502_adcimmsequence, //0x69
  r6502_rorasequence, //0x6A
  r6502_arrimmsequence, //0x6B
  r6502_jmpabsindsequence, //0x6C
  r6502_adcabssequence, //0x6D
  r6502_rorabssequence, //0x6E
  r6502_rraabssequence, //0x6F

  r6502_bvssequence, //0x70
  r6502_adcpostindexedsequence, //0x71
  r6502_hltsequence, //0x72
  r6502_rrapostindexedsequence, //0x73
  r6502_skbzpgxsequence, //0x74
  r6502_adczpgxsequence, //0x75
  r6502_rorzpgxsequence, //0x76
  r6502_rrazpgxsequence, //0x77
  r6502_seisequence, //0x78
  r6502_adcabsysequence, //0x79
  r6502_nopsequence, //0x7A
  r6502_rraabsysequence, //0x7B
  r6502_skwabsxsequence, //0x7C
  r6502_adcabsxsequence, //0x7D
  r6502_rorabsxsequence, //0x7E
  r6502_rraabsxsequence, //0x7F

  r6502_skbimmsequence,  //0x80
  r6502_stapreindexedsequence,  //0x81
  r6502_skbimmsequence,  //0x82
  r6502_saxpreindexedsequence,  //0x83
  r6502_styzpgsequence,  //0x84
  r6502_stazpgsequence,  //0x85
  r6502_stxzpgsequence,  //0x86
  r6502_saxzpgsequence,  //0x87
  r6502_deysequence,  //0x88
  r6502_skbimmsequence,  //0x89
  r6502_txasequence,  //0x8A
  r6502_xaaimmsequence,  //0x8B
  r6502_styabssequence,  //0x8C
  r6502_staabssequence,  //0x8D
  r6502_stxabssequence,  //0x8E
  r6502_saxabssequence,  //0x8F

  r6502_bccsequence, //0x90
  r6502_stapostindexedsequence, //0x91
  r6502_hltsequence, //0x92
  r6502_axapostindexedsequence, //0x93
  r6502_styzpgxsequence, //0x94
  r6502_stazpgxsequence, //0x95
  r6502_stxzpgysequence, //0x96
  r6502_saxzpgysequence, //0x97
  r6502_tyasequence, //0x98
  r6502_staabsysequence, //0x99
  r6502_txssequence, //0x9A
  r6502_tasabsysequence, //0x9B
  r6502_sayabsxsequence, //0x9C
  r6502_staabsxsequence, //0x9D
  r6502_xasabsysequence, //0x9E
  r6502_axaabsysequence, //0x9F

  r6502_ldyimmsequence,  //0xA0
  r6502_ldapreindexedsequence,  //0xA1
  r6502_ldximmsequence,  //0xA2
  r6502_laxpreindexedsequence,  //0xA3
  r6502_ldyzpgsequence,  //0xA4
  r6502_ldazpgsequence,  //0xA5
  r6502_ldxzpgsequence,  //0xA6
  r6502_laxzpgsequence,  //0xA7
  r6502_taysequence,  //0xA8
  r6502_ldaimmsequence,  //0xA9
  r6502_taxsequence,  //0xAA
  r6502_oalimmsequence,  //0xAB
  r6502_ldyabssequence,  //0xAC
  r6502_ldaabssequence,  //0xAD
  r6502_ldxabssequence,  //0xAE
  r6502_laxabssequence,  //0xAF

  r6502_bcssequence, //0xB0
  r6502_ldapostindexedsequence, //0xB1
  r6502_hltsequence, //0xB2
  r6502_laxpostindexedsequence, //0xB3
  r6502_ldyzpgxsequence, //0xB4
  r6502_ldazpgxsequence, //0xB5
  r6502_ldxzpgysequence, //0xB6
  r6502_laxzpgysequence, //0xB7
  r6502_clvsequence, //0xB8
  r6502_ldaabsysequence, //0xB9
  r6502_tsxsequence, //0xBA
  r6502_lasabsysequence, //0xBB
  r6502_ldyabsxsequence, //0xBC
  r6502_ldaabsxsequence, //0xBD
  r6502_ldxabsysequence, //0xBE
  r6502_laxabsysequence, //0xBF

  r6502_cpyimmsequence, //0xC0
  r6502_cmppreindexedsequence, //0xC1
  r6502_skbimmsequence, //0xC2
  r6502_dcppreindexedsequence, //0xC3
  r6502_cpyzpgsequence, //0xC4
  r6502_cmpzpgsequence, //0xC5
  r6502_deczpgsequence, //0xC6
  r6502_dcpzpgsequence, //0xC7
  r6502_inysequence, //0xC8
  r6502_cmpimmsequence, //0xC9
  r6502_dexsequence, //0xCA
  r6502_sbximmsequence, //0xCB
  r6502_cpyabssequence, //0xCC
  r6502_cmpabssequence, //0xCD
  r6502_decabssequence, //0xCE
  r6502_dcpabssequence, //0xCF

  r6502_bnesequence, //0xD0
  r6502_cmppostindexedsequence, //0xD1
  r6502_hltsequence, //0xD2
  r6502_dcppostindexedsequence, //0xD3
  r6502_skbzpgxsequence, //0xD4
  r6502_cmpzpgxsequence, //0xD5
  r6502_deczpgxsequence, //0xD6
  r6502_dcpzpgxsequence, //0xD7
  r6502_cldsequence, //0xD8
  r6502_cmpabsysequence, //0xD9
  r6502_nopsequence, //0xDA
  r6502_dcpabsysequence, //0xDB
  r6502_skwabsxsequence, //0xDC
  r6502_cmpabsxsequence, //0xDD
  r6502_decabsxsequence, //0xDE
  r6502_dcpabsxsequence, //0xDF

  r6502_cpximmsequence, //0xE0
  r6502_sbcpreindexedsequence, //0xE1
  r6502_skbimmsequence, //0xE2
  r6502_isbpreindexedsequence, //0xE3
  r6502_cpxzpgsequence, //0xE4
  r6502_sbczpgsequence, //0xE5
  r6502_inczpgsequence, //0xE6
  r6502_isbzpgsequence, //0xE7
  r6502_inxsequence, //0xE8
  r6502_sbcimmsequence, //0xE9
  r6502_nopsequence, //0xEA
  r6502_sbcimmsequence, //0xEB
  r6502_cpxabssequence, //0xEC
  r6502_sbcabssequence, //0xED
  r6502_incabssequence, //0xEE
  r6502_isbabssequence, //0xEF

  r6502_beqsequence, //0xF0
  r6502_sbcpostindexedsequence, //0xF1
  r6502_hltsequence, //0xF2
  r6502_isbpostindexedsequence, //0xF3
  r6502_skbzpgxsequence, //0xF4
  r6502_sbczpgxsequence, //0xF5
  r6502_inczpgxsequence, //0xF6
  r6502_isbzpgxsequence, //0xF7
  r6502_sedsequence, //0xF8
  r6502_sbcabsysequence, //0xF9
  r6502_nopsequence, //0xFA
  r6502_isbabsysequence, //0xFB
  r6502_skwabsxsequence, //0xFC
  r6502_sbcabsxsequence, //0xFD
  r6502_incabsxsequence, //0xFE
  r6502_isbabsxsequence, //0xFF

  r6502_decodesequence,
  r6502_interruptdecodesequence,
  r6502_interruptsequence,
  r6502_resetsequence
};

#ifdef BEEBIT_NO_ASM
R6502CPUMAP* r6502yield(R6502CPUMAP* cmap, uintptr_t pc_code)
{
  R6502ZONEMAP* zmap = (R6502ZONEMAP*)cmap;

  cmap->transition1action = cmap->fetchaction;
  cmap->transition2action = cmap->fetchaction;

  cmap->sync_pc_code = pc_code;
  cmap->cpu_state = cmap->sequences[R6502_DECODE_SEQUENCE];
  cmap->yieldflagaction(zmap);
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502fetch(R6502CPUMAP* cmap, uintptr_t pc_code)
{
  cmap->sync_pc_code = pc_code;
  cmap->cpu_state = cmap->sequences[R6502_DECODE_SEQUENCE];
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502interruptfetch(R6502CPUMAP* cmap, uintptr_t pc_code)
{
  cmap->timesinterruptmissed = 0;
  cmap->sync_pc_code = pc_code;
  cmap->cpu_state = cmap->sequences[R6502_INTERRUPT_DECODE_SEQUENCE];
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502fetchthentestirq(R6502CPUMAP* cmap, uintptr_t pc_code)
{
  cmap->sync_pc_code = pc_code;
  cmap->cpu_state = cmap->sequences[R6502_DECODE_SEQUENCE];

  if (cmap->irq)
    cmap->transition1action = cmap->interruptfetchaction;
  else
    cmap->transition1action = cmap->transition2action;
  R6502_CHECK_FOR_BREAK(cmap)
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502enterreset(R6502CPUMAP* cmap, uintptr_t pc_code)
{
  cmap->timesinterruptmissed = 0;
  cmap->sync_pc_code = pc_code;
  cmap->cpu_state = cmap->sequences[R6502_RESET_SEQUENCE];
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502decodestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = cmap->sequences[(unsigned char)cmap->m];
  R6502_JUMP_TO_READ_OP(cmap, (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF)
}

R6502CPUMAP* r6502interruptdecodestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = cmap->sequences[R6502_INTERRUPT_SEQUENCE];
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502waitstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_READ_OP(cmap, cmap->last_pc_code)
}

// IMPLIED_STEP
R6502CPUMAP* r6502nopstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502clcstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps &= NOTCFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502secstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps |= CFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502clistep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  if (cmap->ps & IFLAG)
  {
    if (cmap->transition1action == cmap->fetchaction || cmap->transition1action == cmap->yieldaction)
    {
      cmap->transition1action = cmap->fetchthentestirqaction;
      R6502_CHECK_FOR_BREAK(cmap)
    }
    cmap->ps &= NOTIFLAG;
  }
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502seistep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps |= IFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cldstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps &= NOTDFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502sedstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps |= DFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502clvstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->ps &= NOTVFLAG;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502taxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = cmap->a;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502taystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->y = cmap->a;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->y & NFLAG) | (cmap->y == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502txastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->x;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502txsstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->sp_code = (((uintptr_t)cmap->x)<<24);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502tyastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->y;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502tsxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = (cmap->sp_code>>24);
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502pulledastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502pulledpstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned char ps_old = cmap->ps;

  cmap->ps = cmap->m | UFLAG | BFLAG;
  if ((ps_old & IFLAG) && !(cmap->ps & IFLAG))
  {
    if (cmap->transition1action == cmap->fetchaction || cmap->transition1action == cmap->yieldaction)
    {
      cmap->transition1action = cmap->fetchthentestirqaction;
      R6502_CHECK_FOR_BREAK(cmap)
    }
  }
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502tohltstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_READ_OP(cmap, cmap->sync_pc_code)
}

R6502CPUMAP* r6502hltstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  if (cmap->transition1action == cmap->resetaction)
    return cmap->resetaction(cmap, cmap->sync_pc_code);
  else if (cmap->transition1action == cmap->yieldaction)
    return cmap->yieldaction(cmap, cmap->sync_pc_code);
  else
    R6502_JUMP_WITHOUT_BUS_OP(cmap)
}

// FROM_IMMEDIATE_STEP / FROM_ADDRESS_STEP
R6502CPUMAP* r6502beforepullstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502topullstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code + 0x1000000) & 0xFFFFFFFF;
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502breadcrumbloadzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  cmap->address_code = (((uintptr_t)cmap->m)<<24);
  R6502_JUMP_TO_ZPG_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502loadzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  address_code = (((uintptr_t)cmap->m)<<24);
  R6502_JUMP_TO_ZPG_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502latchabslostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_READ_OP(cmap, cmap->last_pc_code)
}

R6502CPUMAP* r6502breadcrumbloadabsstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  R6502_JUMP_TO_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502loadabsstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502latchzpgindlostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (cmap->address_code+0x1000000) & 0xFF000000;
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_ZPG_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502breadcrumbloadzpgxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->address_code = (cmap->address_code+(((uintptr_t)cmap->x)<<24)) & 0xFFFFFFFF;
  R6502_JUMP_TO_ZPG_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502loadzpgxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (cmap->address_code+(((uintptr_t)cmap->x)<<24)) & 0xFFFFFFFF;
  R6502_JUMP_TO_ZPG_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (cmap->address_code+(((uintptr_t)cmap->y)<<24)) & 0xFFFFFFFF;
  R6502_JUMP_TO_ZPG_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabsxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->x)<<16);
  uintptr_t address_code = ((((uintptr_t)cmap->m)<<24) + sum) | BUS_BASEFLAG;
  cmap->address_fix_code = address_code;
  if (sum & 0x01000000)
  {
    cmap->cpu_state = (R6502OP*)incremented_cpu_state;
    address_code = (address_code - 0x01000000) & 0xFFFFFFFF;
  }
  else
    cmap->cpu_state = ((R6502OP*)incremented_cpu_state)+1;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabsystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->y)<<16);
  uintptr_t address_code = ((((uintptr_t)cmap->m)<<24) + sum) | BUS_BASEFLAG;
  cmap->address_fix_code = address_code;
  if (sum & 0x01000000)
  {
    cmap->cpu_state = (R6502OP*)incremented_cpu_state;
    address_code = (address_code - 0x01000000) & 0xFFFFFFFF;
  }
  else
    cmap->cpu_state = ((R6502OP*)incremented_cpu_state)+1;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502linearloadabsxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->x)<<16);
  uintptr_t address_code = ((((uintptr_t)cmap->m)<<24) + sum) | BUS_BASEFLAG;
  cmap->address_fix_code = address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0x01000000)
    address_code = (address_code - 0x01000000) & 0xFFFFFFFF;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502linearloadabsystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->y)<<16);
  uintptr_t address_code = ((((uintptr_t)cmap->m)<<24) + sum) | BUS_BASEFLAG;
  cmap->address_fix_code = address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0x01000000)
    address_code = (address_code - 0x01000000) & 0xFFFFFFFF;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502breadcrumbfixindexedstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->address_code = cmap->address_fix_code;
  R6502_JUMP_TO_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502fixindexedstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = cmap->address_fix_code;
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502bitstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  int aandm = cmap->a & cmap->m;
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG);
  cmap->ps |= (cmap->m & (NFLAG | VFLAG)) | (aandm == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502oraimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a |= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502orastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a |= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502andimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a &= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502andstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a &= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502eorimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a ^= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502eorstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a ^= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502adcimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  uintptr_t sum;
  m = ((m<<4)&0xF00) | (m&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + m + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0);
  if (cmap->ps & DFLAG)
    sum += 6;
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ m))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (sum >= 0xA00)
      sum += 0x600;
  }
  if (sum >= 0x1000)
    cmap->ps |= CFLAG;
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502adcstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  uintptr_t sum;
  m = ((m<<4)&0xF00) | (m&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + m + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0);
  if (cmap->ps & DFLAG)
    sum += 6;
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ m))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (sum >= 0xA00)
      sum += 0x600;
  }
  if (sum >= 0x1000)
    cmap->ps |= CFLAG;
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldaimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldximmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldyimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->y = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->y & NFLAG) | (cmap->y == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ldystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->y = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->y & NFLAG) | (cmap->y == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cmpimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->a - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cmpstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->a - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cpximmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->x - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cpxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->x - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cpyimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->y - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502cpystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + cmap->y - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502sbcimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int im = 0xFF ^ cmap->m;
  unsigned int a = cmap->a;
  uintptr_t sum;
  im = ((im<<4)&0xF00) | (im&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + im + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0) | ((sum>>12) & CFLAG);
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ im))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (!(cmap->ps & CFLAG))
      sum -= 0x600;
  }
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502sbcstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int im = 0xFF ^ cmap->m;
  unsigned int a = cmap->a;
  uintptr_t sum;
  im = ((im<<4)&0xF00) | (im&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + im + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0) | ((sum>>12) & CFLAG);
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ im))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (!(cmap->ps & CFLAG))
      sum -= 0x600;
  }
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502skipimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502skipstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502laxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = cmap->a = cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502lasstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int anded = (cmap->sp_code>>24) & cmap->m;
  cmap->x = cmap->a = anded;
  cmap->sp_code = (anded<<24);
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_ADDRESSED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502ancimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a &= cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((cmap->a>>7) & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502alrimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int anded = cmap->a & cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a = ((anded>>1) & 0x7F);
  cmap->ps |= (cmap->a == 0 ? ZFLAG : 0) | (anded & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502arrimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int anded = cmap->a & cmap->m;
  uintptr_t rotated = ((cmap->ps & CFLAG)<<7) | (anded>>1);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (rotated & NFLAG) | ((anded^rotated) & VFLAG) | ((rotated & 0xFF) == 0 ? ZFLAG : 0);
  if (cmap->ps & DFLAG)
  {
    if (anded >= 0x50)
    {
      cmap->ps |= CFLAG;
      rotated += 0x60;
    }
    if ((anded & 0x0F) >= 0x05)
      rotated = (rotated & 0xF0) | ((rotated + 0x06) & 0x0F);
  }
  else
  {
    cmap->ps |= ((anded>>7) & CFLAG);
  }
  cmap->a = (rotated & 0xFF);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502xaaimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->a = cmap->x & cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502oalimmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = cmap->a = (cmap->a | 0xEE) & cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502sbximmediatestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d = 0x100 + (cmap->a & cmap->x) - cmap->m;
  cmap->x = (d & 0xFF);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | (cmap->x == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_IMMEDIATE_NEXT_INSTRUCTION(cmap)
}
// MODIFY_STEP 6502 / 65C12
R6502CPUMAP* r6502tozpgmodifystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502tomodifystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502aslastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (((uintptr_t)cmap->a)<<1);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a = shifted & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((shifted>>8) & CFLAG);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502aslzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (((uintptr_t)cmap->m)<<1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->m = shifted & 0xFF;
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0) | ((shifted>>8) & CFLAG);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502aslstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (((uintptr_t)cmap->m)<<1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->m = shifted & 0xFF;
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0) | ((shifted>>8) & CFLAG);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rolastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = (((uintptr_t)cmap->a)<<1) | (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a = rotated & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((rotated>>8) & CFLAG);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502rolzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = (((uintptr_t)cmap->m)<<1) | (cmap->ps & CFLAG);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->m = rotated & 0xFF;
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0) | ((rotated>>8) & CFLAG);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rolstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = (((uintptr_t)cmap->m)<<1) | (cmap->ps & CFLAG);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->m = rotated & 0xFF;
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0) | ((rotated>>8) & CFLAG);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502lsrastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (cmap->a>>1);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (shifted == 0 ? ZFLAG : 0) | (cmap->a & CFLAG);
  cmap->a = shifted;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502lsrzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (shifted == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = shifted;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502lsrstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (shifted == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = shifted;
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rorastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = ((cmap->ps & CFLAG)<<7) | (cmap->a>>1);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (rotated & NFLAG) | (rotated == 0 ? ZFLAG : 0) | (cmap->a & CFLAG);
  cmap->a = rotated;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502rorzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = ((cmap->ps & CFLAG)<<7) | (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (rotated & NFLAG) | (rotated == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = rotated;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rorstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = ((cmap->ps & CFLAG)<<7) | (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (rotated & NFLAG) | (rotated == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = rotated;
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502dexstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = (cmap->x - 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502deystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->y = (cmap->y - 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->y & NFLAG) | (cmap->y == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502deczpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m - 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502decstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m - 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502inxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->x = (cmap->x + 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->x & NFLAG) | (cmap->x == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502inystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->y = (cmap->y + 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->y & NFLAG) | (cmap->y == 0 ? ZFLAG : 0);
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

R6502CPUMAP* r6502inczpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m + 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502incstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m + 1) & 0xFF;
  cmap->ps &= (NOTNFLAG & NOTZFLAG);
  cmap->ps |= (cmap->m & NFLAG) | (cmap->m == 0 ? ZFLAG : 0);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502asozpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  shifted = (((uintptr_t)cmap->m)<<1);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a |= (shifted & 0xFF);
  cmap->m = shifted & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((shifted>>8) & CFLAG);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502asostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  shifted = (((uintptr_t)cmap->m)<<1);
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a |= (shifted & 0xFF);
  cmap->m = shifted & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((shifted>>8) & CFLAG);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rlazpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = (((uintptr_t)cmap->m)<<1) | (cmap->ps & CFLAG);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a &= rotated;
  cmap->m = rotated & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((rotated>>8) & CFLAG);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rlastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t rotated = (((uintptr_t)cmap->m)<<1) | (cmap->ps & CFLAG);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a &= rotated;
  cmap->m = rotated & 0xFF;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | ((rotated>>8) & CFLAG);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502lsezpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a ^= shifted;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = shifted;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502lsestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t shifted = (cmap->m>>1);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->a ^= shifted;
  cmap->ps |= (cmap->a & NFLAG) | (cmap->a == 0 ? ZFLAG : 0) | (cmap->m & CFLAG);
  cmap->m = shifted;
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rrazpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  unsigned int c = m & CFLAG;
  uintptr_t sum;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = m = ((cmap->ps & CFLAG)<<7) | (m>>1);
  m = ((m<<4)&0xF00) | (m&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + m + c;
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0);
  if (cmap->ps & DFLAG)
    sum += 6;
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ m))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (sum >= 0xA00)
      sum += 0x600;
  }
  if (sum >= 0x1000)
    cmap->ps |= CFLAG;
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502rrastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  unsigned int c = m & CFLAG;
  uintptr_t sum;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = m = ((cmap->ps & CFLAG)<<7) | (m>>1);
  m = ((m<<4)&0xF00) | (m&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + m + c;
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0);
  if (cmap->ps & DFLAG)
    sum += 6;
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ m))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (sum >= 0xA00)
      sum += 0x600;
  }
  if (sum >= 0x1000)
    cmap->ps |= CFLAG;
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502dcpzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m - 1) & 0xFF;
  d = 0x100 + cmap->a - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502dcpstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int d;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = (cmap->m - 1) & 0xFF;
  d = 0x100 + cmap->a - cmap->m;
  cmap->ps &= (NOTNFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= (d & NFLAG) | ((d & 0xFF) == 0 ? ZFLAG : 0) | ((d>>8) & CFLAG);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502isbzpgstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  unsigned int im, sum;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = m = (m+1) & 0xFF;
  im = 0xFF ^ cmap->m;
  im = ((im<<4)&0xF00) | (im&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + im + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0) | ((sum>>12) & CFLAG);
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ im))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (!(cmap->ps & CFLAG))
      sum -= 0x600;
  }
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502isbstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned int m = cmap->m;
  unsigned int a = cmap->a;
  unsigned int im, sum;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = m = (m+1) & 0xFF;
  im = 0xFF ^ cmap->m;
  im = ((im<<4)&0xF00) | (im&0xF);
  a = ((a<<4)&0xF00) | (a&0xF);
  sum = a + 0x0F0 + im + (cmap->ps & CFLAG);
  cmap->ps &= (NOTNFLAG & NOTVFLAG & NOTZFLAG & NOTCFLAG);
  cmap->ps |= ((sum & 0xF0F) == 0 ? ZFLAG : 0) | ((sum>>12) & CFLAG);
  cmap->ps |= ((sum>>4) & NFLAG) | ((((sum ^ a) & (sum ^ im))>>5) & VFLAG);
  if (cmap->ps & DFLAG)
  {
    if (sum & 0x80)
      sum -= 6;
    if (!(cmap->ps & CFLAG))
      sum -= 0x600;
  }
  cmap->a = ((sum>>4)&0xF0) | (sum&0xF);
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_code)
}

// TO_ADDRESS_STEP / FIX_TO_ADDRESS_STEP
R6502CPUMAP* r6502topushpstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = cmap->ps;
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502topushastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = cmap->a;
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502loadzpgtostastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  address_code = (((uintptr_t)cmap->m)<<24);
  cmap->m = cmap->a;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabstostastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  cmap->m = cmap->a;
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgxtostastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = ((cmap->address_code+(((uintptr_t)cmap->x)<<24)) & 0xFF000000);
  cmap->m = cmap->a;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502fixindexedtostastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = cmap->a;
  R6502_JUMP_TO_WRITE_OP(cmap, cmap->address_fix_code)
}

R6502CPUMAP* r6502loadzpgtostxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  address_code = (((uintptr_t)cmap->m)<<24);
  cmap->m = cmap->x;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabstostxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  cmap->m = cmap->x;
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgytostxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = ((cmap->address_code+(((uintptr_t)cmap->y)<<24)) & 0xFF000000);
  cmap->m = cmap->x;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgtostystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  address_code = (((uintptr_t)cmap->m)<<24);
  cmap->m = cmap->y;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabstostystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  cmap->m = cmap->y;
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgxtostystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = ((cmap->address_code+(((uintptr_t)cmap->x)<<24)) & 0xFF000000);
  cmap->m = cmap->y;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgtosaxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF;
  address_code = (((uintptr_t)cmap->m)<<24);
  cmap->m = cmap->a & cmap->x;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadzpgytosaxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = ((cmap->address_code+(((uintptr_t)cmap->y)<<24)) & 0xFF000000);
  cmap->m = cmap->a & cmap->x;
  R6502_JUMP_TO_ZPG_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadabstosaxstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  cmap->m = cmap->a & cmap->x;
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502fixindexedtoaxastep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->y)<<16);
  unsigned int anded = cmap->a & cmap->x;
  uintptr_t address_code = cmap->address_fix_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0x01000000)
  {
    cmap->m = anded & (address_code>>24);
    address_code = (((uintptr_t)cmap->m)<<24) | (address_code & 0x00FFFFFF);
  }
  else
    cmap->m = anded & ((address_code>>24)+1);
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502fixindexedtoxasstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->y)<<16);
  uintptr_t address_code = cmap->address_fix_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0x01000000)
  {
    cmap->m = cmap->x & (address_code>>24);
    address_code = (((uintptr_t)cmap->m)<<24) | (address_code & 0x00FFFFFF);
  }
  else
    cmap->m = cmap->x & ((address_code>>24)+1);
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502fixindexedtosaystep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->x)<<16);
  uintptr_t address_code = cmap->address_fix_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0x01000000)
  {
    cmap->m = cmap->y & (address_code>>24);
    address_code = (((uintptr_t)cmap->m)<<24) | (address_code & 0x00FFFFFF);
  }
  else
    cmap->m = cmap->y & ((address_code>>24)+1);
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502fixindexedtotasstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t sum = cmap->latch + (((uintptr_t)cmap->y)<<16);
  unsigned int anded = cmap->a & cmap->x;
  uintptr_t address_code = cmap->address_fix_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (anded<<24);
  if (sum & 0x01000000)
  {
    cmap->m = anded & (address_code>>24);
    address_code = (((uintptr_t)cmap->m)<<24) | (address_code & 0x00FFFFFF);
  }
  else
    cmap->m = anded & ((address_code>>24)+1);
  R6502_JUMP_TO_WRITE_OP(cmap, address_code)
}

R6502CPUMAP* r6502pushedstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  R6502_IMPLIED_NEXT_INSTRUCTION(cmap)
}

// BRANCH_STEP
R6502CPUMAP* r6502bplstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & NFLAG)
    R6502_NEXT_INSTRUCTION(cmap, address_code)
  else
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
}

R6502CPUMAP* r6502bmistep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & NFLAG)
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
  else
    R6502_NEXT_INSTRUCTION(cmap, address_code)
}

R6502CPUMAP* r6502bvcstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & VFLAG)
    R6502_NEXT_INSTRUCTION(cmap, address_code)
  else
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
}

R6502CPUMAP* r6502bvsstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & VFLAG)
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
  else
    R6502_NEXT_INSTRUCTION(cmap, address_code)
}

R6502CPUMAP* r6502bccstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & CFLAG)
    R6502_NEXT_INSTRUCTION(cmap, address_code)
  else
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
}

R6502CPUMAP* r6502bcsstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & CFLAG)
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
  else
    R6502_NEXT_INSTRUCTION(cmap, address_code)
}

R6502CPUMAP* r6502bnestep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & ZFLAG)
    R6502_NEXT_INSTRUCTION(cmap, address_code)
  else
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
}

R6502CPUMAP* r6502beqstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  address_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (cmap->ps & ZFLAG)
  {
    cmap->latch = (((uintptr_t)cmap->m)<<16);
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
  else
    R6502_NEXT_INSTRUCTION(cmap, address_code)
}

R6502CPUMAP* r6502branchtakenstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  R6502ZONEMAP* zmap = (R6502ZONEMAP*)cmap;
  uintptr_t address_code = cmap->sync_pc_code + 0x20000;
  uintptr_t sum = cmap->latch;
  if (sum & 0x800000)
    sum |= 0xFF000000;
  sum = ((address_code & 0x00FFFFFF) + sum) & 0xFFFFFFFF;
  address_code = (address_code & 0xFF000000) | (sum & 0x00FFFFFF);
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  if (sum & 0xFF000000)
  {
    cmap->address_fix_code = (address_code + (sum & 0xFF000000)) & 0xFFFFFFFF;
    R6502_JUMP_TO_READ_OP(cmap, address_code)
  }
  else
  {
    if (cmap->transition1action == cmap->interruptfetchaction)
    {
      cmap->sync_pc_code = address_code;
      cmap->cpu_state = cmap->sequences[R6502_DECODE_SEQUENCE];

      if (cmap->timesinterruptmissed < 256)
      {
        cmap->timesinterruptmissed++;
      }
      else if (cmap->transition2action == cmap->yieldaction)
      {
        cmap->transition2action = cmap->fetchaction;
        cmap->yieldflagaction(zmap);
      }
      R6502_JUMP_TO_READ_OP(cmap, address_code)
    }
    else
      R6502_NEXT_INSTRUCTION(cmap, address_code)
  }
}

R6502CPUMAP* r6502fixbranchtakenstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  return cmap->transition1action(cmap, cmap->address_fix_code);
}

// JUMPS
R6502CPUMAP* r6502latchjmpabsindlostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (cmap->address_code & 0xFF000000) | ((cmap->address_code+0x10000) & 0x00FFFFFF);
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502loadpchstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  R6502_NEXT_INSTRUCTION(cmap, address_code)
}

// VECTORS AND SUBROUTINES
R6502CPUMAP* r6502waitonresetstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  if (cmap->lbreak)
  {
    if (!(cmap->nmis & NMIS_OLDRESET))
    {
      cmap->nmis |= NMIS_OLDRESET;
      cmap->resetstartingaction((R6502ZONEMAP*)cmap);
    }

    R6502_JUMP_WITHOUT_BUS_OP(cmap)
  }
  else
  {
    cmap->cpu_state = (R6502OP*)incremented_cpu_state;

    if (!(cmap->nmis & NMIS_OLDRESET))
    {
      cmap->nmis |= NMIS_OLDRESET;
      cmap->resetstartingaction((R6502ZONEMAP*)cmap);
    }

    cmap->nmis &= NMIS_NOTOLDRESET;
    cmap->resetcontinuingaction((R6502ZONEMAP*)cmap);
    R6502_JUMP_TO_READ_OP(cmap, (cmap->sync_pc_code + 0x10000) & 0xFFFFFFFF)
  }
}

R6502CPUMAP* r6502resetstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502notpushedtonotpushstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502breadcrumbnotpushedtoresetlostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->ps |= IFLAG;
  cmap->address_code = 0xFFFC0000 | BUS_BASEFLAG;
  cmap->transition1action = cmap->transition2action;
  R6502_CHECK_FOR_BREAK(cmap)
  R6502_JUMP_TO_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502pushedtopushpclstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->m = ((cmap->sync_pc_code>>16) & 0xFF);
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502pushedtopushpstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->m = cmap->ps;
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502pushedtopushpwithoutbstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->m = cmap->ps & NOTBFLAG;
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502breadcrumbpushedtointerruptlostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->ps |= IFLAG;
  if ((cmap->nmis & NMIS_NMI) && !(cmap->nmis & NMIS_OLDNMI))
  {
    cmap->nmis |= NMIS_OLDNMI;
    cmap->address_code = 0xFFFA0000 | BUS_BASEFLAG;
  }
  else
    cmap->address_code = 0xFFFE0000 | BUS_BASEFLAG;
  cmap->transition1action = cmap->transition2action;
  R6502_CHECK_FOR_BREAK(cmap)
  R6502_JUMP_TO_READ_OP(cmap, cmap->address_code)
}

R6502CPUMAP* r6502latchveclostep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  uintptr_t address_code;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  address_code = (cmap->address_code+0x10000) & 0xFFFFFFFF;
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_READ_OP(cmap, address_code)
}

R6502CPUMAP* r6502tobrkpushpchstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->sync_pc_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  return r6502topushpchstep(cmap, incremented_cpu_state);
}

R6502CPUMAP* r6502topushpchstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = ((cmap->sync_pc_code>>24) & 0xFF);
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502latchabslobeforepushstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (cmap->sync_pc_code + 0x20000) & 0xFFFFFFFF;
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502tojsrpushpchstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->m = ((cmap->last_pc_code>>24) & 0xFF);
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502pushedtojsrpushpclstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  cmap->m = ((cmap->last_pc_code>>16) & 0xFF);
  R6502_JUMP_TO_STACK_WRITE_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502pushedtoloadpchstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code - 0x1000000) & 0xFFFFFFFF;
  R6502_JUMP_TO_READ_OP(cmap, cmap->last_pc_code)
}

R6502CPUMAP* r6502pulledptopullstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  unsigned char ps_old = cmap->ps;
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code + 0x1000000) & 0xFFFFFFFF;
  cmap->ps = cmap->m | UFLAG | BFLAG;
  if (ps_old & IFLAG)
  {
    if (!(cmap->ps & IFLAG) && cmap->irq)
    {
      if (cmap->transition1action == cmap->fetchaction || cmap->transition1action == cmap->yieldaction)
      {
        cmap->transition1action = cmap->interruptfetchaction;
        R6502_CHECK_FOR_BREAK(cmap)
      }
    }
  }
  else if (cmap->ps & IFLAG)
  {
    if (cmap->transition1action == cmap->interruptfetchaction)
    {
      if (!(cmap->nmis & NMIS_NMI) || (cmap->nmis & NMIS_OLDNMI))
      {
        cmap->transition1action = cmap->transition2action;
        R6502_CHECK_FOR_BREAK(cmap)
      }
    }
  }
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502pulledpclstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->sp_code = (cmap->sp_code + 0x1000000) & 0xFFFFFFFF;
  cmap->latch = (((uintptr_t)cmap->m)<<16);
  R6502_JUMP_TO_STACK_READ_OP(cmap, cmap->sp_code)
}

R6502CPUMAP* r6502loadpchtoincrementstep(R6502CPUMAP* cmap, uintptr_t incremented_cpu_state)
{
  cmap->cpu_state = (R6502OP*)incremented_cpu_state;
  cmap->last_pc_code = (((uintptr_t)cmap->m)<<24) | cmap->latch | BUS_BASEFLAG;
  R6502_JUMP_TO_READ_OP(cmap, cmap->last_pc_code)
}

R6502CPUMAP* r6502startyield(R6502CPUMAP* cmap)
{
  cmap->transition2action = cmap->yieldaction;

  if (cmap->transition1action == cmap->fetchaction)
  {
    cmap->transition1action = cmap->yieldaction;
    R6502_CHECK_FOR_BREAK(cmap)
  }
  return cmap;
}

R6502CPUMAP* r6502startinterrupt(R6502CPUMAP* cmap)
{
  if (cmap->transition1action == cmap->fetchaction || cmap->transition1action == cmap->yieldaction)
  {
    cmap->transition1action = cmap->interruptfetchaction;
    R6502_CHECK_FOR_BREAK(cmap)
  }
  return cmap;
}
#endif

static inline int r6502setsequences(R6502CPUMAP* cmap, int index, int count, const R6502OP* const *sequences)
{
  int lreturn;
  int i;
  const R6502OP* s;
  R6502OP* entry = &cmap->steps[index<<R6502_LOG2_MAX_SEQUENCE_LENGTH];

  lreturn = TRUE;

  for ( ; count > 0; count--)
  {
    s = *sequences++;

    i=0;
    if (s)
    {
      for (; s[i]; i++, entry++)
      {
        if (i == (1<<R6502_LOG2_MAX_SEQUENCE_LENGTH))
        {
          lreturn = FALSE;
          break;
        }

        *entry = s[i];
      }
    }
    for (; i<(1<<R6502_LOG2_MAX_SEQUENCE_LENGTH); i++, entry++)
    {
      *entry = NULL;
    }
  }

  return lreturn;
}

int r6502reset(R6502CPUMAP* cmap, const R6502OP* const *mainsequences, const R6502OP* const *extrasequences)
{
  R6502OP* entry = cmap->steps;
  R6502OP* s;
  int i;

  /*it is assumed that shift fields for AArch32 byte/word aliasing
   have been initialised to zero at load time or by calloc()*/

  cmap->irq = 0;
  cmap->nmis = 0;
  cmap->lbreak = FALSE;

  cmap->sync_pc_code = BUS_BASEFLAG;
  cmap->sp_code = 0xFF000000;
  cmap->ps = UFLAG | BFLAG;

  if (!r6502setsequences(cmap, 0, R6502_MAIN_SEQUENCE_COUNT, mainsequences))
    return TRUE;

  if (!r6502setsequences(cmap, R6502_MAIN_SEQUENCE_COUNT, R6502_EXTRA_SEQUENCE_COUNT, extrasequences))
    return TRUE;

  for (i=0; i<R6502_SEQUENCE_COUNT; i++)
  {
    cmap->sequences[i] = entry;
    entry += (1<<R6502_LOG2_MAX_SEQUENCE_LENGTH);
  }

  s = cmap->sequences[R6502_OPCODE_07_SEQUENCE];
  if (*s)
  {
    cmap->sequences[R6502_OPCODE_07_SEQUENCE] = cmap->sequences[0x07];
    cmap->sequences[0x07] = s;
  }

  cmap->yieldaction = r6502yield;
  cmap->fetchaction = r6502fetch;
  cmap->interruptfetchaction = r6502interruptfetch;
  cmap->fetchthentestirqaction = r6502fetchthentestirq;
  cmap->resetaction = r6502enterreset;

  cmap->transition1action = cmap->fetchaction;
  cmap->transition2action = cmap->fetchaction;
  cmap->timesinterruptmissed = 0;

  cmap->cpu_state = cmap->sequences[R6502_RESET_SEQUENCE];
  cmap->address_code = (cmap->address_code & 0xFFFF0000) | BUS_BASEFLAG;

  return FALSE;
}

void r6502aftersnapshot(R6502CPUMAP* cmap)
{
  char buffer[1];

  r6502readmemory(cmap, buffer, cmap->sync_pc_code, 1);
  cmap->m = buffer[0];
  cmap->cpu_state = cmap->sequences[R6502_DECODE_SEQUENCE];
}

static inline R6502CPUMAP* r6502readmemorystep(R6502CPUMAP* cmap, intptr_t incremented_cpu_state)
{
  R6502_JUMP_TO_READ_OP(cmap, cmap->address_code)
}

void r6502readmemory(R6502CPUMAP* cmap, char* buffer, uintptr_t naddress, int ncount)
{
  uintptr_t savedaddresscode = cmap->address_code;
  R6502OP* savedcpustate = cmap->cpu_state;
  unsigned char savedm = cmap->m;

  cmap->address_code = ((naddress<<16) & 0xFFFF0000) | BUS_BASEFLAG;
  cmap->cpu_state = cmap->sequences[0xEA];

  for ( ; ncount > 0; ncount--, buffer++)
  {
    r6502readmemorystep(cmap, (intptr_t)(cmap->cpu_state+1));

    while (cmap->cpu_state != cmap->sequences[0xEA])
    {
      (*cmap->cpu_state)(cmap, (intptr_t)cmap->cpu_state+1);
    }
    *buffer = cmap->m;
    cmap->address_code = (cmap->address_code + 0x10000) & 0xFFFFFFFF;
  }

  cmap->address_code = savedaddresscode;
  cmap->cpu_state = savedcpustate;
  cmap->m = savedm;
}
