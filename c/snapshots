#include <stdio.h>
#include <string.h>

#include "hostmap.h"
#include "beebit.h"
#include "snapshots.h"
#include "6502cpu.h"
#include "6522sysvia.h"
#include "6522usrvia.h"
#include "video.h"
#include "6845crtc.h"
#include "videoula.h"
#include "sheila.h"



void snapshotload(FILE *hfile)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  SNAPHDR readhdr;
  void *pfile =&readhdr;
  int r,p;
  rewind(hfile);
  fread(pfile,1,sizeof(SNAPHDR),hfile);
      /*sheila*/
      /*fread(sheila_b,1,0x100,hfile);*/
      /*for (i=0;i<0x100;i++)
      {
        if (sheila_b[i] != 0xFE)
          sheilawrite(0xFE00+i,sheila_b[i]);
      }*/
//      for (int i=0;i<0x100;i++)
//      {
//        if (readhdr.sheila[i] != 0xFE) sheilawrite(0xFE00+i,readhdr.sheila[i]);
//      }

      /*6502 a register*/
//      fread(cbuffer,1,4,hfile); /*0*/
//      r6502_a = cbuffer[3];
  /*&FE00 - &FE07 (CRTC)*/
  /*&FE08 - &FE0F (ACIA)*/
  /*&FE10 - &FE17 (SERIALULA)*/
  /*&FE18 - &FE1F (SERIALULA/ADC)*/
  /*&FE20 - &FE23 (VIDEOULA)*/
  /*&FE24 - &FE27 (VIDEOULA/FDC INTERFACE CONTROL REG)*/
  /*&FE28 - &FE2F (VIDEOULA/FDC INTERFACE)*/
  /*&FE30 - &FE33 (ROMSEL)*/
  /*&FE34 - &FE37 (ACCCON)*/
  //    hmap->acccon = cbuffer[0x34];
  /*&FE38 - &FE3B (INTOFF)*/
  /*&FE3C - &FE3F (INTON)*/
  /*&FE40 - &FE5F (SYSTEMVIA)*/
  hmap->A_sysvia.orb =hmap->A_sysvia.portb =readhdr.sheila[0x40];
  hmap->A_sysvia.ora =hmap->A_sysvia.porta =readhdr.sheila[0x41];
  hmap->A_sysvia.ddrb =readhdr.sheila[0x42];
  hmap->A_sysvia.ddra =readhdr.sheila[0x43];
  hmap->A_sysvia.sr =readhdr.sheila[0x4A];
  hmap->A_sysvia.acr =readhdr.sheila[0x4B];
  hmap->A_sysvia.pcr =readhdr.sheila[0x4C];
  /*&FE60 - &FE7F (USERVIA)*/
  hmap->A_usrvia.orb =hmap->A_usrvia.portb =readhdr.sheila[0x60];
  hmap->A_usrvia.ora =hmap->A_usrvia.porta =readhdr.sheila[0x61];
  hmap->A_usrvia.ddrb =readhdr.sheila[0x62];
  hmap->A_usrvia.ddra =readhdr.sheila[0x63];
  hmap->A_usrvia.sr =readhdr.sheila[0x6A];
  hmap->A_usrvia.acr =readhdr.sheila[0x6B];
  hmap->A_usrvia.pcr =readhdr.sheila[0x6C];
  /*&FE80 - &FE9F (8271 or 1770)*/
  /*&FEC0 - &FEDF (ADC)*/



  cmap->a =readhdr.A;
//      fread(cbuffer,1,4,hfile); /*4*/
//      r6502_x = cbuffer[3];
  cmap->x =readhdr.X;

//      fread(cbuffer,1,4,hfile); /*8*/
//      r6502_y = cbuffer[3];
  cmap->y =readhdr.Y;

//      fread(cbuffer,1,4,hfile); /*12*/
      /*r6502_n = (cbuffer[0] & 0x80);
      r6502_v = (cbuffer[0] & 0x40);
      r6502_b = (cbuffer[0] & 0x10);
      r6502_d = (cbuffer[0] & 0x08);
      r6502_i = (cbuffer[0] & 0x04);
      r6502_z = (cbuffer[0] & 0x02);
      r6502_c = (cbuffer[0] & 0x01);*/
//      r6502_ps = cbuffer[0];
  cmap->ps =readhdr.P | UFLAG | BFLAG;

//      fread(cbuffer,1,4,hfile); /*16*/
//      r6502_sp = cbuffer[3] ;
  cmap->sp_code =((readhdr.S<<24)&0xFF000000);
      /*program counter*/
//      fread(cbuffer,1,4,hfile); /*20*/
//      r6502_pc = (cbuffer[1]<<8)+cbuffer[0];
  cmap->sync_pc_code =((readhdr.PC<<16)&0xFFFF0000) | BUS_BASEFLAG;

      /*timers*/
//      fread(cbuffer,1,4,hfile); /*24*/
//      hmap->A_sysvia.t1setint = cbuffer[0];
//      hmap->A_sysvia.t2setint = cbuffer[1];
//      hmap->A_usrvia.t1setint = cbuffer[2];
//      hmap->A_usrvia.t2setint = cbuffer[3];
  hmap->A_sysvia.t1setint =readhdr.Tim1mode;
  hmap->A_sysvia.t2setint =readhdr.Tim2mode;
  hmap->A_usrvia.t1setint =readhdr.Tim3mode;
  hmap->A_usrvia.t2setint =readhdr.Tim4mode;
   //in snapshots 1 =interupt, but beebit set them as TRUE(0xFF) however as
   // beebit never compares with TRUE it seems to work
      /*system via timer 1 counter*/
//     fread(cbuffer,1,4,hfile); /*28*/
//     hmap->A_sysvia.t1ch = cbuffer[3];
//     hmap->A_sysvia.t1cl = cbuffer[2];
//     hmap->A_sysvia.t1 = (hmap->A_sysvia.t1ch<<9)+(hmap->A_sysvia.t1cl<<1);
  hmap->B_sysvia.t1doubled =(readhdr.Tim1)<<1;
      /*system via timer 1 latches*/
//      fread(cbuffer,1,4,hfile); /*32*/
//      hmap->A_sysvia.t1lh = cbuffer[3];
//      hmap->A_sysvia.t1ll = cbuffer[2];
  hmap->A_sysvia.t1lh =(readhdr.Tim1latch)>>8;
  hmap->A_sysvia.t1ll =(readhdr.Tim1latch) & 0xFF;
      /*system via timer 2 counter*/
//      fread(cbuffer,1,4,hfile); /*36*/
//      hmap->A_sysvia.t2ch = cbuffer[3];
//      hmap->A_sysvia.t2cl = cbuffer[2];
//      hmap->A_sysvia.t2 = (hmap->A_sysvia.t2ch<<9)+(hmap->A_sysvia.t2cl<<1);
  hmap->B_sysvia.t2doubled =(readhdr.Tim2)<<1;
      /*system via timer 2 latches*/
//      fread(cbuffer,1,4,hfile); /*40*/
//      hmap->A_sysvia.t2ll = cbuffer[3];
  hmap->A_sysvia.t2ll =(readhdr.Tim2latch) & 0xFF; //this wont work!

      /*user via timer 1 counter*/
//      fread(cbuffer,1,4,hfile); /*44*/
//      hmap->A_usrvia.t1ch = cbuffer[3];
//      hmap->A_usrvia.t1cl = cbuffer[2];
//      hmap->A_usrvia.t1 = (hmap->A_usrvia.t1ch<<9)+(hmap->A_usrvia.t1cl<<1);
  hmap->B_usrvia.t1doubled =(readhdr.Tim3)<<1;
      /*user via timer 1 latches*/
//      fread(cbuffer,1,4,hfile); /*48*/
//      hmap->A_usrvia.t1lh = cbuffer[3];
//      hmap->A_usrvia.t1ll = cbuffer[2];
  hmap->A_usrvia.t1lh =(readhdr.Tim3latch)>>8;
  hmap->A_usrvia.t1ll =(readhdr.Tim3latch) & 0xFF;
      /*user via timer 2 counter*/
//      fread(cbuffer,1,4,hfile); /*52*/
//      hmap->A_usrvia.t2ch = cbuffer[3];
//      hmap->A_usrvia.t2cl = cbuffer[2];
//      hmap->A_usrvia.t2 = (hmap->A_usrvia.t2ch<<9)+(hmap->A_usrvia.t2cl<<1);
  hmap->B_usrvia.t2doubled =(readhdr.Tim4)<<1;
      /*user via timer 2 latches*/
//      fread(cbuffer,1,4,hfile); /*56*/
//      hmap->A_usrvia.t2ll = cbuffer[3];
  hmap->A_usrvia.t2ll =(readhdr.Tim4latch) & 0xFF; //this wont work either!!

      /*timer to vertical sync*/
//      fread(cbuffer,1,4,hfile); /*60*/
//      video_timer = getword(cbuffer);
  hmap->cycles.video_togo =readhdr.Cvsync;

      /*unused*/
//      fread(cbuffer,1,4,hfile); /*64*/
//      fread(cbuffer,1,4,hfile); /*68*/
//      fread(cbuffer,1,4,hfile); /*72*/
//      fread(cbuffer,1,4,hfile); /*76*/
//      hmap->A_sysvia.ifr = cbuffer[0];
  hmap->A_sysvia.ifr =readhdr.SysVIAIFR;
//      hmap->A_sysvia.ier = cbuffer[1];
  hmap->A_sysvia.ier =readhdr.SysVIAIER;
//      hmap->A_usrvia.ifr = cbuffer[2];
  hmap->A_usrvia.ifr =readhdr.UserVIAIFR;
//      hmap->A_usrvia.ier = cbuffer[3];
  hmap->A_usrvia.ier =readhdr.UserVIAIER;

      /*unused*/
//     fread(cbuffer,1,4,hfile); /*80*/
//      fread(cbuffer,1,4,hfile); /*84*/
//      fread(cbuffer,1,4,hfile); /*88*/
//      fread(cbuffer,1,4,hfile); /*92*/
      /*roms*/
//      fread(cbuffer,1,4,hfile); /*96*/
//      hmap->romsel = cbuffer[0];
  hmap->romsel =readhdr.ROMSEL;
//      j = 0;
//      for (i=0;i<=0x03;i++)
//      {
//        fread(cbuffer,1,4,hfile); /*100,104,108,112*/
//        hmap->romwritable[j++] = cbuffer[0];
//        hmap->romwritable[j++] = cbuffer[1];
//        hmap->romwritable[j++] = cbuffer[2];
//        hmap->romwritable[j++] = cbuffer[3];
//      }
  for (r=0;r<=0xf;r++) //hmap->romwritable[r] =readhdr.rom[r];
  {
    char transrom[] ={1,0,0}; //translate from RAM/ROM/empty to RAM/ROM
    int read;

    read =readhdr.rom[r];
    if (read >2) read =2;

    hmap->romwritable[r] =transrom[read];
  }
      /*&FE20 - ignore for now*/
  hmap->m = readhdr.Sheila20; videoula00write(hmap, 0xFE200000); //video control register
//      fread(cbuffer,1,4,hfile); /*116*/
      /*6845 crtc*/
//      j = 0;
//      for (i=0;i<=0x03;i++)
//      {
//        fread(cbuffer,1,4,hfile); /*120,124,128,132*/
//        crtcwrite(0xFE00,j);
//        crtcwrite(0xFE01,cbuffer[0]);
//        j++;
//        crtcwrite(0xFE00,j);
//        crtcwrite(0xFE01,cbuffer[1]);
//        j++;
//        crtcwrite(0xFE00,j);
//        crtcwrite(0xFE01,cbuffer[2]);
//        j++;
//        crtcwrite(0xFE00,j);
//        crtcwrite(0xFE01,cbuffer[3]);
//        j++;
//      }
  for (r =0; r<0x10; r++)
  {
    hmap->m = r; crtc00write(hmap, 0xFE000000);
    hmap->m = readhdr.crtc[r]; crtc01write(hmap, 0xFE010000);
  }

//      fread(cbuffer,1,4,hfile); /*136*/
//      m6845_r[0x10] = cbuffer[0];
//      m6845_r[0x11] = cbuffer[1];
  m6845_r[0x10] =readhdr.crtc[0x10];
  m6845_r[0x11] =readhdr.crtc[0x11];
      /*register 19*/
//      hmap->screenstartindex = cbuffer[2];
  hmap->screenstartindex =readhdr.crtc[0x12];
      /*unused*/
//      fread(cbuffer,1,4,hfile); /*140*/
//      fread(cbuffer,1,4,hfile); /*144*/
      /*video ula palette registers*/
//      j = 0;
//      for (i=0;i<=0x03;i++)
//      {
//        fread(cbuffer,1,4,hfile); /*148,152,156,160*/
//        videoula_palette[j++] = cbuffer[0];
//        videoula_palette[j++] = cbuffer[1];
//        videoula_palette[j++] = cbuffer[2];
//        videoula_palette[j++] = cbuffer[3];
//      }
  for (p=0;p<=15;p++)
  {
    int read;
    read =readhdr.palette[p];
    hmap->m = (p<<4) +(read & 0xf); videoula01write(hmap, 0xFE210000);
// videoula_palette[p] =readhdr.palette[p];
  }

      /*unused*/
//      fread(cbuffer,1,4,hfile); /*164*/
//      fread(cbuffer,1,4,hfile); /*168*/
      /*acccon*/
//      fread(cbuffer,1,4,hfile); /*172*/
  hmap->acccon =readhdr.ACCCON;
      /*&FE10 - ignore*/
//      fread(cbuffer,1,4,hfile); /*176*/
      /*unused*/
//      fread(cbuffer,1,4,hfile); /*180*/
//      fread(cbuffer,1,4,hfile); /*184*/
//      fread(cbuffer,1,4,hfile); /*188*/
      /*timer to vertical sync - ignore*/
//      fread(cbuffer,1,4,hfile); /*192*/
      /*unused*/
//      fread(cbuffer,1,4,hfile); /*196*/
      /*extra 56 bytes until we to &210*/
//      for (i=0;i<=0x0D;i++)
//      {
//        fread(cbuffer,1,4,hfile);
//      }

  fseek(hfile,0x210 ,SEEK_SET);
  fread(&hmap->memory,1,0x8000,hfile);
  fclose(hfile);

  hostmapaftersnapshot();
}

void snapheadersave(SNAPHDR *phdr)
{
//  void *clear =&phdr;
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  int r,p;

  hostmapbeforesnapshot();

  memset(phdr,0,sizeof(SNAPHDR));
  strncpy(phdr ->tag,"BBC Snapshot101",0xf);
  phdr ->tag[0x0f] =0xa;

  r6502readmemory(cmap, phdr->sheila, 0xFE00, 0x100);

//  strncpy(phdr ->sheila,memory+0xFE00,0x100);


//  for (int l=0; l<sizeof(phdr); l++)
//  clear+l =0;
//  int i,j;
//  /*0=low/first byte*/
//  /*3=high/last byte*/
//  cbuffer[0] = 0;
//  cbuffer[1] = 0;
//  cbuffer[2] = 0;
//  cbuffer[3] = 0;
//  /* fprintf(hfile,"BBC Snapshot101"); */
//  wimpwrite("BBC Snapshot101",15,1);
//  /* fputc(0x0A,hfile);*/
//  wimpputc(0x0A);
//  /*sheila*/
////  fwrite(sheila_b,1,0x100,hfile);
//  wimpwrite(memory+0xFE00,1,0x100);
//
//  /*6502 a register*/
//  cbuffer[3] = r6502_a;
//  wimpwrite(cbuffer,1,4); /*0*/
  phdr ->A =cmap->a;

//  cbuffer[3] = r6502_x;
//  wimpwrite(cbuffer,1,4); /*4*/
  phdr ->X =cmap->x;
//  cbuffer[3] = r6502_y;
//  wimpwrite(cbuffer,1,4); /*8*/
  phdr ->Y =cmap->y;

//  cbuffer[3] = 0;
//  cbuffer[0] = r6502_ps; /*12*/
//  wimpwrite(cbuffer,1,4);
  phdr ->P =cmap->ps;
//  cbuffer[3] = r6502_sp;
//  /*cbuffer[0] = 1;*/
//  wimpwrite(cbuffer,1,4); /*16*/
  phdr ->S =(cmap->sp_code>>24)&0xFF;

//  /*program counter*/
//  setword(cbuffer,r6502_pc);
//  wimpwrite(cbuffer,1,4); /*20*/
  phdr ->PC =(int)(cmap->sync_pc_code>>16);
//  /*timers*/
//  cbuffer[0] = hmap->A_sysvia.t1setint;
//  cbuffer[1] = hmap->A_sysvia.t2setint;
//  cbuffer[2] = hmap->A_usrvia.t1setint;
//  cbuffer[3] = hmap->A_usrvia.t2setint;
//  wimpwrite(cbuffer,1,4); /*24*/
  phdr ->Tim1mode =hmap->A_sysvia.t1setint;
  phdr ->Tim2mode =hmap->A_sysvia.t2setint;
  phdr ->Tim3mode =hmap->A_usrvia.t1setint;
  phdr ->Tim4mode =hmap->A_usrvia.t2setint;
//  setword(cbuffer,0);
//  /*system via timer 1 counter*/
//  hmap->A_sysvia.t1ch = ((hmap->A_sysvia.t1>>9) & 0xFF);
//  hmap->A_sysvia.t1cl = ((hmap->A_sysvia.t1>>1) & 0xFF);
//  cbuffer[3] = hmap->A_sysvia.t1ch;
//  cbuffer[2] = hmap->A_sysvia.t1cl;
//  wimpwrite(cbuffer,1,4); /*28*/
  phdr ->Tim1 =(int)(hmap->B_sysvia.t1doubled >>1);
//  /*system via timer 1 latches*/
//  cbuffer[3] = hmap->A_sysvia.t1lh;
//  cbuffer[2] = hmap->A_sysvia.t1ll;
//  wimpwrite(cbuffer,1,4); /*32*/
  phdr ->Tim1latch =hmap->A_sysvia.t1ll +(hmap->A_sysvia.t1lh <<8);
//  /*system via timer 2 counter*/
//  hmap->A_sysvia.t2ch = ((hmap->A_sysvia.t2>>9) & 0xFF);
//  hmap->A_sysvia.t2cl = ((hmap->A_sysvia.t2>>1) & 0xFF);
//  cbuffer[3] = hmap->A_sysvia.t2ch;
//  cbuffer[2] = hmap->A_sysvia.t2cl;
//  wimpwrite(cbuffer,1,4); /*36*/
  phdr ->Tim2 =(int)(hmap->B_sysvia.t2doubled >>1);
//  /*system via timer 2 latches*/
//  cbuffer[3] = hmap->A_sysvia.t2ll;
//  cbuffer[2] = 0;
//  wimpwrite(cbuffer,1,4); /*40*/
  phdr ->Tim2latch =hmap->A_sysvia.t2ll;

//  /*user via timer 1 counter*/
//  hmap->A_usrvia.t1ch = ((hmap->A_usrvia.t1>>9) & 0xFF);
//  hmap->A_usrvia.t1cl = ((hmap->A_usrvia.t1>>1) & 0xFF);
//  cbuffer[3] = hmap->A_usrvia.t1ch;
//  cbuffer[2] = hmap->A_usrvia.t1cl;
//  wimpwrite(cbuffer,1,4); /*44*/
  phdr ->Tim3 =(int)(hmap->B_usrvia.t1doubled >>1);

//  /*user via timer 1 latches*/
//  cbuffer[3] = hmap->A_usrvia.t1lh;
//  cbuffer[2] = hmap->A_usrvia.t1ll;
//  wimpwrite(cbuffer,1,4); /*48*/
  phdr ->Tim3latch =hmap->A_usrvia.t1ll +(hmap->A_usrvia.t1lh <<8);
//  /*user via timer 2 counter*/
//  hmap->A_usrvia.t2ch = ((hmap->A_usrvia.t2>>9) & 0xFF);
//  hmap->A_usrvia.t2cl = ((hmap->A_usrvia.t2>>1) & 0xFF);
//  cbuffer[3] = hmap->A_usrvia.t2ch;
//  cbuffer[2] = hmap->A_usrvia.t2cl;
//  wimpwrite(cbuffer,1,4); /*52*/
  phdr ->Tim4 =(int)(hmap->B_usrvia.t2doubled >>1);
//  /*user via timer 2 latches*/
//  cbuffer[3] = hmap->A_usrvia.t2ll;
//  cbuffer[2] = 0;
//  wimpwrite(cbuffer,1,4); /*56*/
  phdr ->Tim4latch =hmap->A_usrvia.t2ll;
//  /*timer to vertical sync*/
//  setword(cbuffer,video_timer);
//  wimpwrite(cbuffer,1,4); /*60*/
  phdr ->Cvsync =(int)hmap->cycles.video_togo;
//  /*unused*/
//  setword(cbuffer,0);
//  wimpwrite(cbuffer,1,4); /*64*/
//  wimpwrite(cbuffer,1,4); /*68*/
//  wimpwrite(cbuffer,1,4); /*72*/
//  cbuffer[0] = hmap->A_sysvia.ifr;
//  cbuffer[1] = hmap->A_sysvia.ier;
//  cbuffer[2] = hmap->A_usrvia.ifr;
//  cbuffer[3] = hmap->A_usrvia.ier;
//  wimpwrite(cbuffer,1,4); /*76*/
  phdr ->SysVIAIFR =hmap->A_sysvia.ifr;
  phdr ->SysVIAIER =hmap->A_sysvia.ier;
  phdr ->UserVIAIFR =hmap->A_usrvia.ifr;
  phdr ->UserVIAIER =hmap->A_usrvia.ier;

//  /*unused*/
//  setword(cbuffer,0);
//  wimpwrite(cbuffer,1,4); /*80*/
//  wimpwrite(cbuffer,1,4);
//  wimpwrite(cbuffer,1,4);
//  wimpwrite(cbuffer,1,4); /*92*/
//  /*roms*/
//  cbuffer[0] = hmap->romsel;
//  wimpwrite(cbuffer,1,4); /*96*/
  phdr ->ROMSEL =hmap->romsel;
//  j = 0;
//  for (i=0;i<=0x0F;i++)
//  {
//    if (hmap->romwritable[i])
//      cbuffer[j] = 0;    //wrong should be 0 for RAM!
//    else
//      cbuffer[j] = 1;
//    j++;
//    if (j > 3)
//    {
//      wimpwrite(cbuffer,1,4); /*100,104,108,112*/
//      j = 0;
//    }
//  }
  for (r =0; r<=0xf; r++)
  {
    phdr ->rom[r] =1;
    if (hmap->romwritable[r]) phdr ->rom[r] =0;
  }
//  setword(cbuffer,0);
//  /*&FE20*/
//  /*cbuffer[0] = sheila_b[0x20];*/
//  wimpwrite(cbuffer,1,4); /*116*/
  phdr ->Sheila20 =videoularead(0);
//  /*6845 crtc*/
//  j = 0;
//  for (i=0;i<=0x0F;i++)
//  {
//    cbuffer[j] = m6845_r[i];
//    j++;
//    if (j > 3)
//    {
//      wimpwrite(cbuffer,1,4); /*120,124,128,132*/
//      j = 0;
//    }
//  }
  for (r =0; r<0x12; r++)
  {
    phdr ->crtc[r] =m6845_r[r];
  }

//  cbuffer[0] = m6845_r[0x10];
//  cbuffer[1] = m6845_r[0x11];

//  /*register 19*/
//  cbuffer[2] = hmap->screenstartindex;
//  cbuffer[3] = 0;
//  wimpwrite(cbuffer,1,4); /*136*/
    phdr ->crtc[0x12] =hmap->screenstartindex;
//  /*unused*/
//  setword(cbuffer,0);
//  wimpwrite(cbuffer,1,4); /*140*/
//  wimpwrite(cbuffer,1,4); /*144*/
//  /*video ula palette registers*/
//  j = 0;
//  for (i=0;i<=0x0F;i++)
//  {
//    cbuffer[j] = videoula_palette[i];
//    j++;
//    if (j > 3)
//    {
//      wimpwrite(cbuffer,1,4); /*148,152,156,160*/
//      j = 0;
//    }
//  }
  for (p =0; p<=15; p++)
   phdr ->palette[p] =videoularead(p+1);

//  /*unused*/
//  setword(cbuffer,0);
//  wimpwrite(cbuffer,1,4); /*164*/
//  wimpwrite(cbuffer,1,4); /*168*/
//  /*acccon*/
//  wimpwrite(cbuffer,1,4); /*172*/
//  /*&FE10*/
//  /*cbuffer[3] = sheila_b[0x10];*/
//  wimpwrite(cbuffer,1,4); /*176*/
//  /*unused*/
//  cbuffer[3] = 0;
//  wimpwrite(cbuffer,1,4); /*180*/
//  wimpwrite(cbuffer,1,4); /*184*/
//  wimpwrite(cbuffer,1,4); /*188*/
//  /*timer to vertical sync*/
//  setword(cbuffer,video_timer);
//  wimpwrite(cbuffer,1,4); /*192*/
//  /*unused*/
//  setword(cbuffer,0);
//  wimpwrite(cbuffer,1,4); /*196*/
//  /*fill up extra 56 bytes until we to &210*/
//  for (i=0;i<=0x0D;i++)
//  {
//    wimpwrite(cbuffer,1,4);
//  }
//
//
//
//}

  hostmapaftersnapshot();
}
