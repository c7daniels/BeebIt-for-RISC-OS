/*>videoula.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Acorn Video ULA [1MHz]
 *
 * Cycle-level video emulation
 *
 * (C) Copyright Crispian Daniels, 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

/* Bit assignments in control reg:
   0 - Flash colour (0=first colour, 1=second)
   1 - Teletext select (0=on chip serialiser, 1=teletext)
 2,3 - Bytes per line (2,3=1,1 is 80, 1,0=40, 0,1=20, 0,0=10)
   4 - Clock chip select (0=low frequency (1MHz),1=high frequency (2MHz))
 5,6 - Cursor width in bytes (00=1 byte, 01=not defined, 10=2, 11=4)
   7 - Master cursor width (if set causes large cursor)
*/

#include <assert.h>
#include <stddef.h>
#include <string.h>
#include "hostmap.h"
#include "videoula.h"
#include "video.h"
#include "sheila.h"
#include "beebit.h"

/*Video ULA*/

void videoulainit(void)
{
  HOSTMAP* hmap = &hostmap;
  int i;
  uint8_t bytemapping[256];
  unsigned int pixelcolour;
  unsigned int bytecolours1,bytecolours2,bytecolours3;

  for (i=0; i<256; i++)
  {
    bytemapping[i] = ((i&0x80)>>4)|((i&0x20)>>3)|((i&0x08)>>2)|((i&0x02)>>1);
  }

  for (i=0; i<256; i++)
  {
    pixelcolour = bytemapping[i];
    bytecolours3 = (pixelcolour<<28);
    pixelcolour |= (pixelcolour<<4);
    bytecolours2 = (pixelcolour<<24);
    pixelcolour |= (pixelcolour<<8);
    bytecolours1 = (pixelcolour<<16);
    hmap->shiftedbytecolours[i] = bytecolours1 | pixelcolour;

    pixelcolour = bytemapping[((i<<1)&0xFF)|0x01];
    bytecolours3 |= (pixelcolour<<24);
    pixelcolour |= (pixelcolour<<4);
    bytecolours2 |= (pixelcolour<<16);
    pixelcolour |= (pixelcolour<<8);
    hmap->shiftedbytecolours[256+i] = bytecolours1 | pixelcolour;

    pixelcolour = bytemapping[((i<<2)&0xFF)|0x03];
    bytecolours3 |= (pixelcolour<<20);
    pixelcolour |= (pixelcolour<<4);
    bytecolours2 |= (pixelcolour<<8);

    pixelcolour = bytemapping[((i<<3)&0xFF)|0x07];
    bytecolours3 |= (pixelcolour<<16);
    pixelcolour |= (pixelcolour<<4);
    hmap->shiftedbytecolours[512+i] = bytecolours2 | pixelcolour;

    pixelcolour = bytemapping[((i<<4)&0xFF)|0x0F];
    bytecolours3 |= (pixelcolour<<12);

    pixelcolour = bytemapping[((i<<5)&0xFF)|0x1F];
    bytecolours3 |= (pixelcolour<<8);

    pixelcolour = bytemapping[((i<<6)&0xFF)|0x3F];
    bytecolours3 |= (pixelcolour<<4);

    pixelcolour = bytemapping[((i<<7)&0xFF)|0x7F];
    hmap->shiftedbytecolours[768+i] = bytecolours3 | pixelcolour;
  }
}

static inline int getnphys(HOSTMAP* hmap, int nlogical)
{
  int nphys2 = hmap->A_videoula.palette[nlogical];
  int nphys = nphys2 ^ 0x7;

  if (hmap->A_videoula.control & (hmap->B_videoula.flashing>>nphys) & 1)
    return nphys2;
  else
    return nphys;
}

static HOSTMAP* videoularefreshnybblefragments(HOSTMAP* hmap, uintptr_t* fill)
{
  int i;
  uint8_t* bytefragment = (uint8_t*)hmap->D_colour.fragment;

  for (i=0; i<16; i++)
  {
    bytefragment[i] = fill[getnphys(hmap, i)] & 0xF;
  }

  return hmap;
}

static HOSTMAP* videoularefreshbytefragments(HOSTMAP* hmap, uintptr_t* fill)
{
  int i;
  uint8_t* bytefragment = (uint8_t*)hmap->D_colour.fragment;

  for (i=0; i<16; i++)
  {
    bytefragment[i] = fill[getnphys(hmap, i)] & 0xFF;
  }

  return hmap;
}

void videoulareset(void)
{
  HOSTMAP* hmap = &hostmap;
  int i;

  hmap->A_videoula.control = 0;
  hmap->B_videoula.bytelut = hmap->shiftedbytecolours;
  hmap->B_videoula.flashing = 0xFF00;
  for (i=0; i<16; i++)
  {
    hmap->A_videoula.palette[i] = 0;
  }

  hmap->B_videoula.evenloadop = 0;
  hmap->B_videoula.evenRloadop = 0;
  hmap->B_videoula.oddloadop = 0;
  hmap->B_videoula.oddRloadop = 0;
  hmap->B_videoula.selectedevenloadop = 0;
  hmap->B_videoula.selectedevenRloadop = 0;
}

static inline void videoulasetfragmentops(HOSTHIGHOP write01, VIDEOULAFRAGMENTREFRESHOP refreshop)
{
  HOSTMAP* hmap = &hostmap;
  HOSTHIGHOP writes[4] = { videoula00write, write01, videoula00write, write01 };

  hmap->B_videoula.fragmentrefreshaction = refreshop;
  sheilareplacevideoulawrites(&writes);
}

void videoulasetloads(int oneslice)
{
  HOSTMAP* hmap = &hostmap;
  int evenloadintercept;
  const VIDEOULALOADOP (*selectedset)[32];
  VIDEOULALOADOP *loadopgroup;

  if (oneslice)
    selectedset = &videoulaoloadset;
  else if (hmap->A_vidbuf.progressive)
    selectedset = &videoulaploadset;
  else
    selectedset = &videoulaloadset;

  memcpy(hmap->videoulaloads, selectedset, 32 * sizeof(VIDEOULALOADOP));

  loadopgroup = &hmap->videoulaloads[hmap->A_videoula.control & 0x1C];
  evenloadintercept = hmap->B_videoula.evenloadop != 0;

  if (!evenloadintercept)
  {
    hmap->B_videoula.evenloadop = loadopgroup[0];
    hmap->B_videoula.evenRloadop = loadopgroup[1];
  }
  hmap->B_videoula.selectedevenloadop = loadopgroup[0];
  hmap->B_videoula.selectedevenRloadop = loadopgroup[1];
  hmap->B_videoula.oddloadop = loadopgroup[2];
  hmap->B_videoula.oddRloadop = loadopgroup[3];
}

void videoulaclearloads(void)
{
  HOSTMAP* hmap = &hostmap;
  int evenloadintercept = hmap->B_videoula.evenloadop != hmap->B_videoula.selectedevenloadop;

  if (!evenloadintercept)
  {
    hmap->B_videoula.evenloadop = 0;
    hmap->B_videoula.evenRloadop = 0;
  }
  hmap->B_videoula.selectedevenloadop = 0;
  hmap->B_videoula.selectedevenRloadop = 0;
  hmap->B_videoula.oddloadop = 0;
  hmap->B_videoula.oddRloadop = 0;
}

static HOSTMAP* videoulasetblacklevelnphys(HOSTMAP* hmap, int nphys)
{
  int i,mask;

  hmap->A_videoula.blacklevelnphys = nphys;
  mask = 15 ^ (nphys&7);

  for (i=0; i<16; i++)
  {
    hmap->D_colour.normalfill[i] = hmap->D_colour.absolutefill[i&mask];
    hmap->D_colour.inversefill[i] = hmap->D_colour.absolutefill[(i^7)&mask];
  }

  hmap->B_videoula.inverseblank = hmap->D_colour.inversefill[0];
  hmap->B_videoula.cursorfill = hmap->B_videoula.inverseblank;

  for (i=0; i<8; i++)
    hmap->B_teletext.colourfill[i] = hmap->D_colour.normalfill[i];

  return hmap->B_videoula.fragmentrefreshaction(hmap, hmap->D_colour.normalfill);
}

void videoulasetcolours(void)
{
  HOSTMAP* hmap = &hostmap;
  int i;
  unsigned int u;

  if (hmap->A_videoula.fragmentbits == 8)
  {
    videoulasetfragmentops(videoula01writebyte, videoularefreshbytefragments);
  }
  else
  {
    videoulasetfragmentops(videoula01writenybble, videoularefreshnybblefragments);
  }

  for (i=0; i<8; i++)
  {
    u = i;
    u |= (u<<4);
    u |= (u<<8);
    u |= (u<<16);
    hmap->D_colour.absolutefill[i] = u;
    hmap->D_colour.absolutefill[i+8] = u;
  }

  hmap->B_videoula.normalblank = hmap->D_colour.absolutefill[0];

  videoulasetblacklevelnphys(hmap, 0);
}

R6502ZONEMAP* videoulablankblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  if (hmap->A_videoula.blacklevelnphys != 0)
    videoulasetblacklevelnphys(hmap, 0);
  return zmap;
}

R6502ZONEMAP* videoulagraphicsblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  uintptr_t bc;

  if (!(hmap->A_crtc.c9 & 8))
  {
    bc = hmap->B_videoula.bytelut[hmap->A_videoula.shiftregister&0xFF];
    nphys = getnphys(hmap, (bc>>28)&0xF);

    if (hmap->A_videoula.blacklevelnphys != nphys)
      videoulasetblacklevelnphys(hmap, nphys);
  }
  else
  {
    if (hmap->A_videoula.blacklevelnphys != 0)
      videoulasetblacklevelnphys(hmap, 0);
  }
  return zmap;
}

R6502ZONEMAP* videoulateletextblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  const uint8_t* p = (const uint8_t*)hmap->B_teletext.lue2;

  if (p[0] & 1)
    nphys = (hmap->B_teletext.colours>>8)&7;
  else
    nphys = (hmap->B_teletext.colours>>12)&7;

  if (hmap->A_videoula.blacklevelnphys != nphys)
    videoulasetblacklevelnphys(hmap, nphys);
  return zmap;
}

R6502ZONEMAP* videoulateletextbblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  const uint32_t* p = (const uint32_t*)hmap->B_teletext.lue2;

  if (p[hmap->B_teletext.bblevelbit>>5] & (1<<(hmap->B_teletext.bblevelbit&31)))
    nphys = (hmap->B_teletext.colours>>8)&7;
  else
    nphys = (hmap->B_teletext.colours>>12)&7;

  if (hmap->A_videoula.blacklevelnphys != nphys)
    videoulasetblacklevelnphys(hmap, nphys);
  return zmap;
}

R6502ZONEMAP* videoulacursorblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  uintptr_t cursorbuffer,cursorflags;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorflags = hmap->B_videoula.cursorflags;

  if (cursorflags & cursorbuffer)
  {
    if (hmap->A_videoula.blacklevelnphys != 7)
      videoulasetblacklevelnphys(hmap, 7);
  }
  else
  {
    if (hmap->A_videoula.blacklevelnphys != 0)
      videoulasetblacklevelnphys(hmap, 0);
  }
  return zmap;
}

R6502ZONEMAP* videoulacursorgraphicsblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  uintptr_t bc;
  uintptr_t cursorbuffer,cursorflags;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorflags = hmap->B_videoula.cursorflags;

  if (!(hmap->A_crtc.c9 & 8))
  {
    bc = hmap->B_videoula.bytelut[hmap->A_videoula.shiftregister&0xFF];
    nphys = getnphys(hmap, (bc>>28)&0xF);

    if (cursorflags & cursorbuffer)
      nphys ^= 7;

    if (hmap->A_videoula.blacklevelnphys != nphys)
      videoulasetblacklevelnphys(hmap, nphys);
  }
  else if (cursorflags & cursorbuffer)
  {
    if (hmap->A_videoula.blacklevelnphys != 7)
      videoulasetblacklevelnphys(hmap, 7);
  }
  else
  {
    if (hmap->A_videoula.blacklevelnphys != 0)
      videoulasetblacklevelnphys(hmap, 0);
  }
  return zmap;
}

R6502ZONEMAP* videoulacursorteletextblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  uintptr_t cursorbuffer,cursorflags;
  const uint8_t* p = (const uint8_t*)hmap->B_teletext.lue2;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorflags = hmap->B_videoula.cursorflags;

  if (p[0] & 1)
    nphys = (hmap->B_teletext.colours>>8)&7;
  else
    nphys = (hmap->B_teletext.colours>>12)&7;

  if (cursorflags & cursorbuffer)
    nphys ^= 7;

  if (hmap->A_videoula.blacklevelnphys != nphys)
    videoulasetblacklevelnphys(hmap, nphys);
  return zmap;
}

R6502ZONEMAP* videoulacursorteletextbblacklevel(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  int nphys;
  uintptr_t cursorbuffer,cursorflags;
  const uint32_t* p = (const uint32_t*)hmap->B_teletext.lue2;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorflags = hmap->B_videoula.cursorflags;

  if (p[hmap->B_teletext.bblevelbit>>5] & (1<<(hmap->B_teletext.bblevelbit&31)))
    nphys = (hmap->B_teletext.colours>>8)&7;
  else
    nphys = (hmap->B_teletext.colours>>12)&7;

  if (cursorflags & cursorbuffer)
    nphys ^= 7;

  if (hmap->A_videoula.blacklevelnphys != nphys)
    videoulasetblacklevelnphys(hmap, nphys);
  return zmap;
}

HOSTMAP* videoula00write(HOSTMAP* hmap, uintptr_t address_code)
{
  int toggleflash,evenloadintercept;
  VIDEOULALOADOP *loadopgroup;
  unsigned int step_state_index;

  toggleflash = (hmap->A_videoula.control ^ hmap->m) & 1;

  hmap->B_videoula.bytelut = &hmap->shiftedbytecolours[(hmap->m&0xC)<<6];
  hmap->B_videoula.cursorflags = ((hmap->m&0xE0)<<(VIDEOCURSORSIGNALSEGMENTSHIFT-4))|((hmap->m&0x20)>>(5-VIDEOCURSORSIGNALSEGMENTSHIFT));
  hmap->A_videoula.control = hmap->m;

  step_state_index = (unsigned int)(hmap->B_crtc.step_state - hmap->crtcstep);
  if ((hmap->m & 0x10) || (hmap->B_crtc.scan_code & VIDEOREADODDFLAG))
    hmap->B_crtc.step_state = hmap->crtcstep + (~VIDEOSTEPIDLEFLAG & step_state_index);
  else
    hmap->B_crtc.step_state = hmap->crtcstep + (VIDEOSTEPIDLEFLAG | step_state_index);

  loadopgroup = &hmap->videoulaloads[hmap->m & 0x1C];
  evenloadintercept = hmap->B_videoula.evenloadop != hmap->B_videoula.selectedevenloadop;

  if (!evenloadintercept)
  {
    hmap->B_videoula.evenloadop = loadopgroup[0];
    hmap->B_videoula.evenRloadop = loadopgroup[1];
  }
  hmap->B_videoula.selectedevenloadop = loadopgroup[0];
  hmap->B_videoula.selectedevenRloadop = loadopgroup[1];
  hmap->B_videoula.oddloadop = loadopgroup[2];
  hmap->B_videoula.oddRloadop = loadopgroup[3];

  if (hmap->m & 0x02)
    hmap->peripheral_code |= VIDEODISPLAYTELETEXT;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYTELETEXT;

  if (toggleflash)
    hmap->B_videoula.fragmentrefreshaction(hmap, hmap->D_colour.normalfill);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* videoula01writenybble(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nphys, nphys2;
  uint8_t* bytefragment = (uint8_t*)hmap->D_colour.fragment;

  nphys2 = (hmap->m & 0x0F);
  nphys = nphys2 ^ 0x7;
  hmap->A_videoula.palette[hmap->m>>4] = nphys2;

  if (hmap->A_videoula.control & (hmap->B_videoula.flashing>>nphys) & 1)
    nphys = nphys2;

  bytefragment[hmap->m>>4] = hmap->D_colour.normalfill[nphys] & 0xF;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* videoula01writebyte(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nphys, nphys2;
  uint8_t* bytefragment = (uint8_t*)hmap->D_colour.fragment;

  nphys2 = (hmap->m & 0x0F);
  nphys = nphys2 ^ 0x7;
  hmap->A_videoula.palette[hmap->m>>4] = nphys2;

  if (hmap->A_videoula.control & (hmap->B_videoula.flashing>>nphys) & 1)
    nphys = nphys2;

  bytefragment[hmap->m>>4] = hmap->D_colour.normalfill[nphys] & 0xFF;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}
