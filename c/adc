/*>adc.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * NEC Analogue to Digital Converter - D7002C [1MHz]
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <stddef.h>
#include <stdio.h>
#include "hostmap.h"
#include "6522sysvia.h"
#include "adc.h"
#include "beebit.h"
#include "kernel.h"
#include "swis.h"

extern _kernel_swi_regs regs;

/*analog to digital converter*/
static int adc_x_osunits;
static int adc_y_osunits;
static const int adc_floating_value = 0x7FFF;

void adcreset(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_adc.channel = 0;
  hmap->A_adc.flag = 0;
  hmap->A_adc.resolution = 0;
  hmap->A_adc.highbyte = 0;
  hmap->A_adc.lowbyte = 0;
  hmap->cycles.adc_togo = 0;
}

void adcenter(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_adc.suppressfirst = 0;
  adc_x_osunits = 0;
  adc_y_osunits = 0;
}

void adcmodevars(void)
{
  HOSTMAP* hmap = &hostmap;
  int xres,yres;
  int xeig,yeig;

  regs.r[0] = -1;
  regs.r[1] = 4;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  xeig = regs.r[2];
  regs.r[1] = 5;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  yeig = regs.r[2];
  regs.r[1] = 11;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  xres = regs.r[2] + 1;
  regs.r[1] = 12;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  yres = regs.r[2] + 1;

  if (adc_x_osunits != (xres<<xeig))
  {
    adc_x_osunits = (xres<<xeig);
    hmap->B_adc.input_x_high = (adc_x_osunits>>1)+255;
  }
  if (adc_y_osunits != (yres<<yeig))
  {
    adc_y_osunits = (yres<<yeig);
    hmap->B_adc.input_y_low = (adc_y_osunits>>1)-255;
  }
}

HOSTMAP* adcpoll(HOSTMAP* hmap)
{
  int nvalue;
  hmap->A_adc.status &= 0x0F;

  if (beebit_mouseemulation == MOUSE_JOYSTICK)
  {
    /*mouse position in OS units*/
    _kernel_swi(OS_Mouse,&regs,&regs);

    if (hmap->A_adc.suppressfirst == 0)
      beebit_button1 = 0;
    else
      beebit_button1 = ((regs.r[2] & 0x04)>>2);

    if (((regs.r[2] & 0x04)>>2) == 0)
      hmap->A_adc.suppressfirst = 1;

    beebit_button2 = (regs.r[2] & 0x01);
    switch (hmap->A_adc.status & 3)
    {
      case 0:
        /*master left/right*/
        /*sliding 512 OS unit domain*/
        if (hmap->B_adc.input_x_high < regs.r[0])
          hmap->B_adc.input_x_high = regs.r[0];
        else if (hmap->B_adc.input_x_high - 511 > regs.r[0])
          hmap->B_adc.input_x_high = regs.r[0] + 511;

        nvalue = (hmap->B_adc.input_x_high - regs.r[0])<<7;
        break;
      case 1:
        /*master up/down*/
        /*sliding 512 OS unit domain*/
        if (hmap->B_adc.input_y_low > regs.r[1])
          hmap->B_adc.input_y_low = regs.r[1];
        else if (hmap->B_adc.input_y_low + 511 < regs.r[1])
          hmap->B_adc.input_y_low = regs.r[1] - 511;

        nvalue = (regs.r[1] - hmap->B_adc.input_y_low)<<7;
        break;
      case 2:
        /*secondary left/right*/
        nvalue = adc_floating_value;
        break;
      case 3:
        /*secondary up/down*/
        nvalue = adc_floating_value;
        break;
      default:
        nvalue = 0;
        break;
    }
  }
  else
    nvalue = adc_floating_value;

  hmap->A_adc.status |= 0x40; /*not busy*/
  hmap->A_adc.status |= ((nvalue & 0xC000)>>10);
  hmap->A_adc.highbyte = (nvalue>>8);
  hmap->A_adc.lowbyte = (nvalue & 0xF0);

  if (beebit_mouseemulation == MOUSE_JOYSTICK)
  {
    if (beebit_button1)
      hmap->A_sysvia.portb &= 0xEF;
    else
      hmap->A_sysvia.portb |= 0x10;

    if (beebit_button2)
      hmap->A_sysvia.portb &= 0xDF;
    else
      hmap->A_sysvia.portb |= 0x20;
  }

  hmap->A_sysvia.irb = (hmap->A_sysvia.orb & hmap->A_sysvia.ddrb) + (hmap->A_sysvia.portb & ~hmap->A_sysvia.ddrb);
  /*set CB1 to indicate end of conversion*/
  hmap->A_sysvia.ifr |= 0x10;

  return hmap;
}

HOSTMAP* adc00read(HOSTMAP* hmap, uintptr_t address_code)
{
  /*&FC00
   *b0+b1: which of the 4 input channels was selected.
   *b2: not used.
   *b3=0: 8 bit resolution/4ms
   *b3=1: 10 bit resolution/10ms
   *b4: 2nd MSB
   *b5: 1st MSB
   *b6:
   */
  hmap->m = hmap->A_adc.status;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* adc01read(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_adc.highbyte;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* adc02read(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_adc.lowbyte;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* adcwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*if naddress=&FC00 then
   * b1+b0: which of the 4 input channels to select.
   * b2: flag input.
   * b3=0: 8 bit resolution/4ms
   * b3=1: 10 bit resolution/10ms
   * interrupt is generated when conversion is done.
   */
  intptr_t cyclecount;
  hmap->A_adc.channel = (hmap->m & 3);
  hmap->A_adc.flag = (hmap->m & 4)>>2;
  hmap->A_adc.resolution = (hmap->m & 8)>>3;
  /*busy*/
  hmap->A_adc.status = (hmap->m & 0x0F);
  /*not complete*/
  hmap->A_adc.status |= 0x80;
  if (hmap->A_adc.resolution)
    hmap->cycles.adc_togo =  10000<<1;
  else
    hmap->cycles.adc_togo =   4000<<1;
  HOSTMAP_GET_TOGO_FROM_WRITE_OFFSET(cyclecount, hmap)
  hmap->cycles.adc_togo += 1 + cyclecount;
  HOSTMAP_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.adc_togo)
  R6502_JUMP_FROM_HIGH_OP(hmap)
}
