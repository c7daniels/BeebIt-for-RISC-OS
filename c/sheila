/*>sheila.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Enhanced host screen mode compatibility (and more)
 *   contributed by Crispian Daniels in 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <stddef.h>
#include <string.h>
#include "beebit.h"
#include "host.h"
#include "6502cpu.h"
#include "sheila.h"
#include "6522sysvia.h"
#include "6522usrvia.h"
#include "6845crtc.h"
#include "6850acia.h"
#include "8271fdc.h"
#include "adc.h"
/*#include "kernel.h"*/
#include "main.h"
#include "riscos.h"
/*#include "swis.h"*/
#include "tube.h"
#include "videoula.h"
#include "1770fdc.h"

/*extern _kernel_swi_regs regs;*/

/*sheila*/
/*char sheila_b[0x100];*/

void sheilareset(void)
{
  int i,j;
  R6502READSPECIALOP* specialreadops = &hostmap.specialreadops[0x200];
  R6502WRITESPECIALOP* specialwriteops = &hostmap.specialwriteops[0x200];

  /*&FE00 - &FE07 (CRTC)*/
  for (i=0x00; i<0x08; i+=0x02)
  {
    specialreadops[i] = crtc00read;
    specialreadops[i+1] = crtc01read;
    specialwriteops[i] = crtc00write;
    specialwriteops[i+1] = crtc01write;
  }

  /*&FE08 - &FE0F (ACIA)*/
  for (i=0x08; i<0x10; i+=0x02)
  {
    specialreadops[i] = acia00read;
    specialreadops[i+1] = acia01read;
    specialwriteops[i] = acia00write;
    specialwriteops[i+1] = acia01write;
  }

  /*&FE10 - &FE17 (SERIALULA)*/
  for (i=0x10; i<0x18; i+=0x01)
  {
    specialreadops[i] = serialularead;
    specialwriteops[i] = serialulawrite;
  }

  if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
  {
    /*&FE18 - &FE1F (ADC)*/
    for (i=0x18; i<0x20; i+=0x04)
    {
      specialreadops[i] = adc00read;
      specialreadops[i+1] = adc01read;
      specialreadops[i+2] = adc02read;
      specialreadops[i+3] = adc02read;
      specialwriteops[i] = adcwrite;
      specialwriteops[i+1] = adcwrite;
      specialwriteops[i+2] = adcwrite;
      specialwriteops[i+3] = adcwrite;
    }
  }
  else
  {
    /*&FE18 - &FE1F (ECONET STATION NUMBER/INTOFF)*/
    for (i=0x18; i<0x20; i+=0x01)
    {
      specialreadops[i] = hostconstantreadFE;
      specialwriteops[i] = hostnowrite;
    }
  }

  if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
  {
    /*&FE20 - &FE23 (VIDEOULA)*/
    for (i=0x20; i<0x24; i+=0x02)
    {
      specialreadops[i] = hostconstantread00;
      specialreadops[i+1] = hostconstantread00;
      specialwriteops[i] = videoula00write;
      specialwriteops[i+1] = videoula01write;
    }
    /*&FE24 - &FE27 (FDC INTERFACE CONTROL REG)*/
    for (i=0x24; i<0x28; i+=0x01)
    {
      specialreadops[i] = w1770controlread;
      specialwriteops[i] = w1770controlwrite_m;
    }
    /*&FE28 - &FE2F (FDC INTERFACE)*/
    for (i=0x28; i<0x30; i+=0x04)
    {
      specialreadops[i] = w1770statusread;
      specialreadops[i+1] = w1770trackread;
      specialreadops[i+2] = w1770sectorread;
      specialreadops[i+3] = w1770dataread;
      specialwriteops[i] = w1770commandwrite;
      specialwriteops[i+1] = w1770trackwrite;
      specialwriteops[i+2] = w1770sectorwrite;
      specialwriteops[i+3] = w1770datawrite;
    }
  }
  else
  {
    /*&FE20 - &FE2F (VIDEOULA/INTON)*/
    for (i=0x20; i<0x30; i+=0x02)
    {
      specialreadops[i] = hostconstantreadFE;
      specialreadops[i+1] = hostconstantreadFE;
      specialwriteops[i] = videoula00write;
      specialwriteops[i+1] = videoula01write;
    }
  }

  if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
  {
    /*&FE30 - &FE33 (ROMSEL)*/
    for (i=0x30; i<0x34; i++)
    {
      specialreadops[i] = romselread;
      specialwriteops[i] = romselwrite_m;
    }
    /*&FE34 - &FE37 (ACCCON)*/
    for (i=0x34; i<0x38; i++)
    {
      specialreadops[i] = accconread;
      specialwriteops[i] = accconwrite_m;
    }
    /*&FE38 - &FE3B (INTOFF)*/
    for (i=0x38; i<0x3C; i++)
    {
      specialreadops[i] = hostconstantread00;
      specialwriteops[i] = hostnowrite;
    }
    /*&FE3C - &FE3F (INTON)*/
    for (i=0x3C; i<0x40; i++)
    {
      specialreadops[i] = hostconstantread00;
      specialwriteops[i] = hostnowrite;
    }
  }
  else if (beebit_machinetype == MACHINE_MODELBPLUS)
  {
    for (j=0x30; j<0x40; j+=0x08)
    {
      /*&FE30 - &FE33 (ROMSEL)*/
      for (i=0x00; i<0x04; i++)
      {
        specialreadops[j+i] = romselread;
        specialwriteops[j+i] = romselwrite_bp;
      }
      /*&FE34 - &FE37 (ACCCON)*/
      for (i=0x04; i<0x08; i++)
      {
        specialreadops[j+i] = accconread;
        specialwriteops[j+i] = accconwrite_bp;
      }
    }
  }
  else
  {
    /*&FE30 - &FE33 (ROMSEL)*/
    for (i=0x30; i<0x34; i++)
    {
      specialreadops[i] = hostconstantreadFE;
      specialwriteops[i] = romselwrite_b;
    }
    /*&FE34 - &FE3F (ROMSEL in place of ACCCON, INTOFF and INTON)*/
    /*ignoring writes directed at Master*/
    for (i=0x34; i<0x40; i++)
    {
      specialreadops[i] = hostconstantreadFE;
      specialwriteops[i] = hostnowrite;
    }
  }

  /*&FE40-&FE5F*/
  for (i=0x40; i<0x60; i+=0x10)
  {
    specialreadops[i] = systemvia00read;
    specialreadops[i+0x02] = systemvia02read;
    specialreadops[i+0x03] = systemvia03read;
    specialreadops[i+0x04] = systemvia04read;
    specialreadops[i+0x05] = systemvia05read;
    specialreadops[i+0x06] = systemvia06read;
    specialreadops[i+0x07] = systemvia07read;
    specialreadops[i+0x08] = systemvia08read;
    specialreadops[i+0x09] = systemvia09read;
    specialreadops[i+0x0A] = systemvia0Aread;
    specialreadops[i+0x0B] = systemvia0Bread;
    specialreadops[i+0x0C] = systemvia0Cread;
    specialreadops[i+0x0D] = systemvia0Dread;
    specialreadops[i+0x0E] = systemvia0Eread;
    specialwriteops[i+0x02] = systemvia02write;
    specialwriteops[i+0x03] = systemvia03write;
    specialwriteops[i+0x04] = systemvia04write;
    specialwriteops[i+0x05] = systemvia05write;
    specialwriteops[i+0x06] = systemvia06write;
    specialwriteops[i+0x07] = systemvia07write;
    specialwriteops[i+0x08] = systemvia08write;
    specialwriteops[i+0x09] = systemvia09write;
    specialwriteops[i+0x0A] = systemvia0Awrite;
    specialwriteops[i+0x0B] = systemvia0Bwrite;
    specialwriteops[i+0x0C] = systemvia0Cwrite;
    specialwriteops[i+0x0D] = systemvia0Dwrite;
    specialwriteops[i+0x0E] = systemvia0Ewrite;
    if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
    {
      specialreadops[i+0x01] = systemvia01read_m;
      specialreadops[i+0x0F] = systemvia0Fread_m;
      specialwriteops[i] = systemvia00write_m;
      specialwriteops[i+0x01] = systemvia01write_m;
      specialwriteops[i+0x0F] = systemvia0Fwrite_m;
    }
    else
    {
      specialreadops[i+0x01] = systemvia01read_b;
      specialreadops[i+0x0F] = systemvia0Fread_b;
      specialwriteops[i] = systemvia00write_b;
      specialwriteops[i+0x01] = systemvia01write_b;
      specialwriteops[i+0x0F] = systemvia0Fwrite_b;
    }
  }

  /*&FE60-&FE7F*/
  for (i=0x60; i<0x80; i+=0x10)
  {
    specialreadops[i] = uservia00read;
    specialreadops[i+0x01] = uservia01read;
    specialreadops[i+0x02] = uservia02read;
    specialreadops[i+0x03] = uservia03read;
    specialreadops[i+0x04] = uservia04read;
    specialreadops[i+0x05] = uservia05read;
    specialreadops[i+0x06] = uservia06read;
    specialreadops[i+0x07] = uservia07read;
    specialreadops[i+0x08] = uservia08read;
    specialreadops[i+0x09] = uservia09read;
    specialreadops[i+0x0A] = uservia0Aread;
    specialreadops[i+0x0B] = uservia0Bread;
    specialreadops[i+0x0C] = uservia0Cread;
    specialreadops[i+0x0D] = uservia0Dread;
    specialreadops[i+0x0E] = uservia0Eread;
    specialreadops[i+0x0F] = uservia0Fread;
    specialwriteops[i] = uservia00write;
    specialwriteops[i+0x01] = uservia01write;
    specialwriteops[i+0x02] = uservia02write;
    specialwriteops[i+0x03] = uservia03write;
    specialwriteops[i+0x04] = uservia04write;
    specialwriteops[i+0x05] = uservia05write;
    specialwriteops[i+0x06] = uservia06write;
    specialwriteops[i+0x07] = uservia07write;
    specialwriteops[i+0x08] = uservia08write;
    specialwriteops[i+0x09] = uservia09write;
    specialwriteops[i+0x0A] = uservia0Awrite;
    specialwriteops[i+0x0B] = uservia0Bwrite;
    specialwriteops[i+0x0C] = uservia0Cwrite;
    specialwriteops[i+0x0D] = uservia0Dwrite;
    specialwriteops[i+0x0E] = uservia0Ewrite;
    specialwriteops[i+0x0F] = uservia0Fwrite;
  }

  if (beebit_machinetype == MACHINE_MODELBPLUS)
  {
    /*&FE80-&FE9F (8271 or 1770)*/
    for (j=0x80; j<0xA0; j+=0x08)
    {
      /*&FE80 - &FE83 (FDC INTERFACE CONTROL REG)*/
      for (i=0x00; i<0x04; i+=0x01)
      {
        specialreadops[j+i] = w1770controlread;
        specialwriteops[j+i] = w1770controlwrite_bp;
      }
      /*&FE84 - &FE87 (FDC INTERFACE)*/
      specialreadops[j+0x04] = w1770statusread;
      specialreadops[j+0x05] = w1770trackread;
      specialreadops[j+0x06] = w1770sectorread;
      specialreadops[j+0x07] = w1770dataread;
      specialwriteops[j+0x04] = w1770commandwrite;
      specialwriteops[j+0x05] = w1770trackwrite;
      specialwriteops[j+0x06] = w1770sectorwrite;
      specialwriteops[j+0x07] = w1770datawrite;
    }
  }
  else if (beebit_machinetype == MACHINE_MODELB)
  {
    /*&FE80-&FE9F (8271 or 1770)*/
    for (j=0x80; j<0xA0; j+=0x08)
    {
      specialreadops[j] = i8271statusread;
      specialreadops[j+1] = i8271resultread;
      specialreadops[j+2] = hostconstantreadFE;
      specialreadops[j+3] = hostconstantreadFE;
      specialwriteops[j] = i8271commandwrite;
      specialwriteops[j+1] = i8271parameterwrite;
      specialwriteops[j+2] = i8271resetwrite;
      specialwriteops[j+3] = hostnowrite;

      for (i=0x04; i<0x08; i+=0x01)
      {
        specialreadops[j+i] = i8271dataread;
        specialwriteops[j+i] = i8271datawrite;
      }
    }
  }
  else
  {
    for (i=0x80; i<0xA0; i+=0x01)
    {
      specialreadops[i] = hostconstantread00;
      specialwriteops[i] = hostnowrite;
    }
  }

  /*&FEA0-&FEBF (ECONET)*/
  for (i=0xA0; i<0xC0; i+=0x01)
  {
    specialreadops[i] = hostconstantreadFE;
    specialwriteops[i] = hostnowrite;
  }

  if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
  {
    /*&FEC0-&FEDF (ECONET)*/
    for (i=0xC0; i<0xE0; i++)
    {
      specialreadops[i] = hostconstantreadFF;
      specialwriteops[i] = hostnowrite;
    }
  }
  else
  {
    /*FEC0-&FEDF (ADC)*/
    for (i=0xC0; i<0xE0; i+=0x04)
    {
      specialreadops[i] = adc00read;
      specialreadops[i+1] = adc01read;
      specialreadops[i+2] = adc02read;
      specialreadops[i+3] = adc02read;
      specialwriteops[i] = adcwrite;
      specialwriteops[i+1] = adcwrite;
      specialwriteops[i+2] = adcwrite;
      specialwriteops[i+3] = adcwrite;
    }
  }

  /*FEE0-&FEFF (TUBE)*/
  if (beebit_machinetype == MACHINE_MASTER128 || beebit_machinetype == MACHINE_COMPACT)
  {
    for (i=0xE0; i<0x100; i+=0x01)
    {
      specialreadops[i] = hostconstantreadFF;
      specialwriteops[i] = hostnowrite;
    }
  }
  else
  {
    for (i=0xE0; i<0x100; i+=0x01)
    {
      specialreadops[i] = hostconstantreadFE;
      specialwriteops[i] = hostnowrite;
    }
  }
}

struct R6502CPUMAP* hostconstantread00(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = 0x00;
  return cmap;
}

struct R6502CPUMAP* hostconstantreadFE(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = 0xFE;
  return cmap;
}

struct R6502CPUMAP* hostconstantreadFF(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = 0xFF;
  return cmap;
}

struct R6502CPUMAP* romselread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->romsel;
  return cmap;
}

struct R6502CPUMAP* accconread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->acccon;
  return cmap;
}

struct R6502CPUMAP* hostnowrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  return cmap;
}

struct R6502CPUMAP* romselwrite_b(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  int nrom = (value & 0x0F);
  cmap->addressingops[0x0B].op = cmap->addressingops[0x0A].op
      = cmap->addressingops[0x09].op = cmap->addressingops[0x08].op = hmap->read8000s[nrom];
  cmap->addressingops[0x1B].op = cmap->addressingops[0x1A].op
      = cmap->addressingops[0x19].op = cmap->addressingops[0x18].op = hmap->modify8000s[nrom];
  hmap->romsel = value;
  return cmap;
}

struct R6502CPUMAP* romselwrite_bp(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  int nrom = (value & 0x0F);
  if (value & 0x80)
  {
    /*ROMSEL b7 (RAM) (&8000-&AFFF)*/
    cmap->addressingops[0x0A].op = cmap->addressingops[0x09].op
        = cmap->addressingops[0x08].op = hmap->paging.address8000_ram;
    cmap->addressingops[0x1A].op = cmap->addressingops[0x19].op
        = cmap->addressingops[0x18].op = hmap->paging.address8000_ram;
    if (hmap->acccon & 0x80)
    {
      /*ACCCON b7 (VDUSEL) (&3000-&7FFF)*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
      = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
      = cmap->addressingops[0x03].op = hmap->paging.address3000_ramram_e;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
      = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
      = cmap->addressingops[0x13].op = hmap->paging.address3000_ramram_e;
    }
  }
  else
  {
    cmap->addressingops[0x0A].op = cmap->addressingops[0x09].op
        = cmap->addressingops[0x08].op = hmap->read8000s[nrom];
    cmap->addressingops[0x1A].op = cmap->addressingops[0x19].op
        = cmap->addressingops[0x18].op = hmap->modify8000s[nrom];
    if (hmap->acccon & 0x80)
    {
      /*ACCCON b7 (VDUSEL) (&3000-&7FFF)*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
      = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
      = cmap->addressingops[0x03].op = hmap->paging.address3000_ram_x;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
      = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
      = cmap->addressingops[0x13].op = hmap->paging.address3000_ram_x;
    }
  }
  cmap->addressingops[0x0B].op = hmap->read8000s[nrom];
  cmap->addressingops[0x1B].op = hmap->modify8000s[nrom];
  hmap->romsel = value;
  return cmap;
}

struct R6502CPUMAP* romselwrite_m(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  int nrom = (value & 0x0F);
  if (value & 0x80)
  {
    /*ROMSEL b7 (RAM) (&8000-&8FFF)*/
    cmap->addressingops[0x08].op = hmap->paging.address8000_ram;
    cmap->addressingops[0x18].op = hmap->paging.address8000_ram;
  }
  else
  {
    cmap->addressingops[0x08].op = hmap->read8000s[nrom];
    cmap->addressingops[0x18].op = hmap->modify8000s[nrom];
  }
  cmap->addressingops[0x0B].op = cmap->addressingops[0x0A].op
      = cmap->addressingops[0x09].op = hmap->read8000s[nrom];
  cmap->addressingops[0x1B].op = cmap->addressingops[0x1A].op
      = cmap->addressingops[0x19].op = hmap->modify8000s[nrom];
  hmap->romsel = value;
  return cmap;
}

struct R6502CPUMAP* accconwrite_bp(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  if (value & 0x80)
  {
    /*ACCCON b7 (VDUSEL) (&3000-&7FFF)*/
    if (hmap->romsel & 0x80)
    {
      /*ROMSEL b7 (RAM) (&8000-&AFFF)*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
      = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
      = cmap->addressingops[0x03].op = hmap->paging.address3000_ramram_e;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
      = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
      = cmap->addressingops[0x13].op = hmap->paging.address3000_ramram_e;
    }
    else
    {
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
      = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
      = cmap->addressingops[0x03].op = hmap->paging.address3000_ram_x;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
      = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
      = cmap->addressingops[0x13].op = hmap->paging.address3000_ram_x;
    }
  }
  else
  {
    cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
        = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
        = cmap->addressingops[0x03].op = cmap->addressingops[0x00].op;
    cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
        = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
        = cmap->addressingops[0x13].op = cmap->addressingops[0x10].op;
  }
  hmap->acccon = value;
  return cmap;
}

struct R6502CPUMAP* accconwrite_m(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  switch (value & 0x06)
  {
    case 0x00:
      /*RAM*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
          = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
          = cmap->addressingops[0x03].op = cmap->addressingops[0x00].op;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
          = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
          = cmap->addressingops[0x13].op = cmap->addressingops[0x10].op;
      break;
    case 0x02:
      /*ACCCON b1 (E)*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
          = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
          = cmap->addressingops[0x03].op = hmap->paging.address3000_ramram_e;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
          = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
          = cmap->addressingops[0x13].op = hmap->paging.address3000_ramram_e;
      break;
    case 0x04:
    case 0x06:
      /*ACCCON b2 (X)*/
      cmap->addressingops[0x07].op = cmap->addressingops[0x06].op
          = cmap->addressingops[0x05].op = cmap->addressingops[0x04].op
          = cmap->addressingops[0x03].op = hmap->paging.address3000_ram_x;
      cmap->addressingops[0x17].op = cmap->addressingops[0x16].op
          = cmap->addressingops[0x15].op = cmap->addressingops[0x14].op
          = cmap->addressingops[0x13].op = hmap->paging.address3000_ram_x;
      break;
  }
  if (value & 0x08)
  {
    /*ACCCON b3 (Y)*/
    /*&C000-&DFFF*/
    cmap->addressingops[0x0D].op = cmap->addressingops[0x0C].op = hmap->paging.addressC000_y;
    cmap->addressingops[0x1D].op = cmap->addressingops[0x1C].op = hmap->paging.addressC000_y;
  }
  else
  {
    /*&C000-&DFFF*/
    cmap->addressingops[0x0D].op = cmap->addressingops[0x0C].op = cmap->addressingops[0x0E].op;
    cmap->addressingops[0x1D].op = cmap->addressingops[0x1C].op = cmap->addressingops[0x1E].op;
  }
  switch (value & 0x60)
  {
    case 0x00:
      /*FRED, JIM*/
      hmap->readmFC00 = hmap->paging.addressFC00;
      hmap->modifymFC00 = hmap->paging.addressFC00;
      break;
    case 0x20:
      /*IFJ*/
      hmap->readmFC00 = hmap->paging.addressFC00_ifj;
      hmap->modifymFC00 = hmap->paging.addressFC00_ifj;
      break;
    case 0x40:
    case 0x60:
      /*TST*/
      hmap->readmFC00 = cmap->addressingops[0x0E].op;
      hmap->modifymFC00 = cmap->addressingops[0x1E].op;
      break;
  }

  if (value & 0x80)
  {
    /*IRR*/
    HOST_SETIRQ(hmap, HOST_IRQ_IRR)
  }
  else
  {
    HOST_CLEARIRQ(hmap, HOST_IRQ_IRR)
  }
  hmap->acccon = value;
  return cmap;
}
