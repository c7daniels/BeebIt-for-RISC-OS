/*>6522sysvia.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Rockwell 6522 Versatile Interface Adapter (VIA) [1MHz]
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

/* 0xffff * 2 = 0x1fffe +2 = 0x20000 */

/*ACR bits*/
/*b7 = output enable*/
/*b6 = free-run enable*/
/*b5 = timer 2 control (0=timed interrupt,1=countdown with pulses)*/
/*b1 = PB latching enabled*/
/*b0 = PA latching enabled*/

#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include "hostmap.h"
#include "6502cpu.h"
#include "6522sysvia.h"
#include "beebit.h"
#include "kernel.h"
#include "keyboard.h"
#include "main.h"
#include "riscos.h"
#include "swis.h"

extern _kernel_swi_regs regs;

#ifdef __RISCOS__
extern void zeribeepwrite(HOSTMAP *hmap, char nvalue);
#endif

/*System VIA*/
static int ScreenStartArray[] = {0x4000,0x6000,0x3000,0x5800};

char bcd(char nvalue)
{
  //convert a decimal value to a BCD value
  return(((nvalue / 10) * 16) + nvalue % 10);
}

char cmosread(char naddress)
{
  #ifdef __RISCOS__
    char cmosclock[8];
  #else
    time_t currenttime;
    struct tm * splittime;
  #endif
  switch (naddress)
  {
    case 0x00:
    case 0x01:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[6]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_sec));
      #endif
       break;
    case 0x02:
    case 0x03:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[5]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_min));
      #endif
      break;
    case 0x04:
    case 0x05:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[4]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_hour));
      #endif
      break;
    case 0x06:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[3]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_wday)+1);
      #endif
      break;
    case 0x07:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[2]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_mday));
      #endif
      return(0);
      break;
    case 0x08:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[1]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_mon+1));
      #endif
      break;
    case 0x09:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[0]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_year-10));
      #endif
      break;
    case 0x0A:
    case 0x0B:
    case 0x0C:
    case 0x0D:
      /*registers*/
      return(0);
      break;
    default:
      return(beebit_cmos[naddress-0x0E]);
      break;
  }
}

void cmoswrite(char naddress,char nvalue)
{
  switch (naddress)
  {
    case 0x00:
    case 0x01:
    case 0x02:
    case 0x03:
    case 0x04:
    case 0x05:
    case 0x06:
    case 0x07:
    case 0x08:
    case 0x09:
      break;
    case 0x0A:
    case 0x0B:
    case 0x0C:
    case 0x0D:
      break;
    default:
      beebit_cmos[naddress-0x0E] = nvalue;
      break;
  }
}

void systemviasetirq(void)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;

  if (hmap->A_sysvia.ifr & hmap->A_sysvia.ier & 0x7F)
  {
    /*if (beebit_trace)
      fprintf(htrace,"SV IRQ=&FF\n");*/
    hmap->A_sysvia.ifr |= 0x80;
    cmap->irq |= IRQ_6522SYSVIA;
  }
  else
  {
    hmap->A_sysvia.ifr &= 0x7F;
    cmap->irq &= IRQ_NOT6522SYSVIA;
  }
}

void systemviasetca1(void)
{
  HOSTMAP* hmap = &hostmap;
  #ifdef __DEBUG__
    fprintf(htrace,"CA1 ");
  #endif
  hmap->A_sysvia.ifr |= 0x02; /*CA1 flag*/
  systemviasetirq();
}

/*void systemviavidca1(void)
{*/
  /*CA1 flag*/
  /*hmap->A_sysvia.ifr |= 0x02;
  systemviasetirq();
  hmap->A_sysvia.ira=(hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}*/

/*void systemviavidirq(void)
{
  systemviasetirq();
  hmap->A_sysvia.ira=(hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}*/

void systemviaunsetca1(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_sysvia.ifr &= 0xFD; /*CA1 flag*/
  systemviasetirq();
}

void systemviasetca2(void)
{
  HOSTMAP* hmap = &hostmap;
  #ifdef __DEBUG__
    fprintf(htrace,"CA2 ");
  #endif
  switch (hmap->A_sysvia.pcr & 0x0E)
  {
    case 0:
    case 2:
      /*updatekeyboard();*/
      hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
      systemviasetirq();
      break;
    case 4:
    case 6:
      /*updatekeyboard();*/
      hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
      systemviasetirq();
      break;
  }
}

void systemviakeyca2(void)
{
  HOSTMAP* hmap = &hostmap;
  /*updatekeyboard();*/
  /*if (beebit_trace)
    printf("SVK PC=%X, SP=%X %X\n", r6502_pc, r6502_sp, hmap->A_sysvia.ifr);*/
  hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
  systemviasetirq();
}

/*void systemviaunsetca2(void)
{
  hmap->A_sysvia.ifr &= 0xFE;*/ /*CA2 flag*/
  /*systemviasetirq();
}*/

static intptr_t systemviapickcyclestogo(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t cyclestogo;

  // the interrupt flag is set after the counter has passed through zero
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    if (hmap->B_sysvia.t1doubled < hmap->B_sysvia.t2doubled)
    {
      cyclestogo = hmap->B_sysvia.t1doubled + 2;
    }
    else
    {
      cyclestogo = hmap->B_sysvia.t2doubled + 2;
    }
  }
  else
  {
    cyclestogo = hmap->B_sysvia.t1doubled + 2;
  }

  if (hmap->A_sysvia.aftert1)
  {
    cyclestogo = 1;
  }

  return cyclestogo;
}

void systemviareset(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled = expiryoffset;
  hmap->B_sysvia.t2doubled = expiryoffset;
  hmap->A_sysvia.sr = 0;

  /*if ier is set to none, a hard reset will be done*/
  hmap->A_sysvia.ier = 0x80;

  hmap->A_sysvia.ifr = 0x00;
  hmap->A_sysvia.ddra = 0; /*input*/
  hmap->A_sysvia.ddrb = 0; /*input*/
  hmap->A_sysvia.t1ll = 0xFF;
  hmap->A_sysvia.t1lh = 0xFF;
  hmap->A_sysvia.t2ll = 0xFF;
  hmap->A_sysvia.acr = 0;
  hmap->A_sysvia.pcr = 0;
  hmap->A_sysvia.ora = 0xFF;
  hmap->A_sysvia.ira = 0xFF;
  hmap->A_sysvia.orb = 0xFF;
  hmap->A_sysvia.irb = 0xFF;
  hmap->A_sysvia.porta = 0xFF;
  hmap->A_sysvia.portb = 0xFF;

  hmap->A_sysvia.aftert1 = FALSE;
  hmap->A_sysvia.t1setint = FALSE;
  hmap->A_sysvia.t2setint = FALSE;

  hmap->lsoundlatch = FALSE;
  systemviasetirq();
  hmap->screenstartaddress = 0;
  hmap->screenstartindex = 0;

  hmap->cycles.sysvia_togo = systemviapickcyclestogo();
  hmap->cycles.sysvia_original = hmap->cycles.sysvia_togo;

  HOSTMAP_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.sysvia_togo)
}

void systemviabeforesnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled -= expiryoffset;
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled -= expiryoffset;
  }
}

void systemviaaftersnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled += expiryoffset;
  HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t1doubled + 2)
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled += expiryoffset;
    HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
  }
}

HOSTMAP* systemviaatzerocycles(HOSTMAP* hmap)
{
  /*we are dealing with a 1MHz device here*/
  hmap->B_sysvia.t1doubled -= hmap->cycles.sysvia_original;

  if (hmap->B_sysvia.t1doubled == -2)
  {
    switch (hmap->A_sysvia.acr & 0xC0)
    {
      case 0x00:
        /*output disabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        if (hmap->A_sysvia.t1setint)
        {
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
          hmap->A_sysvia.t1setint = FALSE;
        }
        break;
      case 0x40:
        /*output disabled and free-run mode*/
        /*continuous interrupts*/
        /*ELITE uses this one*/
         if (hmap->A_sysvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
        break;
      case 0x80:
        /*output enabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        if (hmap->A_sysvia.t1setint)
        {
          /*PB7 goes high*/
          hmap->A_sysvia.portb |= 0x80;
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
          hmap->A_sysvia.t1setint = FALSE;
        }
        break;
      case 0xC0:
        /*output enabled and free-run mode*/
        /*continuous interrupts*/
        hmap->A_sysvia.portb ^= 0x80;
        if (hmap->A_sysvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
        break;
    }

    hmap->B_sysvia.t1doubled += 0x20000;
    hmap->A_sysvia.aftert1 = TRUE;
  }
  else if (hmap->A_sysvia.aftert1)
  {
    if (hmap->A_sysvia.acr & 0x40)
    {
      hmap->B_sysvia.t1doubled = ((hmap->A_sysvia.t1lh<<9) | (hmap->A_sysvia.t1ll<<1)) + 1;
    }
    hmap->A_sysvia.aftert1 = 0;
  }

  if (!(hmap->A_sysvia.acr & 0x20))
  {
    hmap->B_sysvia.t2doubled -= hmap->cycles.sysvia_original;

    if (hmap->B_sysvia.t2doubled == -2)
    {
      if (hmap->A_sysvia.t2setint)
      {
        /*on completion of the timing interval,
          T2 interrupt flag is set (IFR b5)*/
        hmap->A_sysvia.ifr |= 0x20;
        hmap->A_sysvia.t2setint=FALSE;
      }

      hmap->B_sysvia.t2doubled += 0x20000;
    }
  }

  hmap->cycles.sysvia_togo = hmap->cycles.sysvia_original = systemviapickcyclestogo();

  systemviasetirq();
  return hmap;
}

HOSTMAP* systemvia00read(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nresult;

  /*input/output reg b*/
  /*hmap->A_sysvia.pcr & 0x20 = CB2 input*/
  /*hmap->A_sysvia.pcr & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_sysvia.pcr & 0xE0) == 0x20) OR ((hmap->A_sysvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_sysvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_sysvia.ifr &= 0xE7;
  }
  systemviasetirq();
  /*reads output register bit in orb. pin level has no effect*/
  nresult = (hmap->A_sysvia.orb & hmap->A_sysvia.ddrb);
  if (hmap->A_sysvia.acr & 0x02)
  {
    /*input latching enabled*/
    /*read input level on irb*/
    nresult |= (hmap->A_sysvia.irb & ~hmap->A_sysvia.ddrb);
  }
  else
  {
    /*input latching disabled*/
    /*read input level on PB pin*/
    nresult |= (hmap->A_sysvia.portb & ~hmap->A_sysvia.ddrb);
  }
  if (!beebit_button1)
    nresult |= 0x10; /*fire button 1 released*/
  if (!beebit_button2)
    nresult |= 0x20; /*fire button 2 released*/

  nresult |= 0xC0; /*speech system not available*/
  /*nresult |= 0xF0;*/
  #ifdef __DEBUG__
    fprintf(htrace,"=&%X (&%X & &%X) ",nresult,hmap->A_sysvia.orb,hmap->A_sysvia.ddrb);
  #endif
  hmap->m = nresult;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01read_b(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nresult;

  /*input/output reg a*/
  /*hmap->A_sysvia.pcr & 0x02 = CA2 input*/
  /*hmap->A_sysvia.pcr & 0x04 = CA2 active edge input*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*independant interrupt*/
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviasetirq();
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01read_m(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nresult;

  /*input/output reg a*/
  /*hmap->A_sysvia.pcr & 0x02 = CA2 input*/
  /*hmap->A_sysvia.pcr & 0x04 = CA2 active edge input*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*independant interrupt*/
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviasetirq();
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (hmap->rtc.chipselect && hmap->rtc.readwrite)
    {
      hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
      /*nresult = (hmap->A_sysvia.porta & hmap->A_sysvia.ddra);
      if (hmap->rtc.chipselect)
        nresult |= (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);*/
      nresult = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
    }
    else
      nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia02read(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_sysvia.ddrb;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia03read(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_sysvia.ddra;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia04read(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t cyclecount;

  /*T1 low order counter*/
  /*T1 interrupt flag is reset (IFR b6)*/
  hmap->A_sysvia.ifr &= 0xBF;
  systemviasetirq();
  HOSTMAP_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
  hmap->m = ((hmap->B_sysvia.t1doubled - cyclecount)>>1)&0xFF;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia05read(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t cyclecount;

  /*T1 high order counter*/
  HOSTMAP_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
  hmap->m = ((hmap->B_sysvia.t1doubled - cyclecount)>>9)&0xFF;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia06read(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T1 low order latch*/
  hmap->m = hmap->A_sysvia.t1ll;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia07read(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T1 high order latch*/
  hmap->m = hmap->A_sysvia.t1lh;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia08read(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t cyclecount;

  /*T2 low order counter*/
  /*T2 interrupt flag is cleared (IFR b5)*/
  hmap->A_sysvia.ifr &= 0xDF;
  systemviasetirq();
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    HOSTMAP_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
    hmap->m = ((hmap->B_sysvia.t2doubled - cyclecount)>>1)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_sysvia.t2doubled>>1)&0xFF;
  }

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia09read(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t cyclecount;

  /*T2 high order counter*/
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    HOSTMAP_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
    hmap->m = ((hmap->B_sysvia.t2doubled - cyclecount)>>9)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_sysvia.t2doubled>>9)&0xFF;
  }

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Aread(HOSTMAP* hmap, uintptr_t address_code)
{
  /*shift register*/
  /*SR interrupt flag is cleared (IFR b2)*/
  hmap->A_sysvia.ifr &= 0xFB;
  systemviasetirq();
  hmap->m = hmap->A_sysvia.sr;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Bread(HOSTMAP* hmap, uintptr_t address_code)
{
  /*auxilary control reg*/
  hmap->m = hmap->A_sysvia.acr;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Cread(HOSTMAP* hmap, uintptr_t address_code)
{
  /*peripheral control reg*/
  hmap->m = hmap->A_sysvia.pcr;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Dread(HOSTMAP* hmap, uintptr_t address_code)
{
  /*interrupt flag reg*/
  /*b7 of this register will be read as a logic 1*/
  /*when an interrupt exists within the chip*/
  systemviasetirq();
  hmap->m = hmap->A_sysvia.ifr;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Eread(HOSTMAP* hmap, uintptr_t address_code)
{
  /*interrupt enable reg*/
  hmap->m = (hmap->A_sysvia.ier | 0x80);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fread_b(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nresult;

  /*input output reg a*/
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (keystatus[(hmap->A_sysvia.porta & hmap->A_sysvia.ddra)])
      hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
    nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fread_m(HOSTMAP* hmap, uintptr_t address_code)
{
  unsigned int nresult;

  /*input output reg a*/
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (hmap->rtc.chipselect && hmap->rtc.readwrite)
    {
      hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
      /*nresult = (hmap->A_sysvia.porta & hmap->A_sysvia.ddra);
      if (hmap->rtc.chipselect)
        nresult |= (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);*/
      nresult = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
    }
    else
    {
      if (keystatus[(hmap->A_sysvia.porta & hmap->A_sysvia.ddra)])
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      nresult = hmap->A_sysvia.porta;
    }
  }
  hmap->m = nresult;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

static inline void systemviaportbwrite(HOSTMAP* hmap)
{
  /*input/output reg b*/
  hmap->A_sysvia.orb = hmap->m;
  hmap->A_sysvia.portb = (hmap->A_sysvia.orb & hmap->A_sysvia.ddrb) | (hmap->A_sysvia.portb & ~hmap->A_sysvia.ddrb);
  /*PCR & 0x20 = CB2 input*/
  /*PCR & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_sysvia.pcr & 0xE0) == 0x20) OR ((hmap->A_sysvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_sysvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_sysvia.ifr &= 0xE7;
  }
  systemviasetirq();
}

static inline void systemviaportawrite(HOSTMAP* hmap)
{
  /*input/output reg a*/
  /*zeribeep_value = hmap->m;*/
  hmap->A_sysvia.ora = hmap->m;
  hmap->A_sysvia.porta = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
  /*PCR & 0x02 = CA2 input*/
  /*PCR & 0x04 = CA2 active edge input*/
  /*indepandant mode*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviasetirq();
}

static inline void systemviaportawritenohandshake(HOSTMAP* hmap)
{
  /*input/output reg a*/
  hmap->A_sysvia.ora = hmap->m;
  hmap->A_sysvia.porta = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}

static inline void systemviaportbwrite_latchb(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_latchm(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_nosoundlatchb(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_nosoundlatchm(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportawrite_latchb(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_latchm(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_nosoundlatchb(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_nosoundlatchm(HOSTMAP* hmap)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

HOSTMAP* systemvia00write_b(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg b*/
  systemviaportbwrite(hmap);
  systemviaportbwrite_latchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia00write_m(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg b*/
  systemviaportbwrite(hmap);
  systemviaportbwrite_latchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia00write_nosoundb(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg b*/
  systemviaportbwrite(hmap);
  systemviaportbwrite_nosoundlatchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia00write_nosoundm(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg b*/
  systemviaportbwrite(hmap);
  systemviaportbwrite_nosoundlatchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01write_b(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawrite(hmap);
  systemviaportawrite_latchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01write_m(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawrite(hmap);
  systemviaportawrite_latchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01write_nosoundb(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawrite(hmap);
  systemviaportawrite_nosoundlatchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia01write_nosoundm(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawrite(hmap);
  systemviaportawrite_nosoundlatchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia02write(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_sysvia.ddrb = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia03write(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_sysvia.ddra = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia04write(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T1 low order latch*/
  hmap->A_sysvia.t1ll = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia05write(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t expiryoffset;

  /*T1 high order counter*/
  hmap->A_sysvia.t1lh = hmap->m;
  /*clear T1 interrupt flag (b6)*/
  hmap->A_sysvia.ifr &= 0xBF;
  systemviasetirq();
  if ((hmap->A_sysvia.acr & 0xC0) == 0x80)
  {
    /*output enabled (b7=1) and free-run disabled (b6=0)*/
    /*one-shot mode*/
    /*PB7 goes low, but goes high when timer 1 times out*/
    /*hmap->A_sysvia.orb &= 0x7F;
    hmap->A_sysvia.irb &= 0x7F;*/
    hmap->A_sysvia.portb &= 0x7F;
  }
  hmap->A_sysvia.t1setint = TRUE;
  hmap->B_sysvia.t1doubled = (hmap->A_sysvia.t1lh<<9) | (hmap->A_sysvia.t1ll<<1);
  HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
  hmap->B_sysvia.t1doubled += expiryoffset;
  // the interrupt flag is set after the counter has passed through zero
  HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t1doubled + 2)
  hmap->A_sysvia.aftert1 = 0;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia06write(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T1 low order latch*/
  hmap->A_sysvia.t1ll = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia07write(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T1 high order latch*/
  hmap->A_sysvia.t1lh = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia08write(HOSTMAP* hmap, uintptr_t address_code)
{
  /*T2 low order latch*/
  hmap->A_sysvia.t2ll = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia09write(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t expiryoffset;

  /*T2 high order counter*/
  /*clear T2 interrupt flag (bit 5)*/
  hmap->A_sysvia.ifr &= 0xDF;
  systemviasetirq();
  /*provide a single interrupt*/
  hmap->A_sysvia.t2setint=TRUE;
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled = (hmap->m<<9) | (hmap->A_sysvia.t2ll<<1);
    HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
    hmap->B_sysvia.t2doubled += expiryoffset;
    // the interrupt flag is set after the counter has passed through zero
    HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
  }
  else
  {
    /*pulse counting mode*/
    hmap->B_sysvia.t2doubled = (hmap->m<<9) | (hmap->A_sysvia.t2ll<<1);
    /*speech system not available*/
  }

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Awrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*shift reg*/
  hmap->A_sysvia.sr = hmap->m;
  hmap->A_sysvia.ifr &= 0xFB;
  systemviasetirq();

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Bwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t expiryoffset;

  /*auxiliary control reg*/
  if ((hmap->A_sysvia.acr ^ hmap->m) & 0x20)
  {
    HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
    if (!(hmap->m & 0x20))
    {
      /*one-shot mode*/
      hmap->B_sysvia.t2doubled += expiryoffset;
      HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
    }
    else
    {
      /*pulse counting mode*/
      hmap->B_sysvia.t2doubled -= expiryoffset;
    }
  }
  hmap->A_sysvia.acr = hmap->m;

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Cwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*peripheral control reg*/
  hmap->A_sysvia.pcr = hmap->m;
  /*CA1 active edge*/
  if (hmap->A_sysvia.pcr & 0x01)
  {
    /*set b2 (CA1)*/
    hmap->A_sysvia.ifr |= 0x02;
  }
  /*CA2 active edge*/
  if ((hmap->A_sysvia.pcr & 0x0E) == 0x04)
  {
    /*set b1 (CA2)*/
    hmap->A_sysvia.ifr |= 0x01;
  }
  /*CB1 active edge*/
  if (hmap->A_sysvia.pcr & 0x10)
  {
    /*set b5 (CB1)*/
    hmap->A_sysvia.ifr |= 0x10;
  }
  /*CB2 active edge*/
  if ((hmap->A_sysvia.pcr & 0xE0) == 0x40)
  {
    /*set b4 (CB2)*/
    hmap->A_sysvia.ifr |= 0x08;
  }

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Dwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*interrupt flag reg*/
  hmap->m &= 0x7F; /*not really needed*/
  hmap->A_sysvia.ifr &= (~hmap->m);
  systemviasetirq();

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Ewrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*interrupt enable reg*/
  if (hmap->m & 0x80)
    hmap->A_sysvia.ier |= hmap->m;
  else
    hmap->A_sysvia.ier &= (~hmap->m);
  hmap->A_sysvia.ier &= 0x7F;
  systemviasetirq();

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fwrite_b(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawritenohandshake(hmap);
  systemviaportawrite_latchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fwrite_m(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawritenohandshake(hmap);
  systemviaportawrite_latchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fwrite_nosoundb(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawritenohandshake(hmap);
  systemviaportawrite_nosoundlatchb(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* systemvia0Fwrite_nosoundm(HOSTMAP* hmap, uintptr_t address_code)
{
  /*input/output reg a*/
  systemviaportawritenohandshake(hmap);
  systemviaportawrite_nosoundlatchm(hmap);

  R6502_JUMP_FROM_HIGH_OP(hmap)
}
