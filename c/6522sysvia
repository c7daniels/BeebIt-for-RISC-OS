/*>6522sysvia.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Rockwell 6522 Versatile Interface Adapter (VIA) [1MHz]
 *
 * (C) Copyright Michael J Foot, 1998-2002
 *
 * Email: <mjfoot.nz@gmail.com>
 */

/* 0xffff * 2 = 0x1fffe +2 = 0x20000 */

/*ACR bits*/
/*b7 = output enable*/
/*b6 = free-run enable*/
/*b5 = timer 2 control (0=timed interrupt,1=countdown with pulses)*/
/*b1 = PB latching enabled*/
/*b0 = PA latching enabled*/

#include <stddef.h>
#include <time.h>
#include "beebit.h"
#include "host.h"
#include "6522sysvia.h"
#include "keyboard.h"
#include "main.h"
#include "riscos.h"
#ifdef __RISCOS__
#include "kernel.h"
#include "swis.h"
#endif

/*System VIA*/

#ifdef __RISCOS__
extern _kernel_swi_regs regs;

extern void zeribeepwrite(HOSTMAP* hmap, char nvalue);
#endif

static int ScreenStartArray[] = {0x4000,0x6000,0x3000,0x5800};

char bcd(char nvalue)
{
  //convert a decimal value to a BCD value
  return(((nvalue / 10) * 16) + nvalue % 10);
}

char cmosread(char naddress)
{
  #ifdef __RISCOS__
    char cmosclock[8];
  #else
    time_t currenttime;
    struct tm * splittime;
  #endif
  switch (naddress)
  {
    case 0x00:
    case 0x01:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[6]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_sec));
      #endif
       break;
    case 0x02:
    case 0x03:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[5]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_min));
      #endif
      break;
    case 0x04:
    case 0x05:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[4]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_hour));
      #endif
      break;
    case 0x06:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[3]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_wday)+1);
      #endif
      break;
    case 0x07:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[2]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_mday));
      #endif
      return(0);
      break;
    case 0x08:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[1]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_mon+1));
      #endif
      break;
    case 0x09:
      /*clock*/
      #ifdef __RISCOS__
        cmosclock[0] = 1;
        regs.r[0] = 14;
        regs.r[1] = (int)cmosclock;
        _kernel_swi(OS_Word,&regs,&regs);
        return(cmosclock[0]);
      #else
        time(&currenttime);
        splittime = localtime(&currenttime);
        return (bcd(splittime->tm_year-10));
      #endif
      break;
    case 0x0A:
    case 0x0B:
    case 0x0C:
    case 0x0D:
      /*registers*/
      return(0);
      break;
    default:
      return(beebit_cmos[naddress-0x0E]);
      break;
  }
}

void cmoswrite(char naddress,char nvalue)
{
  switch (naddress)
  {
    case 0x00:
    case 0x01:
    case 0x02:
    case 0x03:
    case 0x04:
    case 0x05:
    case 0x06:
    case 0x07:
    case 0x08:
    case 0x09:
      break;
    case 0x0A:
    case 0x0B:
    case 0x0C:
    case 0x0D:
      break;
    default:
      beebit_cmos[naddress-0x0E] = nvalue;
      break;
  }
}

void systemviaeventsetirq(HOSTMAP* hmap)
{
  if (hmap->A_sysvia.ifr & hmap->A_sysvia.ier & 0x7F)
  {
    /*if (beebit_trace)
      fprintf(htrace,"SV IRQ=&FF\n");*/
    hmap->A_sysvia.ifr |= 0x80;
    HOST_SETSHIFTEDIRQ(hmap, HOST_IRQ_6522SYSVIA)
  }
  else
  {
    hmap->A_sysvia.ifr &= 0x7F;
    HOST_CLEARSHIFTEDIRQ(hmap, HOST_IRQ_6522SYSVIA)
  }
}

void systemviaregistersetirq(HOSTMAP* hmap)
{
  if (hmap->A_sysvia.ifr & hmap->A_sysvia.ier & 0x7F)
  {
    /*if (beebit_trace)
      fprintf(htrace,"SV IRQ=&FF\n");*/
    hmap->A_sysvia.ifr |= 0x80;
    HOST_SETIRQ(hmap, HOST_IRQ_6522SYSVIA)
  }
  else
  {
    hmap->A_sysvia.ifr &= 0x7F;
    HOST_CLEARIRQ(hmap, HOST_IRQ_6522SYSVIA)
  }
}

void systemviasetca1(void)
{
  HOSTMAP* hmap = &hostmap;
  #ifdef __DEBUG__
    fprintf(htrace,"CA1 ");
  #endif
  hmap->A_sysvia.ifr |= 0x02; /*CA1 flag*/
  systemviaeventsetirq(hmap);
}

/*void systemviavidca1(void)
{*/
  /*CA1 flag*/
  /*hmap->A_sysvia.ifr |= 0x02;
  systemviaeventsetirq(hmap);
  hmap->A_sysvia.ira=(hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}*/

/*void systemviavidirq(void)
{
  systemviaeventsetirq(hmap);
  hmap->A_sysvia.ira=(hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}*/

void systemviaunsetca1(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_sysvia.ifr &= 0xFD; /*CA1 flag*/
  systemviaeventsetirq(hmap);
}

void systemviasetca2(void)
{
  HOSTMAP* hmap = &hostmap;
  #ifdef __DEBUG__
    fprintf(htrace,"CA2 ");
  #endif
  switch (hmap->A_sysvia.pcr & 0x0E)
  {
    case 0:
    case 2:
      /*updatekeyboard();*/
      hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
      systemviaeventsetirq(hmap);
      break;
    case 4:
    case 6:
      /*updatekeyboard();*/
      hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
      systemviaeventsetirq(hmap);
      break;
  }
}

void systemviakeyca2(void)
{
  HOSTMAP* hmap = &hostmap;
  /*updatekeyboard();*/
  /*if (beebit_trace)
    printf("SVK PC=%X, SP=%X %X\n", r6502_pc, r6502_sp, hmap->A_sysvia.ifr);*/
  hmap->A_sysvia.ifr |= 0x01; /*CA2 flag*/
  systemviaregistersetirq(hmap);
}

/*void systemviaunsetca2(void)
{
  hmap->A_sysvia.ifr &= 0xFE;*/ /*CA2 flag*/
  /*systemviaeventsetirq(hmap);
}*/

static intptr_t systemviapickcyclestogo(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t cyclestogo;

  // the interrupt flag is set after the counter has passed through zero
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    if (hmap->B_sysvia.t1doubled < hmap->B_sysvia.t2doubled)
    {
      cyclestogo = hmap->B_sysvia.t1doubled + 2;
    }
    else
    {
      cyclestogo = hmap->B_sysvia.t2doubled + 2;
    }
  }
  else
  {
    cyclestogo = hmap->B_sysvia.t1doubled + 2;
  }

  if (hmap->A_sysvia.aftert1)
  {
    cyclestogo = 1;
  }

  return cyclestogo;
}

void systemviareset(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled = expiryoffset;
  hmap->B_sysvia.t2doubled = expiryoffset;
  hmap->A_sysvia.sr = 0;

  /*if ier is set to none, a hard reset will be done*/
  hmap->A_sysvia.ier = 0x80;

  hmap->A_sysvia.ifr = 0x00;
  hmap->A_sysvia.ddra = 0; /*input*/
  hmap->A_sysvia.ddrb = 0; /*input*/
  hmap->A_sysvia.t1ll = 0xFF;
  hmap->A_sysvia.t1lh = 0xFF;
  hmap->A_sysvia.t2ll = 0xFF;
  hmap->A_sysvia.acr = 0;
  hmap->A_sysvia.pcr = 0;
  hmap->A_sysvia.ora = 0xFF;
  hmap->A_sysvia.ira = 0xFF;
  hmap->A_sysvia.orb = 0xFF;
  hmap->A_sysvia.irb = 0xFF;
  hmap->A_sysvia.porta = 0xFF;
  hmap->A_sysvia.portb = 0xFF;

  hmap->A_sysvia.aftert1 = FALSE;
  hmap->A_sysvia.t1setint = FALSE;
  hmap->A_sysvia.t2setint = FALSE;

  hmap->lsoundlatch = FALSE;
  systemviaregistersetirq(hmap);
  hmap->screenstartaddress = 0;
  hmap->screenstartindex = 0;

  hmap->cycles.sysvia_togo = systemviapickcyclestogo();
  hmap->cycles.sysvia_original = hmap->cycles.sysvia_togo;

  HOST_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.sysvia_togo)
}

void systemviabeforesnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled -= expiryoffset;
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled -= expiryoffset;
  }
}

void systemviaaftersnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, sysvia)

  hmap->B_sysvia.t1doubled += expiryoffset;
  HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t1doubled + 2)
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled += expiryoffset;
    HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
  }

  systemviaregistersetirq(hmap);
}

HOSTMAP* systemviaatzerocycles(HOSTMAP* hmap)
{
  /*we are dealing with a 1MHz device here*/
  hmap->B_sysvia.t1doubled -= hmap->cycles.sysvia_original;

  if (hmap->B_sysvia.t1doubled == -2)
  {
    switch (hmap->A_sysvia.acr & 0xC0)
    {
      case 0x00:
        /*output disabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        if (hmap->A_sysvia.t1setint)
        {
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
          hmap->A_sysvia.t1setint = FALSE;
        }
        break;
      case 0x40:
        /*output disabled and free-run mode*/
        /*continuous interrupts*/
        /*ELITE uses this one*/
         if (hmap->A_sysvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
        break;
      case 0x80:
        /*output enabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        if (hmap->A_sysvia.t1setint)
        {
          /*PB7 goes high*/
          hmap->A_sysvia.portb |= 0x80;
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
          hmap->A_sysvia.t1setint = FALSE;
        }
        break;
      case 0xC0:
        /*output enabled and free-run mode*/
        /*continuous interrupts*/
        hmap->A_sysvia.portb ^= 0x80;
        if (hmap->A_sysvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_sysvia.ifr |= 0x40;
        break;
    }

    hmap->B_sysvia.t1doubled += 0x20000;
    hmap->A_sysvia.aftert1 = TRUE;
  }
  else if (hmap->A_sysvia.aftert1)
  {
    if (hmap->A_sysvia.acr & 0x40)
    {
      hmap->B_sysvia.t1doubled = ((hmap->A_sysvia.t1lh<<9) | (hmap->A_sysvia.t1ll<<1)) + 1;
    }
    hmap->A_sysvia.aftert1 = 0;
  }

  if (!(hmap->A_sysvia.acr & 0x20))
  {
    hmap->B_sysvia.t2doubled -= hmap->cycles.sysvia_original;

    if (hmap->B_sysvia.t2doubled == -2)
    {
      if (hmap->A_sysvia.t2setint)
      {
        /*on completion of the timing interval,
          T2 interrupt flag is set (IFR b5)*/
        hmap->A_sysvia.ifr |= 0x20;
        hmap->A_sysvia.t2setint=FALSE;
      }

      hmap->B_sysvia.t2doubled += 0x20000;
    }
  }

  hmap->cycles.sysvia_togo = hmap->cycles.sysvia_original = systemviapickcyclestogo();

  systemviaeventsetirq(hmap);
  return hmap;
}

struct R6502CPUMAP* systemvia00read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  unsigned int nresult;

  /*hmap->A_sysvia.pcr & 0x20 = CB2 input*/
  /*hmap->A_sysvia.pcr & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_sysvia.pcr & 0xE0) == 0x20) OR ((hmap->A_sysvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_sysvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_sysvia.ifr &= 0xE7;
  }
  systemviaregistersetirq(hmap);
  /*reads output register bit in orb. pin level has no effect*/
  nresult = (hmap->A_sysvia.orb & hmap->A_sysvia.ddrb);
  if (hmap->A_sysvia.acr & 0x02)
  {
    /*input latching enabled*/
    /*read input level on irb*/
    nresult |= (hmap->A_sysvia.irb & ~hmap->A_sysvia.ddrb);
  }
  else
  {
    /*input latching disabled*/
    /*read input level on PB pin*/
    nresult |= (hmap->A_sysvia.portb & ~hmap->A_sysvia.ddrb);
  }
  if (!beebit_button1)
    nresult |= 0x10; /*fire button 1 released*/
  if (!beebit_button2)
    nresult |= 0x20; /*fire button 2 released*/

  nresult |= 0xC0; /*speech system not available*/
  /*nresult |= 0xF0;*/
  #ifdef __DEBUG__
    fprintf(htrace,"=&%X (&%X & &%X) ",nresult,hmap->A_sysvia.orb,hmap->A_sysvia.ddrb);
  #endif
  hmap->m = nresult;

  return cmap;
}

struct R6502CPUMAP* systemvia01read_b(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  unsigned int nresult;

  /*hmap->A_sysvia.pcr & 0x02 = CA2 input*/
  /*hmap->A_sysvia.pcr & 0x04 = CA2 active edge input*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*independant interrupt*/
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviaregistersetirq(hmap);
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  return cmap;
}

struct R6502CPUMAP* systemvia01read_m(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  unsigned int nresult;

  /*hmap->A_sysvia.pcr & 0x02 = CA2 input*/
  /*hmap->A_sysvia.pcr & 0x04 = CA2 active edge input*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*independant interrupt*/
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviaregistersetirq(hmap);
  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (hmap->rtc.chipselect && hmap->rtc.readwrite)
    {
      hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
      /*nresult = (hmap->A_sysvia.porta & hmap->A_sysvia.ddra);
      if (hmap->rtc.chipselect)
        nresult |= (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);*/
      nresult = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
    }
    else
      nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  return cmap;
}

struct R6502CPUMAP* systemvia02read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.ddrb;

  return cmap;
}

struct R6502CPUMAP* systemvia03read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.ddra;

  return cmap;
}

struct R6502CPUMAP* systemvia04read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 low order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  /*T1 interrupt flag is reset (IFR b6)*/
  hmap->A_sysvia.ifr &= 0xBF;
  systemviaregistersetirq(hmap);
  HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
  hmap->m = ((hmap->B_sysvia.t1doubled - cyclecount)>>1)&0xFF;

  return cmap;
}

struct R6502CPUMAP* systemvia05read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
  hmap->m = ((hmap->B_sysvia.t1doubled - cyclecount)>>9)&0xFF;

  return cmap;
}

struct R6502CPUMAP* systemvia06read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.t1ll;

  return cmap;
}

struct R6502CPUMAP* systemvia07read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 high order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.t1lh;

  return cmap;
}

struct R6502CPUMAP* systemvia08read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T2 low order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  /*T2 interrupt flag is cleared (IFR b5)*/
  hmap->A_sysvia.ifr &= 0xDF;
  systemviaregistersetirq(hmap);
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
    hmap->m = ((hmap->B_sysvia.t2doubled - cyclecount)>>1)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_sysvia.t2doubled>>1)&0xFF;
  }

  return cmap;
}

struct R6502CPUMAP* systemvia09read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T2 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  if (!(hmap->A_sysvia.acr & 0x20))
  {
    HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, sysvia)
    hmap->m = ((hmap->B_sysvia.t2doubled - cyclecount)>>9)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_sysvia.t2doubled>>9)&0xFF;
  }

  return cmap;
}

struct R6502CPUMAP* systemvia0Aread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*shift register*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*SR interrupt flag is cleared (IFR b2)*/
  hmap->A_sysvia.ifr &= 0xFB;
  systemviaregistersetirq(hmap);
  hmap->m = hmap->A_sysvia.sr;

  return cmap;
}

struct R6502CPUMAP* systemvia0Bread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*auxilary control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.acr;

  return cmap;
}

struct R6502CPUMAP* systemvia0Cread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*peripheral control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_sysvia.pcr;

  return cmap;
}

struct R6502CPUMAP* systemvia0Dread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*interrupt flag reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*b7 of this register will be read as a logic 1*/
  /*when an interrupt exists within the chip*/
  systemviaregistersetirq(hmap);
  hmap->m = hmap->A_sysvia.ifr;

  return cmap;
}

struct R6502CPUMAP* systemvia0Eread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*interrupt enable reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = (hmap->A_sysvia.ier | 0x80);

  return cmap;
}

struct R6502CPUMAP* systemvia0Fread_b(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  unsigned int nresult;

  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (keystatus[(hmap->A_sysvia.porta & hmap->A_sysvia.ddra)])
      hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
    nresult = hmap->A_sysvia.porta;
  }
  hmap->m = nresult;

  return cmap;
}

struct R6502CPUMAP* systemvia0Fread_m(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  unsigned int nresult;

  if (hmap->A_sysvia.acr & 0x01)
  {
    /*input latching enabled*/
    nresult = hmap->A_sysvia.ira;
  }
  else
  {
    /*input latching disabled*/
    if (hmap->rtc.chipselect && hmap->rtc.readwrite)
    {
      hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
      /*nresult = (hmap->A_sysvia.porta & hmap->A_sysvia.ddra);
      if (hmap->rtc.chipselect)
        nresult |= (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);*/
      nresult = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
    }
    else
    {
      if (keystatus[(hmap->A_sysvia.porta & hmap->A_sysvia.ddra)])
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      nresult = hmap->A_sysvia.porta;
    }
  }
  hmap->m = nresult;

  return cmap;
}

static inline void systemviaportbwrite(HOSTMAP* hmap, uint8_t value)
{
  /*input/output reg b*/
  hmap->A_sysvia.orb = value;
  hmap->A_sysvia.portb = (hmap->A_sysvia.orb & hmap->A_sysvia.ddrb) | (hmap->A_sysvia.portb & ~hmap->A_sysvia.ddrb);
  /*PCR & 0x20 = CB2 input*/
  /*PCR & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_sysvia.pcr & 0xE0) == 0x20) OR ((hmap->A_sysvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_sysvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_sysvia.ifr &= 0xE7;
  }
  systemviaregistersetirq(hmap);
}

static inline void systemviaportawrite(HOSTMAP* hmap, uint8_t value)
{
  /*input/output reg a*/
  /*zeribeep_value = value;*/
  hmap->A_sysvia.ora = value;
  hmap->A_sysvia.porta = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
  /*PCR & 0x02 = CA2 input*/
  /*PCR & 0x04 = CA2 active edge input*/
  /*indepandant mode*/
  if (((hmap->A_sysvia.pcr & 0x0E) == 0x02) OR ((hmap->A_sysvia.pcr & 0x0E) == 0x06))
  {
    /*clear b2 (CA1)*/
    hmap->A_sysvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_sysvia.ifr &= 0xFC;
  }
  systemviaregistersetirq(hmap);
}

static inline void systemviaportawritenohandshake(HOSTMAP* hmap, uint8_t value)
{
  /*input/output reg a*/
  hmap->A_sysvia.ora = value;
  hmap->A_sysvia.porta = (hmap->A_sysvia.ora & hmap->A_sysvia.ddra) | (hmap->A_sysvia.porta & ~hmap->A_sysvia.ddra);
}

static inline void systemviaportbwrite_latchb(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
#ifdef __RISCOS__
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
#endif
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_latchm(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
#ifdef __RISCOS__
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
#endif
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_nosoundlatchb(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
#ifdef __RISCOS__
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
#endif
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportbwrite_nosoundlatchm(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);

  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->A_sysvia.portb & 0x80)
        hmap->rtc.addrstrobe = hmap->A_sysvia.porta;
      hmap->rtc.chipselect = (hmap->A_sysvia.portb & 0x40);
      if (hmap->rtc.chipselect)
      {
        if (hmap->rtc.readwrite)
          hmap->A_sysvia.porta = cmosread(hmap->rtc.addrstrobe);
        else
        {
          if (hmap->rtc.datastrobe)
            cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
        }
      }
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
    case 0x04:
      /*Screen Size hi*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x05:
      /*Screen Size lo*/
      if (!lenabled)
      {
        hmap->screenstartindex &= 1;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      else
      {
        hmap->screenstartindex |= 2;
        hmap->screenstartaddress=ScreenStartArray[hmap->screenstartindex];
      }
      break;
    case 0x06:
      /*caps lock on/off*/
      /*get keyboard status*/
#ifdef __RISCOS__
      regs.r[0] = 202;
      regs.r[1] = 0;
      regs.r[2] = 255;
      _kernel_swi(OS_Byte,&regs,&regs);

      beebit_leds = (beebit_leds & 0xEF) | (lenabled ? 0x10 : 0x00);

      if ((regs.r[1] ^ beebit_leds) & 0x10)
      {
        /*only update the keyboard leds if they differ*/

        /*set keyboard status*/
        regs.r[0] = 202;
        regs.r[1] = beebit_leds & 0x10;
        regs.r[2] = 0xEF;
        _kernel_swi(OS_Byte,&regs,&regs);

        /*set the leds*/
        regs.r[0] = 118;
        _kernel_swi(OS_Byte,&regs,&regs);
      }
#endif
      break;
    case 0x07:
      /*shift lock on/off*/
      break;
  }
}

static inline void systemviaportawrite_latchb(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_latchm(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      if (lenabled AND !hmap->lsoundlatch)
      {
#ifdef __RISCOS__
        zeribeepwrite(hmap, hmap->A_sysvia.ora);
#endif
      }
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_nosoundlatchb(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*read speech*/
      break;
    case 0x02:
      /*write speech*/
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

static inline void systemviaportawrite_nosoundlatchm(HOSTMAP* hmap, uint8_t value)
{
  int nlatch,lenabled;

  nlatch = (hmap->A_sysvia.portb & 0x07);
  lenabled = (hmap->A_sysvia.portb & 0x08);
  switch (nlatch)
  {
    case 0x00:
      /*sound write enable*/
      hmap->lsoundlatch = lenabled;
      break;
    case 0x01:
      /*RTC/RAM read write*/
      hmap->rtc.readwrite = lenabled;
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      break;
    case 0x02:
      /*RTC/RAM data strobe*/
      if (hmap->rtc.datastrobe && hmap->rtc.readwrite && hmap->rtc.chipselect)
        cmoswrite(hmap->rtc.addrstrobe, hmap->A_sysvia.porta);
      hmap->rtc.datastrobe = lenabled;
      break;
    case 0x03:
      /*keyboard*/
      if (!lenabled)
        hmap->A_sysvia.porta = keyboardread(hmap->A_sysvia.porta,hmap->A_sysvia.ddra);
      break;
  }
}

struct R6502CPUMAP* systemvia00write_b(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportbwrite(hmap, value);
  systemviaportbwrite_latchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia00write_m(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportbwrite(hmap, value);
  systemviaportbwrite_latchm(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia00write_nosoundb(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportbwrite(hmap, value);
  systemviaportbwrite_nosoundlatchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia00write_nosoundm(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportbwrite(hmap, value);
  systemviaportbwrite_nosoundlatchm(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia01write_b(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawrite(hmap, value);
  systemviaportawrite_latchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia01write_m(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawrite(hmap, value);
  systemviaportawrite_latchm(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia01write_nosoundb(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawrite(hmap, value);
  systemviaportawrite_nosoundlatchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia01write_nosoundm(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawrite(hmap, value);
  systemviaportawrite_nosoundlatchm(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia02write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.ddrb = value;

  return cmap;
}

struct R6502CPUMAP* systemvia03write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.ddra = value;

  return cmap;
}

struct R6502CPUMAP* systemvia04write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.t1ll = value;

  return cmap;
}

struct R6502CPUMAP* systemvia05write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  hmap->A_sysvia.t1lh = value;
  /*clear T1 interrupt flag (b6)*/
  hmap->A_sysvia.ifr &= 0xBF;
  systemviaregistersetirq(hmap);
  if ((hmap->A_sysvia.acr & 0xC0) == 0x80)
  {
    /*output enabled (b7=1) and free-run disabled (b6=0)*/
    /*one-shot mode*/
    /*PB7 goes low, but goes high when timer 1 times out*/
    /*hmap->A_sysvia.orb &= 0x7F;
    hmap->A_sysvia.irb &= 0x7F;*/
    hmap->A_sysvia.portb &= 0x7F;
  }
  hmap->A_sysvia.t1setint = TRUE;
  hmap->B_sysvia.t1doubled = (hmap->A_sysvia.t1lh<<9) | (hmap->A_sysvia.t1ll<<1);
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
  hmap->B_sysvia.t1doubled += expiryoffset;
  // the interrupt flag is set after the counter has passed through zero
  HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t1doubled + 2)
  hmap->A_sysvia.aftert1 = 0;

  return cmap;
}

struct R6502CPUMAP* systemvia06write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.t1ll = value;

  return cmap;
}

struct R6502CPUMAP* systemvia07write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 high order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.t1lh = value;

  return cmap;
}

struct R6502CPUMAP* systemvia08write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T2 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.t2ll = value;

  return cmap;
}

struct R6502CPUMAP* systemvia09write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T2 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  /*clear T2 interrupt flag (bit 5)*/
  hmap->A_sysvia.ifr &= 0xDF;
  systemviaregistersetirq(hmap);
  /*provide a single interrupt*/
  hmap->A_sysvia.t2setint=TRUE;
  if (!(hmap->A_sysvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_sysvia.t2doubled = (value<<9) | (hmap->A_sysvia.t2ll<<1);
    HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
    hmap->B_sysvia.t2doubled += expiryoffset;
    // the interrupt flag is set after the counter has passed through zero
    HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
  }
  else
  {
    /*pulse counting mode*/
    hmap->B_sysvia.t2doubled = (value<<9) | (hmap->A_sysvia.t2ll<<1);
    /*speech system not available*/
  }

  return cmap;
}

struct R6502CPUMAP* systemvia0Awrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*shift reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.sr = value;
  hmap->A_sysvia.ifr &= 0xFB;
  systemviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* systemvia0Bwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*auxiliary control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  if ((hmap->A_sysvia.acr ^ value) & 0x20)
  {
    HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, sysvia)
    if (!(value & 0x20))
    {
      /*one-shot mode*/
      hmap->B_sysvia.t2doubled += expiryoffset;
      HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, sysvia, hmap->B_sysvia.t2doubled + 2)
    }
    else
    {
      /*pulse counting mode*/
      hmap->B_sysvia.t2doubled -= expiryoffset;
    }
  }
  hmap->A_sysvia.acr = value;

  return cmap;
}

struct R6502CPUMAP* systemvia0Cwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*peripheral control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_sysvia.pcr = value;
  /*CA1 active edge*/
  if (hmap->A_sysvia.pcr & 0x01)
  {
    /*set b2 (CA1)*/
    hmap->A_sysvia.ifr |= 0x02;
  }
  /*CA2 active edge*/
  if ((hmap->A_sysvia.pcr & 0x0E) == 0x04)
  {
    /*set b1 (CA2)*/
    hmap->A_sysvia.ifr |= 0x01;
  }
  /*CB1 active edge*/
  if (hmap->A_sysvia.pcr & 0x10)
  {
    /*set b5 (CB1)*/
    hmap->A_sysvia.ifr |= 0x10;
  }
  /*CB2 active edge*/
  if ((hmap->A_sysvia.pcr & 0xE0) == 0x40)
  {
    /*set b4 (CB2)*/
    hmap->A_sysvia.ifr |= 0x08;
  }

  return cmap;
}

struct R6502CPUMAP* systemvia0Dwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*interrupt flag reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  value &= 0x7F; /*not really needed*/
  hmap->A_sysvia.ifr &= (~value);
  systemviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* systemvia0Ewrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*interrupt enable reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  if (value & 0x80)
    hmap->A_sysvia.ier |= value;
  else
    hmap->A_sysvia.ier &= (~value);
  hmap->A_sysvia.ier &= 0x7F;
  systemviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* systemvia0Fwrite_b(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawritenohandshake(hmap, value);
  systemviaportawrite_latchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia0Fwrite_m(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawritenohandshake(hmap, value);
  systemviaportawrite_latchm(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia0Fwrite_nosoundb(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawritenohandshake(hmap, value);
  systemviaportawrite_nosoundlatchb(hmap, value);

  return cmap;
}

struct R6502CPUMAP* systemvia0Fwrite_nosoundm(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  systemviaportawritenohandshake(hmap, value);
  systemviaportawrite_nosoundlatchm(hmap, value);

  return cmap;
}
