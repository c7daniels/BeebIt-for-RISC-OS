/*>6850acia.c
 *
 * 6850 Asynchronous Communications Interface Adaptor [1MHz]
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 *
 * Anytime the IRQ output is low, the IRQ status bit will be high
 *
 * W FE08 0003
 * W FE08 0056
 * W FE10 0064
 *
 */

#include <assert.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include "hostmap.h"
#include "6502cpu.h"
#include "6850acia.h"
#include "beebit.h"
#include "kernel.h"
#include "main.h"
#include "swis.h"

static_assert(sizeof(HOSTMAPUEFFILEPOINTERAREA) >= sizeof(long), "Expecting uef_filepointerarea to hold a long");

extern _kernel_swi_regs regs;

extern void uefread(void);

/*counter divide poll speed in 1MHz cycles (bits 0-15)*/
int m6850_pollspeed01[0x10] = {0,52,105,156,208,260,312,365,417,469,521,573,625,677,729,781};
int m6850_pollspeed16[0x10] = {0,833,1667,2500,3333,4167,5000,5833,6667,7500,8333,9167,10000,10833,11667,12500};
int m6850_pollspeed64[0x10] = {0,3333,6667,10000,13333,16667,20000,23333,26667,30000,33333,36667,40000,43333,46667,50000};

/*int serialula_baudrate[8] = {19200,1200,4800,150,9600,300,2400,75};*/

char uef_buffer[0xFF];

void aciareset(void)
{
  HOSTMAP* hmap = &hostmap;

  hmap->A_serial.m6850_controlreg = 0x00;
  hmap->A_serial.m6850_rxdatareg = 0x00;
  hmap->A_serial.m6850_txdatareg = 0x00;
  hmap->A_serial.m6850_rxdatashiftreg = 0x00;
  hmap->A_serial.m6850_txdatashiftreg = 0x00;

  hmap->A_serial.m6850_statusreg = 0x00;
  hmap->B_serial.m6850_CTS = hmap->B_serial.m6850_RTS = hmap->B_serial.m6850_DCD = FALSE;

  hmap->B_serial.m6850_counterdivide = 0x00;
  hmap->B_serial.m6850_bits = hmap->B_serial.m6850_parity = hmap->B_serial.m6850_stop = 0x00;
  hmap->B_serial.m6850_transmittingRTS = FALSE;
  hmap->B_serial.m6850_transmittingIRQ = FALSE;

  hmap->B_serial.m6850_cleardcd = 0;
  hmap->B_serial.m6850_timerreset = m6850_pollspeed64[9]; /*300 baud*/
  hmap->cycles.m6850_togo = 0;

  hmap->B_serial.m6850_firstreset = TRUE;

  hmap->A_serial.ula_reg = 0x00;
  hmap->B_serial.ula_txbaud = 0x00;
  hmap->B_serial.ula_rxbaud = 0x00;

  *((long*)&hmap->B_serial.uef_filepointerarea) = 12;
  hmap->B_serial.uef_buffer = uef_buffer;
  hmap->B_serial.uef_bufferpointer = 0;
}

void aciasetirq(void)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  if (hmap->A_serial.m6850_statusreg & 0x80 AND hmap->A_serial.m6850_controlreg & 0x80)
    cmap->irq |= IRQ_6850ACIA;
  else
    cmap->irq &= IRQ_NOT6850ACIA;
}

void aciadcdhigh(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_serial.m6850_statusreg |= 0x84; /*dcd, irq*/
  aciasetirq();
}

void aciadcdlow(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_serial.m6850_statusreg &= 0xFB; /*not dcd*/
  hmap->A_serial.m6850_statusreg |= 0x80; /*irq*/
  aciasetirq();
}

void aciareceive(char nbyte)
{
  HOSTMAP* hmap = &hostmap;

  hmap->A_serial.m6850_rxdatareg = nbyte;

  hmap->A_serial.m6850_statusreg |= 0x81; /*receive, irq*/
  aciasetirq();
}

HOSTMAP* aciapoll(HOSTMAP* hmap)
{
  if (hmap->A_serial.ula_reg & 0x80)
  {
    /*motor on*/
    /*printf("MOTOR ON\n");*/

    if (!(hmap->A_serial.m6850_statusreg & 0x01))
      uefread();
  }

  hmap->cycles.m6850_togo = hmap->B_serial.m6850_timerreset<<1;

  return hmap;
}

void aciaresettimer(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t bits;

  if (beebit_fasttape)
    hmap->B_serial.m6850_timerreset = 1000;
  else
  {
    bits = hmap->B_serial.m6850_bits + hmap->B_serial.m6850_stop;
    if (hmap->B_serial.m6850_parity != PARITY_NONE)
      bits++;
    switch (hmap->A_serial.m6850_controlreg & 0x03)
    {
      case 0x00:
        /*19200 baud*/
        hmap->B_serial.m6850_timerreset = m6850_pollspeed01[bits]; /*19200 baud*/
        break;
      case 0x01:
        /*1200 baud*/
        hmap->B_serial.m6850_timerreset = m6850_pollspeed16[bits]; /*1200 baud*/
        break;
      case 0x02:
        /*300 baud*/
        hmap->B_serial.m6850_timerreset = m6850_pollspeed64[bits]; /*300 baud*/
        break;
    }
  }
}

HOSTMAP* acia00read(HOSTMAP* hmap, uintptr_t address_code)
{
  if (hmap->A_serial.m6850_statusreg & 0x02)
  {
    if (hmap->B_serial.m6850_cleardcd > 0)
      hmap->B_serial.m6850_cleardcd = 2;
    else
    {
      hmap->B_serial.m6850_cleardcd--;
      if (hmap->B_serial.m6850_cleardcd == 0)
        hmap->A_serial.m6850_statusreg &= 0xFD; /*clear dcd*/
    }
  }
  hmap->m = (hmap->A_serial.m6850_statusreg);
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* acia01read(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  /*clear irq*/
  /*regs.r[0] = 0x04;*/ /*read byte*/
  /*_kernel_swi(OS_SerialOp,&regs,&regs);

   hmap->A_serial.m6850_rxdatareg = (regs.r[1] & 0xFF);*/

  hmap->A_serial.m6850_statusreg &= 0xFE;

  hmap->A_serial.m6850_statusreg &= 0x7F;
  cmap->irq &= IRQ_NOT6850ACIA;

  hmap->m = (hmap->A_serial.m6850_rxdatareg);
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* acia00write(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  hmap->A_serial.m6850_controlreg = hmap->m;
  if (!(hmap->A_serial.m6850_controlreg & 0x10))
  {
    hmap->B_serial.m6850_bits = 7;
    hmap->B_serial.m6850_parity = 2 - ((hmap->A_serial.m6850_controlreg & 0x04) >> 2);
    hmap->B_serial.m6850_stop = 2 - ((hmap->A_serial.m6850_controlreg & 0x08) >> 3);
  }
  else
  {
    hmap->B_serial.m6850_bits = 8;
    switch (hmap->A_serial.m6850_controlreg & 0x0C)
    {
      case 0x00:
        hmap->B_serial.m6850_parity = PARITY_NONE;
        hmap->B_serial.m6850_stop = 2;
        break;
      case 0x04:
        hmap->B_serial.m6850_parity = PARITY_NONE;
        hmap->B_serial.m6850_stop = 1;
        break;
      case 0x08:
        hmap->B_serial.m6850_parity = PARITY_EVEN;
        hmap->B_serial.m6850_stop = 1;
        break;
      case 0x0C:
        hmap->B_serial.m6850_parity = PARITY_ODD;
        hmap->B_serial.m6850_stop = 2;
        break;
    }
  }

  switch (hmap->A_serial.m6850_controlreg & 0x60)
  {
    case 0x00:
      hmap->B_serial.m6850_transmittingRTS = FALSE;
      hmap->B_serial.m6850_transmittingIRQ = FALSE;
      break;
    case 0x20:
      hmap->B_serial.m6850_transmittingRTS = FALSE;
      hmap->B_serial.m6850_transmittingIRQ = TRUE;
      break;
    case 0x40:
      hmap->B_serial.m6850_transmittingRTS = TRUE;
      hmap->B_serial.m6850_transmittingIRQ = FALSE;
      break;
    case 0x60:
      hmap->B_serial.m6850_transmittingRTS = FALSE;
      hmap->B_serial.m6850_transmittingIRQ = FALSE;
      break;
  }

  switch (hmap->A_serial.m6850_controlreg & 0x03)
  {
    case 0x00:
      /*19200 baud*/
      hmap->B_serial.m6850_counterdivide = 1;
      aciaresettimer();
      break;
    case 0x01:
      /*1200 baud*/
      hmap->B_serial.m6850_counterdivide = 16;
      aciaresettimer();
      break;
    case 0x02:
      /*300 baud*/
      hmap->B_serial.m6850_counterdivide = 64;
      aciaresettimer();
      break;
    case 0x03:
      /*master reset*/
      /*aciareset();*/
      if (hmap->B_serial.m6850_firstreset)
      {
        /*set IRQ to level 1*/
        /*hmap->B_serial.m6850_CTS = TRUE;*/
        hmap->B_serial.m6850_RTS = TRUE;
        /*hmap->A_serial.m6850_statusreg |= 0x08;*/ /*CTS*/
        hmap->B_serial.m6850_firstreset = FALSE;
      }
      else
      {
        hmap->B_serial.m6850_RTS = hmap->B_serial.m6850_transmittingRTS;
      }
      /*clear RDRF*/
      hmap->A_serial.m6850_statusreg &= 0xFE;
      /*clear irq*/
      hmap->A_serial.m6850_statusreg &= 0x7F;
      cmap->irq &= IRQ_NOT6850ACIA;
      break;
  }
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* acia01write(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  /*transmit data register*/
  hmap->A_serial.m6850_txdatareg = hmap->m;
  hmap->A_serial.m6850_statusreg &= 0xFD; /*TDRE*/
  /*clear irq*/
  hmap->A_serial.m6850_statusreg &= 0x7F;
  cmap->irq &= IRQ_NOT6850ACIA;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

/*-- SERIAL ULA --*/

HOSTMAP* serialularead(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = (hmap->A_serial.ula_reg);
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* serialulawrite(HOSTMAP* hmap, uintptr_t address_code)
{
  intptr_t cyclecount;
  hmap->A_serial.ula_reg = hmap->m;

  hmap->B_serial.ula_txbaud = (hmap->A_serial.ula_reg & 0x07);
  hmap->B_serial.ula_rxbaud = ((hmap->A_serial.ula_reg & 0x38) >> 3);

  if (hmap->A_serial.ula_reg & 0x40)
  {
    /*RS423*/
    /*clear DCD*/
    hmap->A_serial.m6850_statusreg &= 0xFB;
  }
  else
  {
    /*TAPE*/
    /*clear CTS*/
    hmap->A_serial.m6850_statusreg &= 0xF7;
  }

  if (hmap->A_serial.ula_reg & 0x80)
  {
    /*TAPE*/
    if (hmap->cycles.m6850_togo == 0 && hmap->B_serial.m6850_timerreset > 0)
    {
      hmap->cycles.m6850_togo = hmap->B_serial.m6850_timerreset<<1;
      HOSTMAP_GET_TOGO_FROM_WRITE_OFFSET(cyclecount, hmap)
      hmap->cycles.m6850_togo += 1 + cyclecount;
      HOSTMAP_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.m6850_togo)
    }
  }
  else
    /*RS423*/
    hmap->cycles.m6850_togo = 0;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

/*-- UEF --*/

int uefvalidate(FILE *hfile)
{
  int nreturn;
  if (hfile == NULL)
    nreturn = FALSE;
  else
  {
    /*reset file pointer*/
    fseek(hfile,0,SEEK_SET);
    /*check header*/
    if (fread(uef_buffer,1,10,hfile))
    {
      if (strcmp(uef_buffer, "UEF File!") == 0)
        nreturn = TRUE;
      else
        nreturn = FALSE;
    }
    else
      nreturn = FALSE;
  }
  return (nreturn);
}

int uefopen(void)
{
  HOSTMAP* hmap = &hostmap;
  long uef_filepointer;
  int nreturn;

  hmap->B_serial.uef_chunk = -1;
  hmap->B_serial.uef_chunklen = 0;
  hmap->B_serial.uef_chunkstart = FALSE;
  hmap->B_serial.uef_tone = 0;

  beebit_tapeimage = fopen(beebit_uefimage, "rb");

  nreturn = uefvalidate(beebit_tapeimage);

  if (nreturn)
  {
    uef_filepointer = *(long*)&hmap->B_serial.uef_filepointerarea;
    fread(uef_buffer, 1, 2, beebit_tapeimage);
    hmap->B_serial.uef_version = (getword(uef_buffer) & 0xFFFF);
    fseek(beebit_tapeimage,uef_filepointer,SEEK_SET);
  }
  else
    fclose(beebit_tapeimage);

  return (nreturn);
}

void uefclose(void)
{
  HOSTMAP* hmap = &hostmap;

  if (beebit_tapeimage != NULL)
  {
    *((long*)&hmap->B_serial.uef_filepointerarea) = ftell(beebit_tapeimage);
    fclose(beebit_tapeimage);
  }
}

void uefrewind(void)
{
  HOSTMAP* hmap = &hostmap;

  *((long*)&hmap->B_serial.uef_filepointerarea) = 12;
  if (beebit_tapeimage != NULL)
    fseek(beebit_tapeimage,12,SEEK_SET);
}

void uefread(void)
{
  if (beebit_tapeimage == NULL)
    return;

  HOSTMAP* hmap = &hostmap;

  if (hmap->B_serial.uef_chunk == -1)
  {
    /*no chunk definied*/
    fread(uef_buffer, 1, 2, beebit_tapeimage);
    hmap->B_serial.uef_chunk = (getword(uef_buffer) & 0xFFFF);
    fread(uef_buffer, 1, 4, beebit_tapeimage);
    hmap->B_serial.uef_chunklen = getword(uef_buffer);
    hmap->B_serial.uef_chunkstart = TRUE;
  }

  switch (hmap->B_serial.uef_chunk)
  {
    case 0x00:
      /*origin information chunk*/
      fseek(beebit_tapeimage, hmap->B_serial.uef_chunklen, SEEK_CUR);
      hmap->B_serial.uef_chunk = -1;
      break;
    case 0x01:
      /*game information/manual*/
      fseek(beebit_tapeimage, hmap->B_serial.uef_chunklen, SEEK_CUR);
      hmap->B_serial.uef_chunk = -1;
      break;
    case 0x100:
      /*implicit start/stop bit tape data block*/
      if (hmap->B_serial.uef_chunkstart)
      {
        /*start of chunk*/
        if (hmap->B_serial.uef_chunklen < sizeof(uef_buffer))
          fread(uef_buffer, 1, hmap->B_serial.uef_chunklen, beebit_tapeimage);
        else
          fread(uef_buffer, 1, sizeof(uef_buffer), beebit_tapeimage);
        hmap->B_serial.uef_bufferpointer = 0;

        aciadcdlow();
        hmap->B_serial.uef_chunkstart = FALSE;
      }
      /*fread(&hmap->A_serial.uef_data, 1, 1, beebit_tapeimage);*/
      hmap->A_serial.uef_data = uef_buffer[hmap->B_serial.uef_bufferpointer];

      hmap->B_serial.uef_chunklen--;
      if (hmap->B_serial.uef_chunklen == 0)
        hmap->B_serial.uef_chunk = -1;
      else
      {
        if (hmap->B_serial.uef_bufferpointer == sizeof(uef_buffer)-1)
        {
          if (hmap->B_serial.uef_chunklen < sizeof(uef_buffer))
            fread(uef_buffer, 1, hmap->B_serial.uef_chunklen, beebit_tapeimage);
          else
            fread(uef_buffer, 1, sizeof(uef_buffer), beebit_tapeimage);
          hmap->B_serial.uef_bufferpointer = 0;
        }
        else
          hmap->B_serial.uef_bufferpointer++;
      }

      aciareceive(hmap->A_serial.uef_data);
      break;
    case 0x101:
      /*multiplexed implicit start/stop bit data block*/
      hmap->B_serial.uef_chunk = -1;
      break;
    case 0x110:
      /*high tone*/
      if (hmap->B_serial.uef_tone == 0)
      {
        aciadcdhigh();
        hmap->B_serial.uef_tone = 7; /*8 bits*/
      }
      else
      {
        hmap->B_serial.uef_tone--;
        if (hmap->B_serial.uef_tone == 0)
        {
          /*running length*/
          fseek(beebit_tapeimage, 2, SEEK_CUR);
          hmap->B_serial.uef_chunk = -1;
        }
      }
      break;
    case 0x112:
      /*gap*/
      if (hmap->B_serial.uef_tone == 0)
      {
        aciadcdhigh();
        hmap->B_serial.uef_tone = 7; /*8 bits*/
      }
      else
      {
        hmap->B_serial.uef_tone--;
        if (hmap->B_serial.uef_tone == 0)
        {
          /*running length*/
          fseek(beebit_tapeimage, 2, SEEK_CUR);
          hmap->B_serial.uef_chunk = -1;
        }
      }
      break;
    /*case 0x113:*/
      /*baud rate*/
      /*fread(uef_buffer, 1, 2, beebit_tapeimage);
      hmap->B_serial.uef_baud = (uef_buffer[1] << 8) | uef_buffer[0]*/
      /*break;*/
    default:
      /*printf("bad chunk &%X &%X\n",hmap->B_serial.uef_chunk, hmap->B_serial.uef_chunklen);*/
      fseek(beebit_tapeimage, hmap->B_serial.uef_chunklen, SEEK_CUR);
      hmap->B_serial.uef_chunk = -1;
      break;
  }
}
