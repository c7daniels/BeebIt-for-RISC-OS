/*>6845crtc.c
 *
 * Motorola Cathode Ray Tube Controller [1MHz]
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include "hostmap.h"
#include "6845crtc.h"
#include "beebit.h"
#include "video.h"

/*Motorola 6845 CRTC*/

void crtcreset(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->B_crtc.start_code = 0;
  hmap->B_crtc.row_code = 0;
  hmap->B_crtc.scan_code = 0;
  hmap->B_crtc.cursoraddress = 0;
  hmap->B_crtc.cursorbuffer = 0;
  memset(&hmap->A_crtc,0,sizeof(hmap->A_crtc));
}

HOSTMAP* crtc00read(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = (0); /*m6845_addressreg;*/
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* crtc01read(HOSTMAP* hmap, uintptr_t address_code)
{
  const unsigned int readable = 0x0003F000;

  if ((readable>>hmap->A_crtc.addressreg)&1)
    hmap->m = hmap->A_crtc.r[hmap->A_crtc.addressreg];
  else
    hmap->m = 0;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* crtc00write(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_crtc.addressreg = hmap->m & 0x1F;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

static inline void crtcwriter0(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[0];

  tags = hmap->crtccolumntags[value] & ~CRTCONR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] & ~CRTCBEFORER0COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
    value = (value+1)>>1;
  }
  if (hmap->A_crtc.vs_delayed)
  {
    tags = hmap->crtccolumntags[value] & ~CRTCONHALFR0COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }

  value = hmap->m;
  hmap->A_crtc.r[0] = value;

  tags = hmap->crtccolumntags[value] |= CRTCONR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] |= CRTCBEFORER0COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
    value = (value+1)>>1;
  }
  if (hmap->A_crtc.vs_delayed)
  {
    tags = hmap->crtccolumntags[value] |= CRTCONHALFR0COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }
}

static inline void crtcwriter1(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[1];

  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] & ~CRTCBEFORER1COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }

  value = hmap->m;
  hmap->A_crtc.r[1] = value;

  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] |= CRTCBEFORER1COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }
}

static inline void crtcwriter2(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[2];

  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] & ~CRTCBEFORER2COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }

  value = hmap->m;
  hmap->A_crtc.r[2] = value;

  if (value > 0)
  {
    value--;
    tags = hmap->crtccolumntags[value] |= CRTCBEFORER2COLUMNTAG;
    hmap->crtcstep[value] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[value] = tags;
  }
}

static inline void crtcsignalrowregisterchange(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t column = (uint8_t)(hmap->B_crtc.step_state - hmap->crtcstep);

  tags = hmap->crtccolumntags[column] | CRTCROWTESTCOLUMNTAG;
  hmap->crtcstep[column] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[column] = tags;
}

static inline void crtctagcursorcolumn(HOSTMAP* hmap)
{
  uintptr_t tags;
  intptr_t column = hmap->B_crtc.cursorcolumn;

  if (column > 0)
  {
    column--;
    tags = hmap->crtccolumntags[column] & ~CRTCBEFORECURSORCOLUMNTAG;
    hmap->crtcstep[column] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[column] = tags;
  }

  column = hmap->B_crtc.cursoraddress - (hmap->B_crtc.scan_code>>18);

  if (column > 0 && column <= 256)
  {
    column += (uint8_t)(hmap->B_crtc.step_state - hmap->crtcstep);
    if (column <= 256)
    {
      hmap->B_crtc.cursorcolumn = column;
      column--;
      tags = hmap->crtccolumntags[column] | CRTCBEFORECURSORCOLUMNTAG;
      hmap->crtcstep[column] = hmap->crtctaggedops[tags];
      hmap->crtccolumntags[column] = tags;
    }
    else
      hmap->B_crtc.cursorcolumn = -1;
  }
  else
    hmap->B_crtc.cursorcolumn = -1;
}

HOSTMAP* crtc01write(HOSTMAP* hmap, uintptr_t address_code)
{
  switch (hmap->A_crtc.addressreg)
  {
    case 0:
      /*total of displayed and non-displayed characters,*/
      /*minus 1, per horizontal line in milliseconds*/
      /*frequency of HSYNC is determined by this register*/
      crtcwriter0(hmap);
      break;
    case 1:
      /*number of characters displayed per horizontal line*/
      /*mode 0,1,2,3 = 80 (fast clock)*/
      /*mode 4,5,6,7 = 40 (slow clock)*/
      crtcwriter1(hmap);
      break;
    case 2:
      /*position of the HSYNC on the horizonal line*/
      /*in terms of the character location number on the line*/
      /*determines the left-to-right location of the displayed text*/
      crtcwriter2(hmap);
      break;
    case 3:
      /*width of HSYNC = b0-b3*/
      /*width of VSYNC = b4-b7*/
      hmap->A_crtc.r[3] = hmap->m;
      break;
    case 4:
      /*total vertical size of the screen in rows minus 1*/
      hmap->A_crtc.r[4] = (hmap->m & 0x7F);
      break;
    case 5:
      /*total vertical adjust in lines*/
      hmap->A_crtc.r[5] = (hmap->m & 0x1F);
      break;
    case 6:
      /*displayed vertical size of the screen in rows*/
      hmap->A_crtc.r[6] = (hmap->m & 0x7F);
      crtcsignalrowregisterchange(hmap);
      break;
    case 7:
      /*position of VSYNC*/
      hmap->A_crtc.r[7] = (hmap->m & 0x7F);
      crtcsignalrowregisterchange(hmap);
      break;
    case 8:
      /*interlace mode and skew*/
      /*b1+b0*/
      /* 0  0=normal sync mode (non-interlace)*/
      /* 1  0=normal sync mode (non-interlace)*/
      /* 0  1=interlace sync mode*/
      /* 1  1=interlace sync and video mode*/
      /*b5+b4 (display skew)*/
      /* 0  0=No delay*/
      /* 0  1=One character delay*/
      /* 1  0=Two character delay*/
      /* 1  1=Disable video output*/
      /*b7+b6 (cursor skew)*/
      /* 0  0=No delay*/
      /* 0  1=One character delay*/
      /* 1  0=Two character delay*/
      /* 1  1=Disable cursor output*/
      if (hmap->m&1)
      {
        if (!(hmap->A_crtc.r[8] & 1))
          hmap->A_crtc.fieldnumber = 0;
        hmap->A_crtc.delayvs = 1;
      }
      else
        hmap->A_crtc.delayvs = 0;

      hmap->A_crtc.r[8] = hmap->m;
      hmap->A_crtc.r9image = (hmap->m & 3) == 3 ? ((hmap->A_crtc.r[9]+1) & 0x1F) : (hmap->A_crtc.r[9] & 0x1F);
      hmap->B_vidbuf.setskewop(hmap, hmap->m);
      break;
    case 9:
      /*number of scan lines per character row*/
      hmap->A_crtc.r[9] = (hmap->m & 0x1F);

      hmap->A_crtc.r9image = (hmap->A_crtc.r[8] & 3) == 3 ? ((hmap->m+1) & 0x1F) : (hmap->m & 0x1F);
      break;
    case 10:
      /*bit 6 enables cursor blinking*/
      /*bit 5 =0 blink every 16 v blanks*/
      /*      =1 blink every 32 v blanks*/
      /*bits 4-0 = cursor start line*/
      hmap->A_crtc.r[10] = (hmap->m & 0x7F);
      break;
    case 11:
      /*cursor end*/
      hmap->A_crtc.r[11] = (hmap->m & 0x1F);
      break;
    case 12:
      /*screen start address hi (b0-b5)*/
      hmap->A_crtc.r[12] = (hmap->m & 0x3F);
      hmap->B_crtc.start_code = ((hmap->m<<26)&0xFC000000) | (hmap->B_crtc.start_code&0x03FC0000);
      break;
    case 13:
      /*screen start address lo*/
      hmap->A_crtc.r[13] = hmap->m;
      hmap->B_crtc.start_code = (hmap->B_crtc.start_code&0xFC000000) | (hmap->m<<18);
      break;
    case 14:
      /*cursor address hi (b0-b5)*/
      hmap->A_crtc.r[14] = (hmap->m & 0x3F);
      hmap->B_crtc.cursoraddress = ((hmap->m<<8)&0x3F00) | (hmap->B_crtc.cursoraddress&0xFF);
      crtctagcursorcolumn(hmap);
      break;
    case 15:
      /*cursor address lo*/
      hmap->A_crtc.r[15] = hmap->m;
      hmap->B_crtc.cursoraddress = (hmap->B_crtc.cursoraddress&0x3F00) | hmap->m;
      crtctagcursorcolumn(hmap);
      break;
    default:
      /*cannot write R16-R17*/
      break;
  }
  R6502_JUMP_FROM_HIGH_OP(hmap)
}
