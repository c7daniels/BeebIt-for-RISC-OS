/*>6522usrvia.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Rockwell 6522 Versatile Interface Adapter (VIA) [1MHz]
 *
 * (C) Copyright Michael J Foot, 1998-2002
 *
 * Email: <mjfoot.nz@gmail.com>
 */

/* 0xffff * 2 = 0x1fffe +2 = 0x20000 */

/*ACR bits*/
/*b7 = output enable*/
/*b6 = free-run enable*/
/*b5 = timer 2 control (0=timed interrupt,1=countdown with pulses)*/
/*b1 = PB latching enabled*/
/*b0 = PA latching enabled*/

#include <stddef.h>
#include "beebit.h"
#include "host.h"
#include "6522usrvia.h"
#include "main.h"
#include "keyboard.h"
#include "riscos.h"
#ifdef __RISCOS__
#include "kernel.h"
#include "swis.h"
#endif

/*User VIA*/

#ifdef __RISCOS__
extern _kernel_swi_regs regs;
#endif

void userviaamxmouse(void)
{
  HOSTMAP* hmap = &hostmap;

  if ((hmap->A_usrvia.ifr & 0x18) == 0)
  {
    if ((hmap->amx.targetx != hmap->amx.currentx) || (hmap->amx.targety != hmap->amx.currenty))
    {
      if (hmap->amx.targetx != hmap->amx.currentx)
      {
        hmap->A_usrvia.ifr |= 0x10;
        if (hmap->amx.targetx < hmap->amx.currentx)
        {
          hmap->A_usrvia.irb &= ~0x01;
          hmap->A_usrvia.portb &= ~0x01;
          hmap->amx.currentx--;
        }
        else
        {
          hmap->A_usrvia.irb |= 0x01;
          hmap->A_usrvia.portb |= 0x01;
          hmap->amx.currentx++;
        }
      }

      if (hmap->amx.targety != hmap->amx.currenty)
      {
        hmap->A_usrvia.ifr |= 0x08;
        if (hmap->amx.targety > hmap->amx.currenty)
        {
          hmap->A_usrvia.irb |= 0x04;
          hmap->A_usrvia.portb |= 0x04;
          hmap->amx.currenty++;
        }
        else
        {
          hmap->A_usrvia.irb &= ~0x04;
          hmap->A_usrvia.portb &= ~0x04;
          hmap->amx.currenty--;
        }
      }
    }
  }
}

void userviaeventsetirq(HOSTMAP* hmap)
{
  if (hmap->A_usrvia.ifr & hmap->A_usrvia.ier & 0x7F)
  {
    hmap->A_usrvia.ifr |= 0x80;
    HOST_SETSHIFTEDIRQ(hmap, HOST_IRQ_6522USRVIA)
  }
  else
  {
    hmap->A_usrvia.ifr &= 0x7F;
    HOST_CLEARSHIFTEDIRQ(hmap, HOST_IRQ_6522USRVIA)
  }
}

void userviaregistersetirq(HOSTMAP* hmap)
{
  if (hmap->A_usrvia.ifr & hmap->A_usrvia.ier & 0x7F)
  {
    hmap->A_usrvia.ifr |= 0x80;
    HOST_SETIRQ(hmap, HOST_IRQ_6522USRVIA)
  }
  else
  {
    hmap->A_usrvia.ifr &= 0x7F;
    HOST_CLEARIRQ(hmap, HOST_IRQ_6522USRVIA)
  }
}

static intptr_t userviapickcyclestogo(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t cyclestogo;

  // the interrupt flag is set after the counter has passed through zero
  if (!(hmap->A_usrvia.acr & 0x20))
  {
    if (hmap->B_usrvia.t1doubled < hmap->B_usrvia.t2doubled)
    {
      cyclestogo = hmap->B_usrvia.t1doubled + 2;
    }
    else
    {
      cyclestogo = hmap->B_usrvia.t2doubled + 2;
    }
  }
  else
  {
    cyclestogo = hmap->B_usrvia.t1doubled + 2;
  }

  if (hmap->amx.timer > 0 && hmap->amx.timer < cyclestogo)
  {
    cyclestogo = hmap->amx.timer;
  }

  if (hmap->A_usrvia.aftert1)
  {
    cyclestogo = 1;
  }

  return cyclestogo;
}

void userviastartreset(int lfull)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;

  if (lfull)
  {
    hmap->B_usrvia.t1doubled = 0;
    hmap->B_usrvia.t2doubled = 0;
    hmap->A_usrvia.sr = 0;
  }
  else
  {
    HOST_GET_PERIPHERAL_CYCLE_COUNT(expiryoffset, hmap, usrvia)

    hmap->B_usrvia.t1doubled -= expiryoffset;

    if (!(hmap->A_usrvia.acr & 0x20))
    {
      hmap->B_usrvia.t2doubled -= expiryoffset;
    }
  }

  hmap->A_usrvia.ier = 0x80;
  hmap->A_usrvia.ifr = 0x00;
  hmap->A_usrvia.ddra = 0; /*input*/
  hmap->A_usrvia.ddrb = 0; /*input*/
  hmap->A_usrvia.t1ll = 0xFF;
  hmap->A_usrvia.t1lh = 0xFF;
  hmap->A_usrvia.t2ll = 0xFF;
  hmap->A_usrvia.acr = 0;
  hmap->A_usrvia.pcr = 0;
  hmap->A_usrvia.ora = 0xFF;
  hmap->A_usrvia.ira = 0xFF;
  hmap->A_usrvia.orb = 0xFF;
  hmap->A_usrvia.irb = 0xFF;
  hmap->A_usrvia.porta = 0xFF;
  hmap->A_usrvia.portb = 0xFF;

  hmap->A_usrvia.aftert1 = FALSE;
  hmap->A_usrvia.t1setint = FALSE;
  hmap->A_usrvia.t2setint = FALSE;
  userviaregistersetirq(hmap);
  hmap->amx.timer = 0;
  hmap->amx.buttons = 0;

  hmap->cycles.usrvia_original = 0;
  hmap->cycles.usrvia_togo = 0;
}

void userviafinishreset(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, usrvia)

  hmap->B_usrvia.t1doubled += expiryoffset;
  hmap->B_usrvia.t2doubled += expiryoffset;

  hmap->cycles.usrvia_togo = userviapickcyclestogo();
  hmap->cycles.usrvia_original = hmap->cycles.usrvia_togo;

  HOST_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.usrvia_togo)
}

void userviabeforesnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, usrvia)

  hmap->B_usrvia.t1doubled -= expiryoffset;
  if (!(hmap->A_usrvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_usrvia.t2doubled -= expiryoffset;
  }

  userviaregistersetirq(hmap);
}

void userviaaftersnapshot(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t expiryoffset;
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(expiryoffset, hmap, usrvia)

  hmap->B_usrvia.t1doubled += expiryoffset;
  HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->B_usrvia.t1doubled + 2)
  if (!(hmap->A_usrvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_usrvia.t2doubled += expiryoffset;
    HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->B_usrvia.t2doubled + 2)
  }
}

HOSTMAP* userviaatzerocycles(HOSTMAP* hmap)
{
  /*we are dealing with a 1MHz device here*/
  hmap->B_usrvia.t1doubled -= hmap->cycles.usrvia_original;

  if (hmap->B_usrvia.t1doubled == -2)
  {
    switch (hmap->A_usrvia.acr & 0xC0)
    {
      case 0x00:
        /*output disabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        /*ELITE uses this one*/
        if (hmap->A_usrvia.t1setint)
        {
          /*T1 interrupt flag set*/
          hmap->A_usrvia.ifr |= 0x40;
          hmap->A_usrvia.t1setint = FALSE;
        }
        break;
      case 0x40:
        /*output disabled and free-run mode*/
        /*continuous interrupts*/
        /*REVS, SKIRMISH AND RIG ATTACK USE THIS ONE!*/
         if (hmap->A_usrvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_usrvia.ifr |= 0x40;
        break;
      case 0x80:
        /*output enabled and one-shot mode*/
        /*timed interrupt each time T1 is loaded*/
        if (hmap->A_usrvia.t1setint)
        {
          /*PB7 goes high*/
          hmap->A_usrvia.portb |= 0x80;
          /*T1 interrupt flag set*/
          hmap->A_usrvia.ifr |= 0x40;
          hmap->A_usrvia.t1setint = FALSE;
        }
        break;
      case 0xC0:
        /*output enabled and free-run mode*/
        /*continuous interrupts*/
        hmap->A_usrvia.portb ^= 0x80;
        if (hmap->A_usrvia.t1setint)
          /*T1 interrupt flag set*/
          hmap->A_usrvia.ifr |= 0x40;
        break;
    }

    hmap->B_usrvia.t1doubled += 0x20000;
    hmap->A_usrvia.aftert1 = TRUE;
  }
  else if (hmap->A_usrvia.aftert1)
  {
    if (hmap->A_usrvia.acr & 0x40)
    {
      hmap->B_usrvia.t1doubled = ((hmap->A_usrvia.t1lh<<9) | (hmap->A_usrvia.t1ll<<1)) + 1;
    }
    hmap->A_usrvia.aftert1 = 0;
  }

  if (!(hmap->A_usrvia.acr & 0x20))
  {
    hmap->B_usrvia.t2doubled -= hmap->cycles.usrvia_original;

    if (hmap->B_usrvia.t2doubled == -2)
    {
      if (hmap->A_usrvia.t2setint)
      {
        /*on completion of the timing interval,
          T2 interrupt flag is set (IFR b5)*/
        hmap->A_usrvia.ifr |= 0x20;
        hmap->A_usrvia.t2setint=FALSE;
      }

      hmap->B_usrvia.t2doubled += 0x20000;
    }
  }

  if (hmap->amx.timer > 0)
  {
    hmap->amx.timer -= hmap->cycles.usrvia_original;

    if (hmap->amx.timer == 0)
    {
      if (beebit_mouseemulation == MOUSE_AMXMOUSE)
        userviaamxmouse();
    }
  }

  hmap->cycles.usrvia_togo = hmap->cycles.usrvia_original = userviapickcyclestogo();

  userviaeventsetirq(hmap);
  return hmap;
}

struct R6502CPUMAP* uservia00read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;
  unsigned int nresult;

  /*PCR & 0x20 = CB2 input*/
  /*PCR & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_usrvia.pcr & 0xE0) == 0x20) OR ((hmap->A_usrvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_usrvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_usrvia.ifr &= 0xE7;
  }
  /*userviaregistersetirq(hmap);*/
  /*reads output register bit in orb. pin level has no effect*/
  nresult = (hmap->A_usrvia.orb & hmap->A_usrvia.ddrb);

  if (hmap->A_usrvia.acr & 0x02)
  {
    /*input latching enabled*/
    /*read input level on irb*/
    nresult |= (hmap->A_usrvia.irb & ~hmap->A_usrvia.ddrb);
  }
  else
  {
    /*input latching disabled*/
    /*read input level on PB pin*/
    nresult |= (hmap->A_usrvia.portb & ~hmap->A_usrvia.ddrb);
  }

  if (beebit_mouseemulation == MOUSE_AMXMOUSE)
  {
    /*AMX mouse stuff*/
#ifdef __RISCOS__
    _kernel_swi(OS_Mouse,&regs,&regs);
    hmap->amx.targetx = regs.r[0];
    hmap->amx.targety = regs.r[1];
    hmap->amx.buttons = ((regs.r[2] & 0x04) >> 2);
    hmap->amx.buttons |= (regs.r[2] & 0x02);
    hmap->amx.buttons |= ((regs.r[2] & 0x01) << 2);
#endif

    nresult &= 0x1F;
    nresult |= (hmap->amx.buttons ^ 7) << 5;
    hmap->A_usrvia.ifr &= 0xE7;

    userviaregistersetirq(hmap);

    if ((hmap->amx.targetx != hmap->amx.currentx) OR (hmap->amx.targety != hmap->amx.currenty))
    {
      /*set trigger*/
      HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, usrvia)
      hmap->amx.timer = (500<<1) + expiryoffset;
      HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->amx.timer)
    }
    else
    {
      /*clear trigger*/
      hmap->amx.timer = 0;
    }
  }
  hmap->m = nresult;

  return cmap;
}

struct R6502CPUMAP* uservia01read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*hmap->A_usrvia.pcr & 0x02 = CA2 input*/
  /*hmap->A_usrvia.pcr & 0x04 = CA2 active edge input*/
  /*independant mode*/
  if (((hmap->A_usrvia.pcr & 0x0E) == 0x02) OR ((hmap->A_usrvia.pcr & 0x0E) == 0x06))
  {
    /*independant interrupt*/
    /*clear b2 (CA1)*/
    hmap->A_usrvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_usrvia.ifr &= 0xFC;
  }
  userviaregistersetirq(hmap);
  if (hmap->A_usrvia.acr & 0x01)
  {
    /*input latching enabled*/
    hmap->m = hmap->A_usrvia.ira;
  }
  else
  {
    /*input latching disabled*/
    hmap->m = hmap->A_usrvia.porta;
  }

  return cmap;
}

struct R6502CPUMAP* uservia02read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.ddrb;

  return cmap;
}

struct R6502CPUMAP* uservia03read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.ddra;

  return cmap;
}

struct R6502CPUMAP* uservia04read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 low order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  /*T1 interrupt flag is cleared (IFR b6)*/
  hmap->A_usrvia.ifr &= 0xBF;
  userviaregistersetirq(hmap);
  HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, usrvia)
  hmap->m = ((hmap->B_usrvia.t1doubled - cyclecount)>>1)&0xFF;

  return cmap;
}

struct R6502CPUMAP* uservia05read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, usrvia)
  hmap->m = ((hmap->B_usrvia.t1doubled - cyclecount)>>9)&0xFF;

  return cmap;
}

struct R6502CPUMAP* uservia06read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.t1ll;

  return cmap;
}

struct R6502CPUMAP* uservia07read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T1 high order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.t1lh;

  return cmap;
}

struct R6502CPUMAP* uservia08read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T2 low order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  /*T2 interrupt flag is cleared (IFR b5)*/
  hmap->A_usrvia.ifr &= 0xDF;
  userviaregistersetirq(hmap);
  if (!(hmap->A_usrvia.acr & 0x20))
  {
    HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, usrvia)
    hmap->m = ((hmap->B_usrvia.t2doubled - cyclecount)>>1)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_usrvia.t2doubled>>1)&0xFF;
  }

  return cmap;
}

struct R6502CPUMAP* uservia09read(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*T2 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t cyclecount;

  if (!(hmap->A_usrvia.acr & 0x20))
  {
    HOST_GET_PERIPHERAL_CYCLE_COUNT(cyclecount, hmap, usrvia)
    hmap->m = ((hmap->B_usrvia.t2doubled - cyclecount)>>9)&0xFF;
  }
  else
  {
    hmap->m = (hmap->B_usrvia.t2doubled>>9)&0xFF;
  }

  return cmap;
}

struct R6502CPUMAP* uservia0Aread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*shift register*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*SR interrupt flag is cleared (IFR b2)*/
  hmap->A_usrvia.ifr &= 0xFB;
  userviaregistersetirq(hmap);
  hmap->m = hmap->A_usrvia.sr;

  return cmap;
}

struct R6502CPUMAP* uservia0Bread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*auxilary control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.acr;

  return cmap;
}

struct R6502CPUMAP* uservia0Cread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*peripheral control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = hmap->A_usrvia.pcr;

  return cmap;
}

struct R6502CPUMAP* uservia0Dread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*interrupt flag reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*b7 of this register will be read as a logic 1*/
  /*when an interrupt exists within the chip*/
  userviaregistersetirq(hmap);
  hmap->m = hmap->A_usrvia.ifr;

  return cmap;
}

struct R6502CPUMAP* uservia0Eread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*interrupt enable reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->m = (hmap->A_usrvia.ier | 0x80);

  return cmap;
}

struct R6502CPUMAP* uservia0Fread(struct R6502CPUMAP* cmap, uintptr_t address_code)
{
  /*output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  if (hmap->A_usrvia.acr & 0x01)
  {
    /*latching enabled*/
    hmap->m = hmap->A_usrvia.ira;
  }
  else
  {
    /*latching disabled*/
    hmap->m = hmap->A_usrvia.porta;
  }

  return cmap;
}

struct R6502CPUMAP* uservia00write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg b*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.orb = value;
  hmap->A_usrvia.portb = (hmap->A_usrvia.orb & hmap->A_usrvia.ddrb) | (hmap->A_usrvia.portb & ~hmap->A_usrvia.ddrb);
  /*PCR & 0x20 = CB2 input*/
  /*PCR & 0x40 = CB2 active edge input*/
  /*independant mode*/
  if (((hmap->A_usrvia.pcr & 0xE0) == 0x20) OR ((hmap->A_usrvia.pcr & 0xE0) == 0x60))
  {
    /*clear b4 (CB1)*/
    hmap->A_usrvia.ifr &= 0xEF;
  }
  else
  {
    /*clear b4,b3 (CB1,CB2)*/
    hmap->A_usrvia.ifr &= 0xE7;
  }
  userviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* uservia01write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*input/output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  /*VDU 21 writes &0D (%1101) only*/
  /*VDU 2 writes &OD then character*/
  hmap->A_usrvia.ora = value;
  hmap->A_usrvia.porta = (hmap->A_usrvia.ora & hmap->A_usrvia.ddra) | (hmap->A_usrvia.porta & ~hmap->A_usrvia.ddra);
  /*PCR & 0x02 = CA2 input*/
  /*PCR & 0x04 = CA2 active edge input*/
  if (((hmap->A_usrvia.pcr & 0x0E) == 0x02) OR ((hmap->A_usrvia.pcr & 0x0E) == 0x06))
  {
    /*clear b2 (CA1)*/
    hmap->A_usrvia.ifr &= 0xFD;
  }
  else
  {
    /*clear b2,b1 (CA1,CA2)*/
    hmap->A_usrvia.ifr &= 0xFC;
  }
#ifdef __RISCOS__
  if (beebit_printer)
  {
    regs.r[0] = hmap->A_usrvia.porta;
    _kernel_swi(OS_PrintChar,&regs,&regs);
  }
#endif
  /*clear b2 (CA1)*/
  hmap->A_usrvia.ifr |= 0x02; /*CA1*/
  userviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* uservia02write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.ddrb = value;

  return cmap;
}

struct R6502CPUMAP* uservia03write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.ddra = value;

  return cmap;
}

struct R6502CPUMAP* uservia04write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.t1ll = value;

  return cmap;
}

struct R6502CPUMAP* uservia05write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  hmap->A_usrvia.t1lh = value;
  /*clear T1 interrupt flag (b6)*/
  hmap->A_usrvia.ifr &= 0xBF;
  userviaregistersetirq(hmap);
  if ((hmap->A_usrvia.acr & 0xC0) == 0x80)
  {
    /*output enabled (b7=1) and free-run disabled (b6=0)*/
    /*one-shot mode*/
    /*PB7 goes low, but goes high when timer 1 times out*/
    /*hmap->A_usrvia.orb &= 0x7F;
    hmap->A_usrvia.irb &= 0x7F;*/
    hmap->A_usrvia.portb &= 0x7F;
  }
  hmap->A_usrvia.t1setint = TRUE;
  hmap->B_usrvia.t1doubled = (hmap->A_usrvia.t1lh<<9) | (hmap->A_usrvia.t1ll<<1);
  HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, usrvia)
  hmap->B_usrvia.t1doubled += expiryoffset;
  // the interrupt flag is set after the counter has passed through zero
  HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->B_usrvia.t1doubled + 2)
  hmap->A_usrvia.aftert1 = 0;

  return cmap;
}

struct R6502CPUMAP* uservia06write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.t1ll = value;

  return cmap;
}

struct R6502CPUMAP* uservia07write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T1 high order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.t1lh = value;

  return cmap;
}

struct R6502CPUMAP* uservia08write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T2 low order latch*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.t2ll = value;

  return cmap;
}

struct R6502CPUMAP* uservia09write(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*T2 high order counter*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  /*clear T2 interrupt flag (bit 5)*/
  hmap->A_usrvia.ifr &= 0xDF;
  userviaregistersetirq(hmap);
  /*provide a single interrupt*/
  hmap->A_usrvia.t2setint = TRUE;
  if (!(hmap->A_usrvia.acr & 0x20))
  {
    /*one-shot mode*/
    hmap->B_usrvia.t2doubled = (value<<9) | (hmap->A_usrvia.t2ll<<1);
    HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, usrvia)
    hmap->B_usrvia.t2doubled += expiryoffset;
    // the interrupt flag is set after the counter has passed through zero
    HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->B_usrvia.t2doubled + 2)
  }
  else
  {
    /*pulse counting mode*/
    hmap->B_usrvia.t2doubled = (value<<9) | (hmap->A_usrvia.t2ll<<1);
  }

  return cmap;
}

struct R6502CPUMAP* uservia0Awrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*shift reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.sr = value;
  hmap->A_usrvia.ifr &= 0xFB;
  userviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* uservia0Bwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*auxiliary control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  intptr_t expiryoffset;

  if ((hmap->A_usrvia.acr ^ value) & 0x20)
  {
    HOST_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(expiryoffset, hmap, usrvia)
    if (!(value & 0x20))
    {
      /*one-shot mode*/
      hmap->B_usrvia.t2doubled += expiryoffset;
      HOST_LIMIT_PERIPHERAL_CYCLES_TO_GO(hmap, usrvia, hmap->B_usrvia.t2doubled + 2)
    }
    else
    {
      /*pulse counting mode*/
      hmap->B_usrvia.t2doubled -= expiryoffset;
    }
  }
  hmap->A_usrvia.acr = value;

  return cmap;
}

struct R6502CPUMAP* uservia0Cwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*peripheral control reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.pcr = value;
  /*CA1 active edge*/
  if (hmap->A_usrvia.pcr & 0x01)
  {
    /*set b2 (CA1)*/
    hmap->A_usrvia.ifr |= 0x02;
  }
  /*CA2 active edge*/
  if ((hmap->A_usrvia.pcr & 0x0E) == 0x04)
  {
    /*set b1 (CA2)*/
    hmap->A_usrvia.ifr |= 0x01;
  }
  /*CB1 active edge*/
  if (hmap->A_usrvia.pcr & 0x10)
  {
    /*set b5 (CB1)*/
    hmap->A_usrvia.ifr |= 0x10;
  }
  /*CB2 active edge*/
  if ((hmap->A_usrvia.pcr & 0xE0) == 0x40)
  {
    /*set b4 (CB2)*/
    hmap->A_usrvia.ifr |= 0x08;
  }

  return cmap;
}

struct R6502CPUMAP* uservia0Dwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*interrupt flag reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  value &= 0x7F; /*not really needed*/
  hmap->A_usrvia.ifr &= (~value);
  userviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* uservia0Ewrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*interrupt enable reg*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  if (value & 0x80)
    hmap->A_usrvia.ier |= value;
  else
    hmap->A_usrvia.ier &= (~value);
  hmap->A_usrvia.ier &= 0x7F;
  userviaregistersetirq(hmap);

  return cmap;
}

struct R6502CPUMAP* uservia0Fwrite(struct R6502CPUMAP* cmap, uintptr_t address_code, uint8_t value)
{
  /*output reg a*/
  HOSTMAP* hmap = (HOSTMAP*)cmap;
  hmap->A_usrvia.ora = value;
  hmap->A_usrvia.porta = (hmap->A_usrvia.ora & hmap->A_usrvia.ddra) +(hmap->A_usrvia.porta & ~hmap->A_usrvia.ddra);

  return cmap;
}
