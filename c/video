/*>video.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Cycle-level video emulation
 *
 * (C) Copyright Crispian Daniels, 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <assert.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include "hostmap.h"
#include "beebit.h"
#include "kernel.h"
#include "main.h"
#include "riscos.h"
#include "swis.h"
#include "6502cmap.h"
#include "6502cpu.h"
#include "6522sysvia.h"
#include "6845crtc.h"
#include "video.h"
#include "videoscale.h"
#include "videoula.h"

#ifndef ColourTrans_ReturnColourNumber
#define ColourTrans_ReturnColourNumber 0x040744
#endif
#ifndef ColourTrans_WritePalette
#define ColourTrans_WritePalette 0x04075D
#endif

extern _kernel_swi_regs regs;

#define TIME_25HZ 4 /*CLK_TCK/25*/ /*25 times per second*/
#define TIME_50HZ 2 /*CLK_TCK/50*/ /*50 times per second*/

#define PROGRESSIVECLIPPEDSKIPFLAGS (CLIPPEDBELOWSKIPFLAG|CLIPPEDSKIPFLAG|CLIPPEDABOVESKIPFLAG)
#define TIMINGSKIPFLAGS (FRAMETIMESKIPFLAG|VSYNCSKIPFLAG|HSYNCSKIPFLAG|BEFOREDISPLAYSKIPFLAG|FASTSKIPFLAG)

#define ENDFRAMEIDLE 0
#define ENDFRAMESOON 1
#define ENDFRAMENOADJUST 2
#define ENDFRAMEADJUST 3
#define ENDFRAMEADJUSTING 4
#define ENDFRAMEADJUSTCOMPLETE 5
#define ENDFRAMEDUMMY 6

HOSTMAP* videoendframeidle(HOSTMAP* hmap);
HOSTMAP* videoendframesoon(HOSTMAP* hmap);
HOSTMAP* videoendframenoadjust(HOSTMAP* hmap);
HOSTMAP* videoendframeadjust(HOSTMAP* hmap);
HOSTMAP* videoendframeadjusting(HOSTMAP* hmap);
HOSTMAP* videoendframeadjustcomplete(HOSTMAP* hmap);
HOSTMAP* videoendframedummy(HOSTMAP* hmap);

HOSTMAP* videoslowenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipslowenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoslowleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddleslowleavingvsync(HOSTMAP* hmap);
HOSTMAP* videofastenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipfastenteringvsync(HOSTMAP* hmap);
HOSTMAP* videofastleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddlefastleavingvsync(HOSTMAP* hmap);
HOSTMAP* videoprogressiveenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipprogressiveenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoprogressiveleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddleprogressiveleavingvsync(HOSTMAP* hmap);

R6502ZONEMAP* videodisplaysyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplaypossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplaypsyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayppossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code);

R6502ZONEMAP* videodisplayoutleft(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayoutright(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayslowstop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayfaststop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayprogressivestop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);

HOSTMAP* videoupdateTMstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTR0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateMstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateR0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdatestep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoidlestep(HOSTMAP* hmap, uintptr_t incremented_step_state);

HOSTMAP* videoreadevent(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadlinetest(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadcursorsignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadpcursorsignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreaddisplaysignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoinactivesetskew(HOSTMAP* hmap, uint8_t r8);
HOSTMAP* videosetskew(HOSTMAP* hmap, uint8_t r8);
HOSTMAP* videoprogressivesetskew(HOSTMAP* hmap, uint8_t r8);

HOSTMAP* teletextnoponeslice(HOSTMAP* hmap);
HOSTMAP* teletextnoprounding(HOSTMAP* hmap);
HOSTMAP* teletextendofline(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline00(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline01(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline02(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline03(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline04(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline05(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline06(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline08(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline0D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline11(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline12(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline13(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline14(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline15(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline16(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline17(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline18(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline1A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline1D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline1E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline20(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline21(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline22(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline23(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline24(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline25(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline26(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline27(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline28(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline29(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline2F(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline30(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline31(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline32(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline33(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline34(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline35(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline36(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline37(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline38(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline39(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline3F(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline40(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline41(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline42(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline43(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline44(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline45(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline46(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline47(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline48(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline49(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline4F(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline50(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline51(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline52(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline53(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline54(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline55(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline56(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline57(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline58(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline59(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline5F(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline60(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline61(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline62(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline63(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline64(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline65(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline66(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline67(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline68(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline69(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline6F(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline70(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline71(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline72(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline73(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline74(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline75(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline76(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline77(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline78(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline79(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7A(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7B(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7C(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7D(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7E(HOSTMAP* hmap);
HOSTMAP* teletextcodestartofline7F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline00(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline01(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline02(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline03(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline04(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline05(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline06(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline07(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline08(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline09(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline0C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline0D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline11(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline12(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline13(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline14(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline15(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline16(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline17(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline18(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline19(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline1A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline1C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline1D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline1E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline1F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline20(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline21(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline22(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline23(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline24(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline25(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline26(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline27(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline28(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline29(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline2F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline30(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline31(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline32(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline33(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline34(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline35(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline36(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline37(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline38(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline39(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline3F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline40(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline41(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline42(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline43(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline44(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline45(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline46(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline47(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline48(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline49(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline4F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline50(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline51(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline52(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline53(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline54(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline55(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline56(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline57(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline58(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline59(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline5F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline60(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline61(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline62(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline63(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline64(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline65(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline66(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline67(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline68(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline69(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline6F(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline70(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline71(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline72(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline73(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline74(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline75(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline76(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline77(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline78(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline79(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7A(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7B(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7C(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7D(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7E(HOSTMAP* hmap);
HOSTMAP* teletextcodemidline7F(HOSTMAP* hmap);

/*palette*/
const unsigned int palette_rgb[8] =
{
  0x00000000, /*black*/
  0x0000FF00, /*red*/
  0x00FF0000, /*green*/
  0x00FFFF00, /*yellow*/
  0xFF000000, /*blue*/
  0xFF00FF00, /*magenta*/
  0xFFFF0000, /*cyan*/
  0xFFFFFF00  /*white*/
};
unsigned int palette_specified[8];

int videoupdate_videospeed;
int videoupdate_framerate;

clock_t nclock;

int video_screenstartoffset;
int video_screenstartline;

unsigned char teletextlinemap[192*10];
int nteletextlinepatterns;
const int *teletextlinepatterns;

void* video_workspace = NULL;

void videoinit(void)
{
  HOSTMAP* hmap = &hostmap;
  const int maxhashvalue = 31;
  const int log2collisionallowance = 4;
  const int collisionallowance = 1<<log2collisionallowance;
  const int initialnumberallocation = (1+maxhashvalue)<<log2collisionallowance;
  const int expansionoffset = 8;

  FILE *hfile;
  int i,j,k;
  int updots,dots,downdots,dots8,downdots8;
  int leftxor,rightxor,upxor,downxor;
  int significantupdots,significantdowndots;
  int hashvalue,pattern;
  int startnumber,stopnumber,number;
  unsigned char widedots[8];
  int * const patterns = calloc(2 * initialnumberallocation + 384*10, sizeof(int));
  int * const renumbering = &patterns[initialnumberallocation];
  int * const linenumbers = &patterns[2 * initialnumberallocation];
  int *nextlinenumber = linenumbers;
  int *stoplinenumber;
  unsigned char *nextlineinmap = teletextlinemap;

  hfile = NULL;
  for (k=0; k<2; k++)
  {
    switch (k)
    {
      case 0:
        hfile = fopen("<BeebIt$Dir>.Resources.MODE7A","rb");
        fseek(hfile, 128*10*8, SEEK_CUR);
        break;
      case 1:
        fclose(hfile);

        hfile = fopen("<BeebIt$Dir>.Resources.MODE7G","rb");
        fseek(hfile, 128*10*8, SEEK_CUR);
        break;
    }

    for (j=0; j<96; j++)
    {
      dots = 0;

      fread(widedots, 1, 8, hfile);
      downdots = (widedots[6] & 0x10) | (widedots[5] & 0x08) |
          (widedots[4] & 0x04) | (widedots[3] & 0x02) | (widedots[2] & 0x01);
      downdots8 = (widedots[7] & 0x80) | (widedots[6] & 0x40) | (widedots[5] & 0x20) |
        (widedots[4] & 0x10) | (widedots[3] & 0x08) | (widedots[2] & 0x04) |
        (widedots[1] & 0x02) | (widedots[0] & 0x01);

      for (i=0; i<10; i++)
      {
        updots = dots;
        dots = downdots;
        dots8 = downdots8;

        if (i<9)
        {
          fread(widedots, 1, 8, hfile);
          downdots = (widedots[6] & 0x10) | (widedots[5] & 0x08) |
              (widedots[4] & 0x04) | (widedots[3] & 0x02) | (widedots[2] & 0x01);
          downdots8 = (widedots[7] & 0x80) | (widedots[6] & 0x40) | (widedots[5] & 0x20) |
              (widedots[4] & 0x10) | (widedots[3] & 0x08) | (widedots[2] & 0x04) |
              (widedots[1] & 0x02) | (widedots[0] & 0x01);
        }
        else
        {
          downdots = 0;
        }

        if (((dots8 & 0xF0) == 0xF0 || (dots8 & 0xF0) == 0x00) &&
            ((dots8 & 0x0F) == 0x0F || (dots8 & 0x0F) == 0x00))
        {
          *nextlinenumber = ((dots8>>3)&3)-expansionoffset;
        }
        else
        {
          leftxor = dots ^ (dots<<1);
          rightxor = dots ^ (dots>>1);
          upxor = updots ^ dots;
          downxor = downdots ^ dots;

          significantdowndots = downdots & ((rightxor & (downxor>>1)) | (leftxor & (downxor<<1)));
          significantupdots = updots & ((rightxor & (upxor>>1)) | (leftxor & (upxor<<1)));

          pattern = (significantdowndots << 10) | (dots << 5) | significantupdots;

          hashvalue = dots;
          hashvalue ^= (significantupdots>>3) | ((significantupdots & 0x07)<<2);
          hashvalue ^= (significantdowndots>>2) | ((significantdowndots & 0x03)<<3);

          startnumber = hashvalue << log2collisionallowance;
          stopnumber = startnumber + collisionallowance;

          for (number = startnumber; number < stopnumber; number++)
          {
            if (patterns[number] == pattern)
                break;

            if (patterns[number] == 0)
            {
              patterns[number] = pattern;
              break;
            }
          }

          *nextlinenumber = number == stopnumber ? startnumber : number;
        }

        nextlinenumber++;
      }
    }
  }

  fclose(hfile);

  stoplinenumber = nextlinenumber;
  number = 0;

  for (k = 0; k < initialnumberallocation; k++)
  {
    pattern = patterns[k];

    if (!pattern)
      continue;

    renumbering[k] = expansionoffset + number;

    patterns[number] = pattern;
    number++;
  }

  for (nextlinenumber = linenumbers; nextlinenumber < stoplinenumber; nextlinenumber++)
  {
    if (*nextlinenumber < 0)
      *nextlineinmap = (unsigned char)(expansionoffset + *nextlinenumber);
    else
      *nextlineinmap = (unsigned char)renumbering[*nextlinenumber];
    nextlineinmap++;
  }

  nteletextlinepatterns = number;
  teletextlinepatterns = realloc(patterns, number * sizeof(int));

  hmap->endoflineactions[0] = videoendframeidle;
  hmap->endoflineactions[1] = videoendframesoon;
  hmap->endoflineactions[2] = videoendframenoadjust;
  hmap->endoflineactions[3] = videoendframeadjust;
  hmap->endoflineactions[4] = videoendframeadjusting;
  hmap->endoflineactions[5] = videoendframeadjustcomplete;
  hmap->endoflineactions[6] = videoendframedummy;

  hmap->B_vidbuf.setskewop = videoinactivesetskew;

  videoulainit();
}

void videosetpalette(void)
{
  int i;
  unsigned int u;
  float weights[8],gamma;

  if (beebit_palette == PALETTE_RGB)
  {
    for (i=0; i<8; i++)
    {
      palette_specified[i] = palette_rgb[i];
    }
  }
  else
  {
    weights[0] = 0.0f;
    weights[7] = 1.0f;
    gamma = 1.0f;

    switch (beebit_palette)
    {
      case PALETTE_COLOUR:
        weights[1] = 0.4716f;
        weights[2] = 0.6118f;
        weights[3] = 0.8922f;
        weights[4] = 0.2990f;
        weights[5] = 0.5794f;
        weights[6] = 0.7196f;
        gamma = 0.45f;
        break;
      case PALETTE_GREY:
      case PALETTE_GREEN:
        weights[1] = 0.2657f;
        weights[2] = 0.5845f;
        weights[3] = 0.8501f;
        weights[4] = 0.1499f;
        weights[5] = 0.4155f;
        weights[6] = 0.7343f;
        break;
    }

    for (i=0; i<8; i++)
    {
      u = (unsigned int)nearbyintf(255.0f * powf(weights[i],gamma));
      palette_specified[i] = (u<<24)|(u<<16)|(u<<8);
    }

    switch (beebit_palette)
    {
      case PALETTE_COLOUR:
        for (i=0; i<8; i++)
        {
          palette_specified[i] &= palette_rgb[i];
        }
        break;
      case PALETTE_GREEN:
        for (i=0; i<8; i++)
        {
          palette_specified[i] &= 0x00FF0000;
        }
        break;
    }
  }
}

unsigned int teletextgethalfdots(int dots, int adjacentdots)
{
  int highmask,lowmask,i;
  unsigned int j;
  unsigned int result = 0;

  lowmask = (dots<<1) & adjacentdots & ~(adjacentdots<<1);
  highmask = (dots>>1) & adjacentdots & ~(adjacentdots>>1);

  for (i=0x01,j=0x10; i<=0x10; i<<=1,j<<=2)
  {
    if (dots & i)
      result |= (j<<1)|j;
    else
    {
      if (lowmask & i)
        result |= j;
      if (highmask & i)
        result |= (j<<1);
    }
  }

  return result;
}

unsigned int teletextgetquarterdots(int dots, int adjacentdots)
{
  int highmask,lowmask,i;
  unsigned int j;
  unsigned int result = 0;

  lowmask = (dots<<1) & adjacentdots & ~(adjacentdots<<1);
  highmask = (dots>>1) & adjacentdots & ~(adjacentdots>>1);

  for (i=0x01,j=0x30; i<=0x10; i<<=1,j<<=4)
  {
    if (dots & i)
      result |= (j<<2)|j;
    else
    {
        if (lowmask & i)
          result |= j;
        if (highmask & i)
          result |= (j<<2);
    }
  }

  return result;
}

void teletextadjustquarterdots(unsigned int* dots, unsigned int* upperdots, unsigned int* lowerdots)
{
  int i;

  for (i=0x010; i<=0x100000; i<<=4)
  {
    if (*dots & i)
      continue;

    if (*upperdots & i)
    {
      *upperdots |= (i<<2);
      *dots |= i;
    }
    if (*upperdots & (i<<3))
    {
      *upperdots |= (i<<1);
      *dots |= (i<<3);
    }
    if (*lowerdots & i)
    {
      *lowerdots |= (i<<2);
      *dots |= i;
    }
    if (*lowerdots & (i<<3))
    {
      *lowerdots |= (i<<1);
      *dots |= (i<<3);
    }
  }
}

void teletextwriteslicehalves(intptr_t* address, int stride, int ndivisions, unsigned int subdots)
{
  unsigned int mask = (1U<<(ndivisions>>1))-1;
  *(uint32_t*)*address = subdots & mask;
  *address += (stride>>1);
  *(uint32_t*)*address = (subdots >> (ndivisions>>1)) & mask;
  *address += (stride>>1);
}

void teletextexpandslicehalves(intptr_t address, int ndivisions, int shift, int nslices, int stride)
{
  unsigned int block = (1U<<shift)-1;
  unsigned int d;
  unsigned int v;
  int i,j,f,f2;
  uint32_t* slice;

  for (i=(nslices<<1); i>0; i--, address+=(stride>>1))
  {
    slice = (uint32_t*)address;
    d = *slice;
    v = 0; f = 0;

    for (j=ndivisions; j>0; j-=2,d>>=1)
    {
      if (d&1)
        v |= (block<<f);
      f2 = f + shift;
      if (f2 >= 32)
      {
        *slice++ = v;
        if (d&1)
          v = block>>(32-f);
        else
          v = 0;
        f = f2 - 32;
      }
      else
        f = f2;
    }
    if (f > 0)
      *slice++ = v;
  }
}

void teletextwritelinemap(int slicesize, int nslices, intptr_t teletextaddress)
{
  HOSTMAP* hmap = &hostmap;
  int aline,gline,adoubleline,gdoubleline;
  int linesize = nslices * slicesize;
  intptr_t* p = hmap->teletextlinelut;
  int i,j;

  if (nslices > 1)
  {
    for (i=0; i<960; i+=10, p+=128)
    {
      for (j=0; j<20; j++)
      {
        aline = j<10 ? teletextlinemap[i+j] : 0;
        adoubleline = teletextlinemap[i+(j>>1)];
        gline = j<10 ? teletextlinemap[960+i+j] : 0;
        gdoubleline = teletextlinemap[960+i+(j>>1)];

        p[j] = teletextaddress + aline * linesize;
        p[20+j] = teletextaddress + gline * linesize;
        if (gline < 4)
        {
          if (j==2||j==6||j==9)
            gline = 0;
          else
            gline += 4;
        }
        p[40+j] = teletextaddress + gline * linesize;
        if (adoubleline < 4)
          p[60+j] = teletextaddress + adoubleline * linesize;
        else
          p[60+j] = teletextaddress + (adoubleline + (1+(j&1)) * nteletextlinepatterns) * linesize;
        if (gdoubleline < 4)
        {
          p[80+j] = teletextaddress + gdoubleline * linesize;
          if ((j>>1)==2||(j>>1)==6||(j>>1)==9)
            gdoubleline = 0;
          else
            gdoubleline += 4;
          p[100+j] = teletextaddress + gdoubleline * linesize;
        }
        else
        {
          p[100+j] = p[80+j] = teletextaddress + (gdoubleline + (1+(j&1)) * nteletextlinepatterns) * linesize;
        }
      }
    }
  }
  else
  {
    for (i=0; i<960; i+=10, p+=128)
    {
      for (j=0; j<20; j++)
      {
        aline = j<10 ? teletextlinemap[i+j] : 0;
        adoubleline = teletextlinemap[i+(j>>1)];
        gline = j<10 ? teletextlinemap[960+i+j] : 0;
        gdoubleline = teletextlinemap[960+i+(j>>1)];

        p[j] = teletextaddress + aline * slicesize;
        p[20+j] = teletextaddress + gline * slicesize;
        if (gline < 4)
        {
          if (j==2||j==6||j==9)
            gline = 0;
          else
            gline += 4;
        }
        p[40+j] = teletextaddress + gline * slicesize;
        p[60+j] = teletextaddress + adoubleline * slicesize;
        p[80+j] = teletextaddress + gdoubleline * slicesize;
        if (gdoubleline < 4)
        {
          if ((j>>1)==2||(j>>1)==6||(j>>1)==9)
            gdoubleline = 0;
          else
            gdoubleline += 4;
        }
        p[100+j] = teletextaddress + gdoubleline * slicesize;
      }
    }
  }
}

static inline void videosetdisplayfunctions(VIDEOSCALECHOICE* choice)
{
  HOSTMAP* hmap = &hostmap;
  R6502PERIPHERALOP displaystopop;
  R6502PERIPHERALOP displayvsyncedgeop,displaypossiblestartop;
  R6502PERIPHERALOP teletextblacklevelop,cursorteletextblacklevelop;
  R6502PERIPHERALOP teletextop,cursorteletextop;
  int i;

  if (hmap->A_vidbuf.progressive)
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videoprogressiveenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipprogressiveenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddleprogressiveleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videoprogressiveleavingvsync;
    displaystopop = videodisplayprogressivestop;
  }
  else if (beebit_videospeed == VIDEO_FAST)
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videofastenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipfastenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddlefastleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videofastleavingvsync;
    displaystopop = videodisplayfaststop;
  }
  else
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videoslowenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipslowenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddleslowleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videoslowleavingvsync;
    displaystopop = videodisplayslowstop;
  }

  if (hmap->A_vidbuf.progressive)
  {
    displayvsyncedgeop = videodisplaypsyncedge;
    displaypossiblestartop = videodisplayppossiblestart;
  }
  else
  {
    displayvsyncedgeop = videodisplaysyncedge;
    displaypossiblestartop = videodisplaypossiblestart;
  }

  if (beebit_machinetype == MACHINE_MODELB || beebit_machinetype == MACHINE_MODELBPLUS)
  {
    teletextblacklevelop = choice->blacklevelops.teletextb;
    cursorteletextblacklevelop = choice->blacklevelops.cursorteletextb;
    hmap->B_vidbuf.teletextinnerop = choice->writeinnerops.teletextb;
    teletextop = choice->writeops.teletextb;
    cursorteletextop = choice->writeops.cursorteletextb;
  }
  else
  {
    teletextblacklevelop = choice->blacklevelops.teletext;
    cursorteletextblacklevelop = choice->blacklevelops.cursorteletext;
    hmap->B_vidbuf.teletextinnerop = choice->writeinnerops.teletext;
    teletextop = choice->writeops.teletext;
    cursorteletextop = choice->writeops.cursorteletext;
  }

  hmap->blacklevelops[0] = choice->blacklevelops.blank;
  hmap->blacklevelops[1] = choice->blacklevelops.graphics;
  hmap->blacklevelops[2] = teletextblacklevelop;
  hmap->blacklevelops[3] = teletextblacklevelop;
  hmap->blacklevelops[4] = choice->blacklevelops.cursorblank;
  hmap->blacklevelops[5] = choice->blacklevelops.cursorgraphics;
  hmap->blacklevelops[6] = cursorteletextblacklevelop;
  hmap->blacklevelops[7] = cursorteletextblacklevelop;

  hmap->B_vidbuf.graphicsinnerop = choice->writeinnerops.graphics;
  hmap->B_vidbuf.cursorinnerop = choice->writeinnerops.cursor;

  hmap->peripheralops[0] = videodisplayskip;
  hmap->peripheralops[1] = choice->writeops.graphics;
  hmap->peripheralops[2] = teletextop;
  hmap->peripheralops[3] = teletextop;
  hmap->peripheralops[4] = choice->writeops.cursorblank;
  hmap->peripheralops[5] = choice->writeops.cursorgraphics;
  hmap->peripheralops[6] = cursorteletextop;
  hmap->peripheralops[7] = cursorteletextop;
  for (i=0x08; i<0x10; i++)
  {
    hmap->peripheralops[i] = videodisplayskip;
  }
  for (i=0x10; i<0x20; i++)
  {
    hmap->peripheralops[i] = videodisplayoutright;
  }
  for (i=0x20; i<0x30; i++)
  {
    hmap->peripheralops[i] = displaystopop;
  }
  for (i=0x30; i<0x40; i++)
  {
    hmap->peripheralops[i] = videodisplayoutleft;
  }
  for (i=0x40; i<0x80; i++)
  {
    hmap->peripheralops[i] = displaypossiblestartop;
  }
  for (i=0x80; i<0x100; i++)
  {
    hmap->peripheralops[i] = displayvsyncedgeop;
  }

  if (hmap->A_vidbuf.progressive)
    hmap->B_vidbuf.setskewop = videoprogressivesetskew;
  else
    hmap->B_vidbuf.setskewop = videosetskew;
}

static inline void videosetreadfour(HOSTVIDEOREADOP* first, const HOSTVIDEOREADOP* src)
{
  first[0] = src[0];
  first[4] = src[1];
  first[8] = src[2];
  first[12] = src[3];
}

static inline void videosetreadfunctions(void)
{
  HOSTMAP* hmap = &hostmap;
  const VIDEOREADSET* readset;
  const VIDEOREADTWENTY* readgraphicstwenty;
  const VIDEOREADTWENTY* readteletexttwenty;
  int i;

  if (beebit_videospeed == VIDEO_PROGRESSIVE_SLOW)
    readset = &videoreadpset;
  else
    readset = &videoreadset;

  readgraphicstwenty = (*readset)[0];

  if (beebit_machinetype == MACHINE_MODELB)
    readteletexttwenty = (*readset)[1];
  else
    readteletexttwenty = (*readset)[2];

  for (i=0; i<4; i++)
  {
    memcpy(&hmap->videographicswrapreads[i<<2], (*(*readgraphicstwenty)[i+1]), sizeof(VIDEOREADFOUR));
  }
  for (i=0; i<4; i++)
  {
    memcpy(&hmap->videoteletextwrapreads[i<<2], (*(*readteletexttwenty)[i+1]), sizeof(VIDEOREADFOUR));
  }

  videosetreadfour(&hmap->videoreads[0], (*(* readgraphicstwenty)[0]));
  videosetreadfour(&hmap->videoreads[1], &hmap->videographicswrapreads[hmap->screenstartindex<<2]);
  videosetreadfour(&hmap->videoreads[2], (*(* readteletexttwenty)[0]));
  videosetreadfour(&hmap->videoreads[3], &hmap->videoteletextwrapreads[hmap->screenstartindex<<2]);

  for (i=16; i<32; i++)
  {
    hmap->videoreads[i] = videoreaddisplaysignal;
  }
  if (hmap->A_vidbuf.progressive)
  {
    for (i=32; i<64; i++)
    {
      hmap->videoreads[i] = videoreadpcursorsignal;
    }
  }
  else
  {
    for (i=32; i<64; i++)
    {
      hmap->videoreads[i] = videoreadcursorsignal;
    }
  }
  for (i=64; i<128; i++)
  {
    hmap->videoreads[i] = videoreadlinetest;
  }
  for (i=128; i<256; i++)
  {
    hmap->videoreads[i] = videoreadevent;
  }
}

static inline uintptr_t videoupdateskipbit(uintptr_t peripheral_code, uint8_t skip)
{
  if (skip)
    peripheral_code |= VIDEODISPLAYSKIP;
  else
    peripheral_code &= ~VIDEODISPLAYSKIP;
  return peripheral_code;
}

static inline uintptr_t videoupdateadvanceandskipbits(HOSTMAP* hmap, uintptr_t peripheral_code, uint8_t skip)
{
  intptr_t column;

  peripheral_code = videoupdateskipbit(peripheral_code & ~VIDEODISPLAYADVANCEMASK, skip);

  if (skip & HSYNCSKIPFLAG)
    peripheral_code |= VIDEODISPLAYSTOP;
  else
  {
    column = hmap->B_vidbuf.column;

    if (column < 0)
      peripheral_code |= VIDEODISPLAYOUTLEFT;
    else if (column >= hmap->B_vidbuf.limitcolumn)
      peripheral_code |= VIDEODISPLAYSTOP;
    else if (column >= hmap->B_vidbuf.stopcolumn)
      peripheral_code |= VIDEODISPLAYOUTRIGHT;
  }

  return peripheral_code;
}

static inline HOSTMAP* videorefreshclippedskipflag(HOSTMAP* hmap)
{
  if (hmap->B_vidbuf.line < 0 || hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;
  return hmap;
}

static inline uintptr_t videoupdatepskipbit(uintptr_t peripheral_code, uint8_t skip)
{
  if ((skip & TIMINGSKIPFLAGS) || skip >= PROGRESSIVECLIPPEDSKIPFLAGS)
    peripheral_code |= VIDEODISPLAYSKIP;
  else
    peripheral_code &= ~VIDEODISPLAYSKIP;
  return peripheral_code;
}

static inline uintptr_t videoupdatepadvanceandskipbits(HOSTMAP* hmap, uintptr_t peripheral_code, uint8_t skip)
{
  intptr_t column;

  peripheral_code = videoupdatepskipbit(peripheral_code & ~VIDEODISPLAYADVANCEMASK, skip);

  if (skip & HSYNCSKIPFLAG)
    peripheral_code |= VIDEODISPLAYSTOP;
  else
  {
    column = hmap->B_vidbuf.column;

    if (column < 0)
      peripheral_code |= VIDEODISPLAYOUTLEFT;
    else if (column >= hmap->B_vidbuf.limitcolumn)
      peripheral_code |= VIDEODISPLAYSTOP;
    else if (column >= hmap->B_vidbuf.stopcolumn)
      peripheral_code |= VIDEODISPLAYOUTRIGHT;
  }

  return peripheral_code;
}

static inline void videorefreshpclippedskipflag(HOSTMAP* hmap)
{
  if (hmap->B_vidbuf.line < 0 || hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

  if (hmap->B_vidbuf.line < 1 || hmap->B_vidbuf.line > hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDABOVESKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDABOVESKIPFLAG;

  if (hmap->B_vidbuf.line < -1 || hmap->B_vidbuf.line + 1 >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDBELOWSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDBELOWSKIPFLAG;
}

void videosetscale(void)
{
  HOSTMAP* hmap = &hostmap;
  VIDEOSCALEUPDATEPARAMS uparams;
  VIDEOSCALECHOICE choice;
  int log2bpp,xres,yres,i,j;
  int columnstep, linestep;
  int linelength;
  int columncapacity;
  int columnremainder;
  intptr_t stopcolumn;
  int nstopmarkers;
  int linecapacity;
  int lineremainder;
  intptr_t buffersize;
  int nteletextslices;
  int adjustednteletextslices;
  int nteletextlog2divisionshift;
  int nteletextdivisions;
  int adjustednteletextdivisions;
  int teletextslicesize;
  int teletextlinecount;
  int teletextsize;
  unsigned int graphicleft,graphicright,separationmask;
  unsigned int subdots,uppersubdots,lowersubdots;
  int pattern;
  intptr_t bufferaddress;
  intptr_t teletextaddress;
  intptr_t sliceaddress;
  int workspacesize = 0;
  unsigned int (*getsubdots)(int, int);

  uparams.videospeed = beebit_videospeed;
  uparams.framerate = beebit_framerate;
  videoscalechoose(beebit_graphicsmodespecifier, &uparams, &choice);

  hmap->A_vidbuf.shift = choice.buffershift;
  hmap->A_vidout.linescaletotal = choice.linescale;
  videoscale_updateparameters = uparams;
  videoscale_lutparameters = choice.lutparameters;
  videoscale_init = choice.init;

  videoscalesetops(&choice);

  regs.r[0] = beebit_graphicsmodespecifier;
  regs.r[1] = 9;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  log2bpp = regs.r[2];
  regs.r[1] = 11;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  xres = regs.r[2] + 1;
  regs.r[1] = 12;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  yres = regs.r[2] + 1;

  hmap->B_vidout.nbits = choice.columnpixels<<log2bpp;

  if (choice.format&4)
    hmap->A_videoula.fragmentbits = 8;
  else
    hmap->A_videoula.fragmentbits = 4;

  linestep = choice.linescale;

  columnstep = (choice.columnpixels<<log2bpp)>>3;

  linelength = (xres<<log2bpp)>>3;
  columncapacity = linelength / columnstep;
  columnremainder = linelength % columnstep;

  if (columncapacity & 1)
  {
    video_screenstartoffset = ((columnremainder + columnstep) >> 3) << 2;

    if (video_screenstartoffset > columnremainder)
    {
      columncapacity--;
    }
    else
    {
      video_screenstartoffset = (columnremainder >> 3) << 2;
    }
  }
  else
  {
    video_screenstartoffset = (columnremainder >> 3) << 2;
  }

  hmap->B_vidbuf.synccolumn = beebit_hadjust + (columncapacity - 129) / 2;
  stopcolumn = hmap->B_vidbuf.synccolumn + 128;

  if (stopcolumn > columncapacity)
    stopcolumn = columncapacity;

  if (hmap->B_vidbuf.synccolumn > 0)
  {
    video_screenstartoffset += hmap->B_vidbuf.synccolumn * columnstep;
    stopcolumn -= hmap->B_vidbuf.synccolumn;
    hmap->B_vidbuf.synccolumn = 0;
  }

  hmap->B_vidbuf.limitcolumn = hmap->B_vidbuf.synccolumn + 128;

  linecapacity = yres / linestep;
  lineremainder = yres % linestep;

  if (linecapacity & 1)
  {
    video_screenstartline = ((lineremainder + linestep) >> 1) << 1;

    if (video_screenstartline > lineremainder)
    {
      linecapacity--;
    }
    else
    {
      video_screenstartline = (lineremainder >> 1) << 1;
    }
  }
  else
  {
    video_screenstartline = (lineremainder >> 1) << 1;
  }

  hmap->B_vidbuf.syncline = beebit_vadjust + (linecapacity - 317) / 2;
  hmap->B_vidbuf.stopline = hmap->B_vidbuf.syncline + 312;

  if (hmap->B_vidbuf.stopline > linecapacity)
    hmap->B_vidbuf.stopline = linecapacity;

  if (hmap->B_vidbuf.syncline > 0)
  {
    video_screenstartline += hmap->B_vidbuf.syncline * linestep;
    hmap->B_vidbuf.stopline -= hmap->B_vidbuf.syncline;
    hmap->B_vidbuf.syncline = 0;
  }

  hmap->B_vidbuf.startline = hmap->B_vidbuf.syncline + 30;
  hmap->B_vidbuf.limitline = hmap->B_vidbuf.syncline + 312;

  hmap->B_vidbuf.column += hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.line += hmap->B_vidbuf.syncline;

  hmap->B_vidbuf.stopcolumn = stopcolumn;

  if (columnstep&1)
    nstopmarkers = (-stopcolumn&3)+1;
  else if (columnstep&2)
    nstopmarkers = (-stopcolumn&1)+1;
  else
    nstopmarkers = 1;

  if (choice.format&8)
  {
    hmap->A_vidbuf.distinctfields = 1;
    hmap->A_vidbuf.progressive = (beebit_videospeed == VIDEO_PROGRESSIVE_SLOW);
  }
  else
  {
    hmap->A_vidbuf.distinctfields = 0;
    hmap->A_vidbuf.progressive = 0;
    hmap->A_vidbuf.writecode = 0x30;
  }

  hmap->B_vidbuf.stride = (stopcolumn+nstopmarkers) << hmap->A_vidbuf.shift;
  hmap->B_vidbuf.stride += (-hmap->B_vidbuf.stride&3);

  if (hmap->A_vidbuf.progressive)
  {
    hmap->B_vidbuf.altoffset = hmap->B_vidbuf.stride;
    hmap->B_vidbuf.stride <<= 1;
  }

  hmap->B_vidbuf.stride = sizeof(intptr_t) + hmap->B_vidbuf.stride;

  buffersize = hmap->B_vidbuf.stopline * hmap->B_vidbuf.stride;

  if (choice.format&2)
    nteletextlog2divisionshift = 3;
  else
    nteletextlog2divisionshift = 2;

  if (!(choice.format&3))
  {
    nteletextdivisions = 16;
    graphicleft = 0x00FF;
    graphicright = 0xFF00;
    separationmask = 0xFCFC;
    getsubdots = teletextgethalfdots;
    hmap->B_teletext.bblevelbit = (2<<nteletextlog2divisionshift);
  }
  else
  {
    nteletextdivisions = 24;
    graphicleft = 0x000FFF;
    graphicright = 0xFFF000;
    separationmask = 0xFF0FF0;
    getsubdots = teletextgetquarterdots;
    hmap->B_teletext.bblevelbit = (4<<nteletextlog2divisionshift);
  }

  adjustednteletextdivisions = (((nteletextdivisions<<nteletextlog2divisionshift)+63)&~63)>>nteletextlog2divisionshift;

  teletextslicesize = ((adjustednteletextdivisions>>3)<<nteletextlog2divisionshift);

  nteletextslices = choice.teletextslices;
  if (nteletextslices == 3 && hmap->A_vidbuf.distinctfields)
    adjustednteletextslices = nteletextslices+1;
  else
    adjustednteletextslices = nteletextslices;

  if (nteletextslices > 1)
    teletextlinecount = 8 + 3 * nteletextlinepatterns;
  else
    teletextlinecount = 8 + nteletextlinepatterns;

  teletextsize = teletextlinecount * adjustednteletextslices * teletextslicesize;

  hmap->B_teletext.rightoffset = teletextslicesize>>1;
  if (hmap->A_vidbuf.distinctfields)
  {
    if (nteletextslices < 3)
      hmap->B_teletext.lowoffset = teletextslicesize;
    else
      hmap->B_teletext.lowoffset = (teletextslicesize<<1);
  }
  else
    hmap->B_teletext.lowoffset = 0;

  hmap->B_vidout.lut = workspacesize;
  workspacesize += choice.lutsize + (-choice.lutsize & 3);
  bufferaddress = workspacesize;
  workspacesize += buffersize + (-buffersize & 3);
  teletextaddress = workspacesize;
  workspacesize += teletextsize + (-teletextsize & 3);

  video_workspace = malloc(workspacesize);

  hmap->B_vidout.lut += (intptr_t)video_workspace;
  bufferaddress += (intptr_t)video_workspace;
  teletextaddress += (intptr_t)video_workspace;

  memset((void*)bufferaddress, 0, buffersize);
  bufferaddress += sizeof(intptr_t);

  hmap->B_vidbuf.synclineaddress = bufferaddress + hmap->B_vidbuf.syncline * hmap->B_vidbuf.stride;
  hmap->B_vidbuf.lineaddress = bufferaddress + hmap->B_vidbuf.line * hmap->B_vidbuf.stride;

  for (i=0; i<hmap->B_vidbuf.stopline; i++)
  {
    for (j=0; j<nstopmarkers; j++)
    {
      ((unsigned char*)bufferaddress)[(stopcolumn+j)<<hmap->A_vidbuf.shift] = 0x80;
    }

    if (hmap->A_vidbuf.progressive)
    {
      for (j=0; j<nstopmarkers; j++)
      {
        ((unsigned char*)(bufferaddress+hmap->B_vidbuf.altoffset))[(stopcolumn+j)<<hmap->A_vidbuf.shift] = 0x80;
      }
    }

    bufferaddress += hmap->B_vidbuf.stride;
  }

  sliceaddress = teletextaddress;
  lowersubdots = uppersubdots = subdots = 0;

  for (i=0; i<8; i++)
  {
    subdots = ((i&2)?graphicright:0) | ((i&1)?graphicleft:0);
    if (i>=4)
      subdots &= separationmask;
    for (j=0; j<adjustednteletextslices; j++)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
  }

  for (i=0; i<nteletextlinepatterns; i++)
  {
    pattern = teletextlinepatterns[i];
    if (nteletextslices & 2)
    {
      uppersubdots = getsubdots((pattern>>5)&0x1F, pattern&0x1F);
      lowersubdots = getsubdots((pattern>>5)&0x1F, (pattern>>10)&0x1F);
    }
    if (nteletextslices & 1)
    {
      subdots = getsubdots((pattern>>5)&0x1F, 0);
      if ((nteletextslices & 2) && getsubdots == teletextgetquarterdots)
        teletextadjustquarterdots(&subdots, &uppersubdots, &lowersubdots);
    }
    if (nteletextslices & 2)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, uppersubdots);
    }
    if (nteletextslices & 1)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
    if (nteletextslices & 2)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, lowersubdots);
    }
    if (adjustednteletextslices > nteletextslices)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
  }

  if (nteletextslices > 1)
  {
    for (i=0; i<nteletextlinepatterns; i++)
    {
      pattern = teletextlinepatterns[i];
      subdots = getsubdots((pattern>>5)&0x1F, pattern&0x1F);
      for (j=0; j<adjustednteletextslices; j++)
      {
        teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
      }
    }
    for (i=0; i<nteletextlinepatterns; i++)
    {
      pattern = teletextlinepatterns[i];
      subdots = getsubdots((pattern>>5)&0x1F, (pattern>>10)&0x1F);
      for (j=0; j<adjustednteletextslices; j++)
      {
        teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
      }
    }
  }

  if (nteletextlog2divisionshift > 0)
    teletextexpandslicehalves(teletextaddress, nteletextdivisions, 1<<nteletextlog2divisionshift, teletextlinecount * adjustednteletextslices, teletextslicesize);

  teletextwritelinemap(teletextslicesize, adjustednteletextslices, teletextaddress);

  hmap->A_teletext.roundingdirection2 = hmap->A_teletext.roundingdirection1 = 0;
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1 = hmap->teletextlinelut[0];

  hmap->A_vidbuf.updateframenumber = (1<<beebit_framerate)-1;

  if (hmap->A_vidbuf.updateframecounter > hmap->A_vidbuf.updateframenumber)
    hmap->A_vidbuf.updateframecounter = 0;

  if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
    hmap->A_vidbuf.skip = 0;
  else
    hmap->A_vidbuf.skip = FRAMETIMESKIPFLAG;

  if (beebit_videospeed == VIDEO_FAST)
    hmap->A_vidbuf.skip |= hmap->A_vidbuf.fastskipflipflop;

  hmap->B_crtc.cursorbuffer = 0;

  if (nteletextslices == 1)
  {
    for (i=0; i<128; i++)
    {
      hmap->teletextops[0x000+(i<<1)] = teletextnoponeslice;
    }
  }
  else
  {
    for (i=0; i<128; i++)
    {
      hmap->teletextops[0x000+(i<<1)] = teletextnoprounding;
    }
  }

  videoulasetloads(nteletextslices == 1);
  videosetdisplayfunctions(&choice);
  videosetreadfunctions();
  if (hmap->A_vidbuf.progressive)
  {
    videorefreshpclippedskipflag(hmap);
    hmap->peripheral_code = videoupdatepadvanceandskipbits(hmap, hmap->peripheral_code, hmap->A_vidbuf.skip);
  }
  else
  {
    videorefreshclippedskipflag(hmap);
    hmap->peripheral_code = videoupdateadvanceandskipbits(hmap, hmap->peripheral_code, hmap->A_vidbuf.skip);
  }

  nclock = clock()+TIME_50HZ;
}

void videohostmodevars(void)
{
  HOSTMAP* hmap = &hostmap;
  int ncolour,log2bpp,i;
  uintptr_t u;
  intptr_t nlineaddress;
  int linescale, steplinelength;
  intptr_t bufferaddress;
  uintptr_t* colournumbers = hmap->D_colour.numbers;
  uintptr_t* outputfill = hmap->D_colour.outputfill;

  screenstartandlinelength();

  linescale = hmap->A_vidout.linescaletotal;
  hmap->B_vidout.linelength = nhostscreenlinelength;
  hmap->B_vidout.lowoffset = nhostscreenlinelength * ((linescale+1)>>1);

  regs.r[0] = beebit_graphicsmodespecifier;
  regs.r[1] = 3;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  ncolour = regs.r[2];
  regs.r[1] = 9;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  log2bpp = regs.r[2];

  if (ncolour == 15 || ncolour == 255)
  {
    uint32_t fullpalette[256];

    for (i=0; i<8; i++)
    {
      fullpalette[i] = palette_specified[i];
      colournumbers[i+8] = colournumbers[i] = i;
    }
    for (i=8; i<ncolour; i++)
    {
      fullpalette[i] = (i<<24)|(i<<16)|(i<<8);
    }

    regs.r[0] = -1;
    regs.r[1] = -1;
    regs.r[2] = (int)fullpalette;
    regs.r[3] = 0;
    regs.r[4] = 0;
    _kernel_swi(ColourTrans_WritePalette,&regs,&regs);
  }
  else
  {
    for (i=0; i<8; i++)
    {
      regs.r[0] = palette_specified[i];
      _kernel_swi(ColourTrans_ReturnColourNumber,&regs,&regs);
      colournumbers[i+8] = colournumbers[i] = regs.r[0];
    }
  }

  for (i=0; i<8; i++)
  {
    u = colournumbers[i];
    if (log2bpp < 3)
      u |= (u<<4);
    if (log2bpp < 4)
      u |= (u<<8);
    if (log2bpp < 5)
      u |= (u<<16);
    outputfill[i+8] = outputfill[i] = u;
  }

  videoscale_init(&videoscale_lutparameters);
  videoulasetcolours();
  refreshteletextcolourfill(hmap);

  nlineaddress = nhostscreen;
  nlineaddress += video_screenstartoffset;
  nlineaddress += video_screenstartline * nhostscreenlinelength;

  steplinelength = nhostscreenlinelength * linescale;

  bufferaddress = hmap->B_vidbuf.synclineaddress - hmap->B_vidbuf.syncline * hmap->B_vidbuf.stride;

  for (i=0; i<hmap->B_vidbuf.stopline; i++)
  {
    ((intptr_t*)bufferaddress)[-1] = nlineaddress;

    nlineaddress += steplinelength;
    bufferaddress += hmap->B_vidbuf.stride;
  }
}

int writeusedcolours(void)
{
  HOSTMAP* hmap = &hostmap;
  const char* const names[8] = {
    "Black",
    "Red",
    "Green",
    "Yellow",
    "Blue",
    "Magenta",
    "Cyan",
    "White"
  };
  const char *columnnames = "\n COLOUR    FILL      VALUE\n";
  int i;
  char buffer[128];
  const unsigned int* outputfill = hmap->D_colour.outputfill;

  wimpwrite(columnnames,1,strlen(columnnames));

  for (i=0; i<8; i++)
  {
    snprintf(buffer,sizeof(buffer),"%7s  &%08X  &%08X\n",
      names[i],outputfill[i],
      palette_specified[i]);
    wimpwrite(buffer,1,strlen(buffer));
  }

  return 1;
}

void videofreeworkspace(void)
{
  HOSTMAP* hmap = &hostmap;

  hmap->B_vidbuf.column -= hmap->B_vidbuf.offsetsynccolumn;
  hmap->B_vidbuf.line -= hmap->B_vidbuf.syncline;
  hmap->B_vidbuf.setskewop = videoinactivesetskew;

  videoulaclearloads();

  free(video_workspace);
  video_workspace = NULL;
}

void videoreset(void)
{
  int i;
  HOSTMAP* hmap = &hostmap;
  CRTCSTEPOP crtctaggedops[256] = {
    videoupdatestep, videoupdateH0step, videoupdateB0step, videoupdateB0H0step,
    videoupdateB1step, videoupdateB1H0step, videoupdateB1step, videoupdateB1H0step,
    videoupdateB2step, videoupdateB2H0step, videoupdateB2B0step, videoupdateB2B0H0step,
    videoupdateB2B1step, videoupdateB2B1H0step, videoupdateB2B1step, videoupdateB2B1H0step,

    videoupdateBCstep, videoupdateBCH0step, videoupdateB0step, videoupdateB0H0step,
    videoupdateB1step, videoupdateB1H0step, videoupdateB1step, videoupdateB1H0step,
    videoupdateBCB2step, videoupdateBCB2H0step, videoupdateB2B0step, videoupdateB2B0H0step,
    videoupdateB2B1step, videoupdateB2B1H0step, videoupdateB2B1step, videoupdateB2B1H0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,

    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateTstep, videoupdateTH0step, videoupdateTB0step, videoupdateTB0H0step,
    videoupdateTB1step, videoupdateTB1H0step, videoupdateTB1step, videoupdateTB1H0step,
    videoupdateTB2step, videoupdateTB2H0step, videoupdateTB2B0step, videoupdateTB2B0H0step,
    videoupdateTB2B1step, videoupdateTB2B1H0step, videoupdateTB2B1step, videoupdateTB2B1H0step,

    videoupdateTBCstep, videoupdateTBCH0step, videoupdateTB0step, videoupdateTB0H0step,
    videoupdateTB1step, videoupdateTB1H0step, videoupdateTB1step, videoupdateTB1H0step,
    videoupdateTBCB2step, videoupdateTBCB2H0step, videoupdateTB2B0step, videoupdateTB2B0H0step,
    videoupdateTB2B1step, videoupdateTB2B1H0step, videoupdateTB2B1step, videoupdateTB2B1H0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,

    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step
  };
  HOSTVIDEOOP teletextstartoflineops[128] = {
    teletextcodestartofline00,
    teletextcodestartofline01,
    teletextcodestartofline02,
    teletextcodestartofline03,
    teletextcodestartofline04,
    teletextcodestartofline05,
    teletextcodestartofline06,
    teletextcodestartofline00,
    teletextcodestartofline08,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline0D,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline11,
    teletextcodestartofline12,
    teletextcodestartofline13,
    teletextcodestartofline14,
    teletextcodestartofline15,
    teletextcodestartofline16,
    teletextcodestartofline17,
    teletextcodestartofline18,
    teletextcodestartofline00,
    teletextcodestartofline1A,
    teletextcodestartofline00,
    teletextcodestartofline00,
    teletextcodestartofline1D,
    teletextcodestartofline1E,
    teletextcodestartofline00,
    teletextcodestartofline20,
    teletextcodestartofline21,
    teletextcodestartofline22,
    teletextcodestartofline23,
    teletextcodestartofline24,
    teletextcodestartofline25,
    teletextcodestartofline26,
    teletextcodestartofline27,
    teletextcodestartofline28,
    teletextcodestartofline29,
    teletextcodestartofline2A,
    teletextcodestartofline2B,
    teletextcodestartofline2C,
    teletextcodestartofline2D,
    teletextcodestartofline2E,
    teletextcodestartofline2F,
    teletextcodestartofline30,
    teletextcodestartofline31,
    teletextcodestartofline32,
    teletextcodestartofline33,
    teletextcodestartofline34,
    teletextcodestartofline35,
    teletextcodestartofline36,
    teletextcodestartofline37,
    teletextcodestartofline38,
    teletextcodestartofline39,
    teletextcodestartofline3A,
    teletextcodestartofline3B,
    teletextcodestartofline3C,
    teletextcodestartofline3D,
    teletextcodestartofline3E,
    teletextcodestartofline3F,
    teletextcodestartofline40,
    teletextcodestartofline41,
    teletextcodestartofline42,
    teletextcodestartofline43,
    teletextcodestartofline44,
    teletextcodestartofline45,
    teletextcodestartofline46,
    teletextcodestartofline47,
    teletextcodestartofline48,
    teletextcodestartofline49,
    teletextcodestartofline4A,
    teletextcodestartofline4B,
    teletextcodestartofline4C,
    teletextcodestartofline4D,
    teletextcodestartofline4E,
    teletextcodestartofline4F,
    teletextcodestartofline50,
    teletextcodestartofline51,
    teletextcodestartofline52,
    teletextcodestartofline53,
    teletextcodestartofline54,
    teletextcodestartofline55,
    teletextcodestartofline56,
    teletextcodestartofline57,
    teletextcodestartofline58,
    teletextcodestartofline59,
    teletextcodestartofline5A,
    teletextcodestartofline5B,
    teletextcodestartofline5C,
    teletextcodestartofline5D,
    teletextcodestartofline5E,
    teletextcodestartofline5F,
    teletextcodestartofline60,
    teletextcodestartofline61,
    teletextcodestartofline62,
    teletextcodestartofline63,
    teletextcodestartofline64,
    teletextcodestartofline65,
    teletextcodestartofline66,
    teletextcodestartofline67,
    teletextcodestartofline68,
    teletextcodestartofline69,
    teletextcodestartofline6A,
    teletextcodestartofline6B,
    teletextcodestartofline6C,
    teletextcodestartofline6D,
    teletextcodestartofline6E,
    teletextcodestartofline6F,
    teletextcodestartofline70,
    teletextcodestartofline71,
    teletextcodestartofline72,
    teletextcodestartofline73,
    teletextcodestartofline74,
    teletextcodestartofline75,
    teletextcodestartofline76,
    teletextcodestartofline77,
    teletextcodestartofline78,
    teletextcodestartofline79,
    teletextcodestartofline7A,
    teletextcodestartofline7B,
    teletextcodestartofline7C,
    teletextcodestartofline7D,
    teletextcodestartofline7E,
    teletextcodestartofline7F
  };
  HOSTVIDEOOP teletextmidlineops[128] = {
    teletextcodemidline00,
    teletextcodemidline01,
    teletextcodemidline02,
    teletextcodemidline03,
    teletextcodemidline04,
    teletextcodemidline05,
    teletextcodemidline06,
    teletextcodemidline07,
    teletextcodemidline08,
    teletextcodemidline09,
    teletextcodemidline00,
    teletextcodemidline00,
    teletextcodemidline0C,
    teletextcodemidline0D,
    teletextcodemidline00,
    teletextcodemidline00,
    teletextcodemidline00,
    teletextcodemidline11,
    teletextcodemidline12,
    teletextcodemidline13,
    teletextcodemidline14,
    teletextcodemidline15,
    teletextcodemidline16,
    teletextcodemidline17,
    teletextcodemidline18,
    teletextcodemidline19,
    teletextcodemidline1A,
    teletextcodemidline00,
    teletextcodemidline1C,
    teletextcodemidline1D,
    teletextcodemidline1E,
    teletextcodemidline1F,
    teletextcodemidline20,
    teletextcodemidline21,
    teletextcodemidline22,
    teletextcodemidline23,
    teletextcodemidline24,
    teletextcodemidline25,
    teletextcodemidline26,
    teletextcodemidline27,
    teletextcodemidline28,
    teletextcodemidline29,
    teletextcodemidline2A,
    teletextcodemidline2B,
    teletextcodemidline2C,
    teletextcodemidline2D,
    teletextcodemidline2E,
    teletextcodemidline2F,
    teletextcodemidline30,
    teletextcodemidline31,
    teletextcodemidline32,
    teletextcodemidline33,
    teletextcodemidline34,
    teletextcodemidline35,
    teletextcodemidline36,
    teletextcodemidline37,
    teletextcodemidline38,
    teletextcodemidline39,
    teletextcodemidline3A,
    teletextcodemidline3B,
    teletextcodemidline3C,
    teletextcodemidline3D,
    teletextcodemidline3E,
    teletextcodemidline3F,
    teletextcodemidline40,
    teletextcodemidline41,
    teletextcodemidline42,
    teletextcodemidline43,
    teletextcodemidline44,
    teletextcodemidline45,
    teletextcodemidline46,
    teletextcodemidline47,
    teletextcodemidline48,
    teletextcodemidline49,
    teletextcodemidline4A,
    teletextcodemidline4B,
    teletextcodemidline4C,
    teletextcodemidline4D,
    teletextcodemidline4E,
    teletextcodemidline4F,
    teletextcodemidline50,
    teletextcodemidline51,
    teletextcodemidline52,
    teletextcodemidline53,
    teletextcodemidline54,
    teletextcodemidline55,
    teletextcodemidline56,
    teletextcodemidline57,
    teletextcodemidline58,
    teletextcodemidline59,
    teletextcodemidline5A,
    teletextcodemidline5B,
    teletextcodemidline5C,
    teletextcodemidline5D,
    teletextcodemidline5E,
    teletextcodemidline5F,
    teletextcodemidline60,
    teletextcodemidline61,
    teletextcodemidline62,
    teletextcodemidline63,
    teletextcodemidline64,
    teletextcodemidline65,
    teletextcodemidline66,
    teletextcodemidline67,
    teletextcodemidline68,
    teletextcodemidline69,
    teletextcodemidline6A,
    teletextcodemidline6B,
    teletextcodemidline6C,
    teletextcodemidline6D,
    teletextcodemidline6E,
    teletextcodemidline6F,
    teletextcodemidline70,
    teletextcodemidline71,
    teletextcodemidline72,
    teletextcodemidline73,
    teletextcodemidline74,
    teletextcodemidline75,
    teletextcodemidline76,
    teletextcodemidline77,
    teletextcodemidline78,
    teletextcodemidline79,
    teletextcodemidline7A,
    teletextcodemidline7B,
    teletextcodemidline7C,
    teletextcodemidline7D,
    teletextcodemidline7E,
    teletextcodemidline7F
  };

  memcpy(hmap->crtctaggedops, crtctaggedops, 256*sizeof(CRTCSTEPOP));

  for (i=0; i<128; i++)
  {
    hmap->teletextops[0x001+(i<<1)] = teletextstartoflineops[i];
    hmap->teletextops[0x100+(i<<1)] = teletextendofline;
    hmap->teletextops[0x101+(i<<1)] = teletextmidlineops[i];
  }

  nclock = clock()+TIME_50HZ;

  hmap->A_crtc.displaycounter = 0;
  hmap->A_crtc.fieldnumber = 0;
  hmap->A_crtc.nextfieldnumber = 0;
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.in_vd = 0;
  hmap->A_crtc.delayvs = 0;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->A_crtc.vs_counting = 0;
  hmap->A_crtc.endframe = ENDFRAMEIDLE;
  hmap->A_crtc.lpstbtimer = 0;

  hmap->A_videoula.shiftregister = 0;

  hmap->A_vidbuf.eventflags = 0;
  hmap->A_vidbuf.fastskipflipflop = 0;
  hmap->A_vidbuf.updateframecounter = 0;
  hmap->A_vidbuf.skip = 0;

  hmap->A_teletext.line = 0;
  hmap->A_teletext.lastline = 9;
  hmap->A_teletext.flipflops = 0;
  hmap->A_teletext.flashstage = 0;
  hmap->A_teletext.flashcounter = 50;

  hmap->B_crtc.step_state = &hmap->crtcstep[VIDEOSTEPIDLEFLAG];
  hmap->B_crtc.cursorcolumn = -1;

  hmap->B_videoula.cursorflags = 0;

  hmap->B_teletext.lutslice = &hmap->teletextlinelut[0];
  hmap->B_teletext.holdlue = hmap->teletextlinelut[0];
  hmap->B_teletext.queue = 0;
  hmap->B_teletext.colours = 0x0707;

  hmap->B_vidbuf.displayskewmask = 0x01;
  hmap->B_vidbuf.cursorskewmask = 0x01;
  hmap->B_vidbuf.limitlinecounter = 0;
  hmap->B_vidbuf.column = 0;
  hmap->B_vidbuf.line = 0;
  hmap->B_vidbuf.linelevel = 0;

  for (i=0; i<255; i++)
  {
    hmap->crtccolumntags[i] = 0;
  }
  hmap->crtccolumntags[255] = CRTCMAXCOLUMNTAG;

  for (i=0; i<256; i++)
  {
    hmap->crtcstep[i] = hmap->crtctaggedops[hmap->crtccolumntags[i]];
  }

  for (i=256; i<512; i++)
  {
    hmap->crtcstep[i] = videoidlestep;
  }
}

HOSTMAP* videotopmiddle(HOSTMAP* hmap)
{
  int skew = (hmap->A_crtc.r[8]>>4)&3;
  intptr_t centrecolumn,offset;

  if (skew == 3)
    skew = 0;

  if (hmap->A_videoula.control & 0x10)
    centrecolumn = hmap->B_vidbuf.column + (hmap->A_crtc.r[1]>>1) + skew;
  else
    centrecolumn = hmap->B_vidbuf.column + hmap->A_crtc.r[1] + (skew<<1);

  if (hmap->A_videoula.control & 2)
    centrecolumn += 4;

  offset = (hmap->B_vidbuf.stopcolumn>>1) - centrecolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn + offset;
  hmap->B_vidbuf.column += offset;

  hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.startline - hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
  hmap->B_vidbuf.line = hmap->B_vidbuf.startline;
  hmap->A_vidbuf.skip &= ~BEFOREDISPLAYSKIPFLAG;
  return hmap;
}

HOSTMAP* videofield(HOSTMAP* hmap)
{
  unsigned char fieldnumber = hmap->A_crtc.nextfieldnumber;
  hmap->A_crtc.fieldnumber = fieldnumber;
  hmap->A_crtc.delayvs = hmap->A_crtc.r[8] & (fieldnumber ^ 1);
  hmap->A_crtc.in_vd = 1;
  hmap->A_crtc.endframe = ENDFRAMEIDLE;
  hmap->A_crtc.c4 = 0;
  hmap->A_crtc.vs_thisrow = 0;
  if ((hmap->A_crtc.r[8] & 3) == 3)
    hmap->A_crtc.c9low = hmap->A_crtc.c9 = fieldnumber;
  else
    hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->B_crtc.row_code = hmap->B_crtc.start_code;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoslowblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line < hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
      hmap->B_vidout.lineop(hmap);
    }

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  return hmap;
}

HOSTMAP* videofastblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line < hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|FASTSKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
      hmap->B_vidout.lineop(hmap);
    }

    skip ^= FASTSKIPFLAG;

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip = CLIPPEDSKIPFLAG | skip;
  return hmap;
}

void videoyield(void)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)&hostmap;
  int clockdiff;

  r6502startyield(cmap);

  /*if (singletask)
  {*/
  /*sync emulated BBC clock with PC clock*/
  if (beebit_cpuspeed == CPU_2MHZ)
  {
    clockdiff = (int)(clock() - nclock);
    if (clockdiff < 0)
    {
      vsync(); /*wait for native screen vsync*/
      do
      {
        clockdiff = (int)(clock() - nclock);
      } while (clockdiff < 0);
    }
    nclock += clockdiff+TIME_50HZ;
  }
  /*}*/
}

HOSTMAP* videoprogressiveblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line <= hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDABOVESKIPFLAG|FRAMETIMESKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress - hmap->B_vidbuf.stride;
      hmap->B_vidout.lineop(hmap);
    }

    skip &= ~CLIPPEDABOVESKIPFLAG;

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip = CLIPPEDBELOWSKIPFLAG|CLIPPEDSKIPFLAG|CLIPPEDABOVESKIPFLAG | skip;
  return hmap;
}

static inline HOSTMAP* videoslowenteringvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip |= VSYNCSKIPFLAG;

  systemviasetca1();

  intptr_t offset = hmap->B_vidbuf.offsetsynccolumn - hmap->B_vidbuf.synccolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.column -= offset;

  if (hmap->B_vidbuf.line < 0)
  {
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
    hmap->B_vidbuf.line = 0;
  }
  return hmap;
}

static inline HOSTMAP* videofastenteringvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip |= VSYNCSKIPFLAG;

  systemviasetca1();

  intptr_t offset = hmap->B_vidbuf.offsetsynccolumn - hmap->B_vidbuf.synccolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.column -= offset;

  if (hmap->B_vidbuf.line < 0)
  {
    if (hmap->B_vidbuf.line & 1)
      hmap->A_vidbuf.skip ^= FASTSKIPFLAG;

    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
    hmap->B_vidbuf.line = 0;
  }
  return hmap;
}

static inline HOSTMAP* videoupdateframetimeskip(HOSTMAP* hmap)
{
  if (hmap->A_vidbuf.updateframenumber > 0)
  {
    if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
    {
      hmap->A_vidbuf.skip |= FRAMETIMESKIPFLAG;
      hmap->A_vidbuf.updateframecounter = 0;
    }
    else
    {
      hmap->A_vidbuf.updateframecounter++;
      if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
      {
        hmap->A_vidbuf.skip &= ~FRAMETIMESKIPFLAG;
      }
    }
  }
  return hmap;
}

static inline HOSTMAP* videoenteringvsynctail(HOSTMAP* hmap)
{
  hmap->B_vidbuf.line = hmap->B_vidbuf.syncline;
  hmap->B_vidbuf.lineaddress = hmap->B_vidbuf.synclineaddress;

  hmap->B_vidbuf.limitlinecounter = 0;

  hmap->A_teletext.line = 0;
  hmap->A_teletext.lastline = 9;

  if (--hmap->A_teletext.flashcounter == 0)
  {
    if (hmap->A_teletext.flashstage & 1)
    {
      hmap->A_teletext.flipflops &= NOTTELETEXTFLASHTIMEFLAG;
      hmap->A_teletext.flashcounter = 50;
    }
    else
    {
      hmap->A_teletext.flipflops |= TELETEXTFLASHTIMEFLAG;
      if (hmap->A_teletext.flashstage)
        hmap->A_teletext.flashcounter = 17;
      else
        hmap->A_teletext.flashcounter = 16;
    }
    if (++hmap->A_teletext.flashstage == 6)
      hmap->A_teletext.flashstage = 0;
  }
  return hmap;
}

static inline HOSTMAP* videoslowleavingvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip &= ~VSYNCSKIPFLAG;

  systemviaunsetca1();

  hmap->B_vidbuf.linelevel = 54 - (hmap->B_vidbuf.column - hmap->B_vidbuf.synccolumn);
  if (hmap->B_vidbuf.linelevel < 0)
  {
    hmap->B_vidbuf.line -= 1;
    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.stride;
    hmap->B_vidbuf.linelevel += 128;
  }
  return hmap;
}

static inline HOSTMAP* videofastleavingvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip &= ~VSYNCSKIPFLAG;

  systemviaunsetca1();

  hmap->B_vidbuf.linelevel = 54 - (hmap->B_vidbuf.column - hmap->B_vidbuf.synccolumn);
  if (hmap->B_vidbuf.linelevel < 0)
  {
    hmap->A_vidbuf.skip ^= FASTSKIPFLAG;
    hmap->B_vidbuf.line -= 1;
    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.stride;
    hmap->B_vidbuf.linelevel += 128;
  }
  return hmap;
}

HOSTMAP* videoslowenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoslowblanklinesdown(hmap);
  videoyield();

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipslowenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoslowblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoslowleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videotopmiddleslowleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videofastenteringvsync(HOSTMAP* hmap)
{
  videofastenteringvsynchead(hmap);
  videofastblanklinesdown(hmap);
  videoyield();

  hmap->A_vidbuf.fastskipflipflop ^= FASTSKIPFLAG;

  hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~FASTSKIPFLAG) | hmap->A_vidbuf.fastskipflipflop;

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipfastenteringvsync(HOSTMAP* hmap)
{
  videofastenteringvsynchead(hmap);
  videofastblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  if (!(hmap->A_vidbuf.skip & FRAMETIMESKIPFLAG))
    hmap->A_vidbuf.fastskipflipflop ^= FASTSKIPFLAG;

  hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~FASTSKIPFLAG) | hmap->A_vidbuf.fastskipflipflop;

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videofastleavingvsync(HOSTMAP* hmap)
{
  videofastleavingvsynchead(hmap);
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videotopmiddlefastleavingvsync(HOSTMAP* hmap)
{
  videofastleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videoprogressiveenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoprogressiveblanklinesdown(hmap);
  videoyield();

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipprogressiveenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoprogressiveblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoprogressiveleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  videorefreshpclippedskipflag(hmap);
  return hmap;
}

HOSTMAP* videotopmiddleprogressiveleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  videorefreshpclippedskipflag(hmap);
  return hmap;
}

static inline int videodummylinerequired(HOSTMAP* hmap)
{
  if (!(hmap->A_crtc.r[8] & 1) || hmap->A_crtc.nextfieldnumber == 0)
    return 0;

  return !(hmap->A_crtc.r[8] & 2) || (hmap->A_crtc.r[9] & 1) == 0 || (hmap->A_crtc.r[4] & 1) != 0;
}

HOSTMAP* videoendframeidle(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  if (hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image)
  {
    if (hmap->A_crtc.r[9] == hmap->A_crtc.r9image)
      hmap->A_crtc.c9 = 0;
    else
    {
      hmap->A_crtc.c9 = hmap->A_crtc.fieldnumber;
      if (!(hmap->A_crtc.r9image&1))
        hmap->A_crtc.c9 ^= (hmap->A_crtc.c4 & 1);
    }
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
    hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
    hmap->A_crtc.vs_thisrow = 0;
  }
  else if (hmap->A_crtc.r[0] > 0)
  {
    hmap->A_crtc.c9 = (hmap->A_crtc.c9 + (hmap->A_crtc.r[9] == hmap->A_crtc.r9image ? 1 : 2)) & 0x1F;
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
  }
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoendframesoon(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  hmap->A_crtc.endframe = ENDFRAMENOADJUST;
  return hmap;
}

HOSTMAP* videoendframenoadjust(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  return hmap;
}

HOSTMAP* videoendframeadjust(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  hmap->A_crtc.endframe = ENDFRAMEADJUSTING;
  return hmap;
}

HOSTMAP* videoendframeadjusting(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  if (hmap->A_crtc.r[0] > 0)
  {
    hmap->A_crtc.c9 = (hmap->A_crtc.c9 + 1) & 0x1F;
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
  }
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoendframeadjustcomplete(HOSTMAP* hmap)
{
  if (videodummylinerequired(hmap))
  {
    hmap->A_crtc.in_firstline = 0;
    if (hmap->A_crtc.r[0] > 0)
    {
      hmap->A_crtc.c9 = (hmap->A_crtc.c9 + 1) & 0x1F;
      hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
    }
    hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
    hmap->A_crtc.endframe = ENDFRAMEDUMMY;
  }
  else
  {
    videofield(hmap);
    hmap->A_crtc.in_firstline = 1;
  }
  return hmap;
}

HOSTMAP* videoendframedummy(HOSTMAP* hmap)
{
  videofield(hmap);
  hmap->A_crtc.in_firstline = 1;
  return hmap;
}

HOSTMAP* videosetscreenstartindex(HOSTMAP* hmap, uint8_t index)
{
  hmap->screenstartindex = index;

  videosetreadfour(&hmap->videoreads[1], &hmap->videographicswrapreads[index<<2]);
  videosetreadfour(&hmap->videoreads[3], &hmap->videoteletextwrapreads[index<<2]);
  return hmap;
}

R6502ZONEMAP* videodisplayoutleft(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  intptr_t column = hmap->B_vidbuf.column + 1;
  hmap->B_vidbuf.column = column;

  if (column >= 0)
    hmap->peripheral_code &= ~VIDEODISPLAYADVANCEMASK;
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

R6502ZONEMAP* videodisplayoutright(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  intptr_t column = hmap->B_vidbuf.column + 1;
  hmap->B_vidbuf.column = column;

  if (column >= hmap->B_vidbuf.limitcolumn)
    hmap->peripheral_code ^= (VIDEODISPLAYSTOP^VIDEODISPLAYOUTRIGHT);
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videoprogressiveleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDABOVESKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress - hmap->B_vidbuf.stride;
    hmap->B_vidout.lineop(hmap);
  }

  if (skip & CLIPPEDSKIPFLAG)
    skip |= CLIPPEDABOVESKIPFLAG;
  else
    skip &= ~CLIPPEDABOVESKIPFLAG;

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
    skip &= ~(CLIPPEDSKIPFLAG|CLIPPEDBELOWSKIPFLAG);
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    skip |= (CLIPPEDSKIPFLAG|CLIPPEDBELOWSKIPFLAG);

  if (hmap->B_vidbuf.line == -1)
    skip &= ~CLIPPEDBELOWSKIPFLAG;
  else if (hmap->B_vidbuf.line + 1 >= hmap->B_vidbuf.stopline)
    skip |= CLIPPEDBELOWSKIPFLAG;
  hmap->A_vidbuf.skip = skip;
  hmap->peripheral_code = videoupdatepskipbit(hmap->peripheral_code, skip);
  return hmap;
}

R6502ZONEMAP* videodisplayprogressivestop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videoprogressiveleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG)|CLIPPEDABOVESKIPFLAG;

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videoprogressiveblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videofastleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG|FASTSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
    hmap->B_vidout.lineop(hmap);
  }

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
    skip &= ~CLIPPEDSKIPFLAG;
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    skip |= CLIPPEDSKIPFLAG;
  skip ^= FASTSKIPFLAG;
  hmap->A_vidbuf.skip = skip;
  hmap->peripheral_code = videoupdateskipbit(hmap->peripheral_code, skip);
  return hmap;
}

R6502ZONEMAP* videodisplayfaststop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videofastleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        if (hmap->B_vidbuf.line&1)
          hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG)^FASTSKIPFLAG;
        else
          hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG);

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videofastblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videoslowleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
    hmap->B_vidout.lineop(hmap);
  }

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
  {
    if (skip == CLIPPEDSKIPFLAG)
      hmap->peripheral_code &= ~VIDEODISPLAYSKIP;
    hmap->A_vidbuf.skip = skip & ~CLIPPEDSKIPFLAG;
  }
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
  {
    if (!skip)
      hmap->peripheral_code |= VIDEODISPLAYSKIP;
    hmap->A_vidbuf.skip = skip | CLIPPEDSKIPFLAG;
  }
  return hmap;
}

R6502ZONEMAP* videodisplayslowstop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videoslowleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videoslowblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

R6502ZONEMAP* videodisplaysyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  uint8_t skip = hmap->A_vidbuf.skip;

  if (skip & VSYNCSKIPFLAG)
  {
    if (!hmap->A_crtc.vs_delayed == !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.leavingvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }
  else
  {
    if (!hmap->A_crtc.vs_delayed != !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.enteringvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }

  if (skip & HSYNCSKIPFLAG)
  {
    if (!(hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC))
    {
      skip &= ~HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->blacklevelops[peripheral_code&7](zmap, peripheral_code);
    }
  }
  else
  {
    if (hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC)
    {
      skip |= HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_vidbuf.linelevel += hmap->B_vidbuf.column - hmap->B_vidbuf.offsetsynccolumn;
      hmap->B_vidbuf.column = hmap->B_vidbuf.offsetsynccolumn;
    }
  }

  peripheral_code = videoupdateadvanceandskipbits(hmap, peripheral_code & ~VIDEODISPLAYSYNCEDGE, skip);
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplaypsyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  uint8_t skip = hmap->A_vidbuf.skip;

  if (skip & VSYNCSKIPFLAG)
  {
    if (!hmap->A_crtc.vs_delayed == !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.leavingvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }
  else
  {
    if (!hmap->A_crtc.vs_delayed != !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.enteringvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }

  if (skip & HSYNCSKIPFLAG)
  {
    if (!(hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC))
    {
      skip &= ~HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->blacklevelops[peripheral_code&7](zmap, peripheral_code);
    }
  }
  else
  {
    if (hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC)
    {
      skip |= HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_vidbuf.linelevel += hmap->B_vidbuf.column - hmap->B_vidbuf.offsetsynccolumn;
      hmap->B_vidbuf.column = hmap->B_vidbuf.offsetsynccolumn;
    }
  }

  peripheral_code = videoupdatepadvanceandskipbits(hmap, peripheral_code & ~VIDEODISPLAYSYNCEDGE, skip);
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplaypossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  if (hmap->A_crtc.in_vd && !(hmap->A_vidbuf.skip & VSYNCSKIPFLAG))
  {
    videotopmiddle(hmap);
    videorefreshclippedskipflag(hmap);
    peripheral_code = videoupdateadvanceandskipbits(hmap, peripheral_code, hmap->A_vidbuf.skip);
  }

  peripheral_code &= ~VIDEODISPLAYPOSSIBLESTART;
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplayppossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  if (hmap->A_crtc.in_vd && !(hmap->A_vidbuf.skip & VSYNCSKIPFLAG))
  {
    videotopmiddle(hmap);
    videorefreshpclippedskipflag(hmap);
    peripheral_code = videoupdatepadvanceandskipbits(hmap, peripheral_code, hmap->A_vidbuf.skip);
  }

  peripheral_code &= ~VIDEODISPLAYPOSSIBLESTART;
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

static inline void videostartvsyncdelay(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[0]>>1;

  tags = hmap->crtccolumntags[value] |= CRTCONHALFR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  hmap->A_crtc.vs_delayed = 1;
}

static inline HOSTMAP* videoendvsyncdelay(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[0]>>1;

  tags = hmap->crtccolumntags[value] &= ~CRTCONHALFR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  hmap->A_crtc.vs_delayed = 0;

  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  return hmap;
}

static inline HOSTMAP* videostartvsync(HOSTMAP* hmap)
{
  hmap->A_crtc.c3v = 0;
  hmap->A_crtc.vs_counting = 1;
  hmap->A_crtc.vs_thisrow = 1;

  if (hmap->A_crtc.delayvs)
    videostartvsyncdelay(hmap);
  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  return hmap;
}

static inline HOSTMAP* videoendvdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.nextfieldnumber = hmap->A_crtc.fieldnumber^1;
  hmap->A_crtc.displaycounter += 1;
  hmap->A_crtc.in_vd = 0;
  return hmap;
}

static inline HOSTMAP* videoendhdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.displaybuffer &= ~VIDEODISPLAYSIGNALINPUT;
  hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  return hmap;
}

static inline HOSTMAP* videoendhdisplaycheckingforendofrow(HOSTMAP* hmap)
{
  if (hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image)
    hmap->B_crtc.row_code = hmap->B_crtc.scan_code & 0xFFFC0000;

  return videoendhdisplay(hmap);
}

static inline HOSTMAP* videostarthdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.displaybuffer |= VIDEODISPLAYSIGNALINPUT;
  hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  return hmap;
}

static inline HOSTMAP* videoclearrowtestcolumntag(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  uintptr_t tags;
  uint8_t column = (uint8_t)(((CRTCSTEPOP*)incremented_step_state) - 1 - hmap->crtcstep);

  tags = hmap->crtccolumntags[column] & ~CRTCROWTESTCOLUMNTAG;
  hmap->crtcstep[column] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[column] = tags;
  return hmap;
}

static inline HOSTMAP* videotestrowregisters(HOSTMAP* hmap)
{
  if (hmap->A_crtc.in_vd && hmap->A_crtc.c4 == hmap->A_crtc.r[6] && !hmap->A_crtc.in_firstline)
  {
    videoendvdisplay(hmap);

    if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
      videoendhdisplay(hmap);
  }

  if (hmap->A_crtc.c4 == hmap->A_crtc.r[7] && !hmap->A_crtc.vs_counting && !hmap->A_crtc.vs_thisrow)
    videostartvsync(hmap);

  return hmap;
}

static inline HOSTMAP* videocountvsyncline(HOSTMAP* hmap)
{
  hmap->A_crtc.c3v = (hmap->A_crtc.c3v + 1) & 0xF;
  if (hmap->A_crtc.c3v == ((hmap->A_crtc.r[3]>>4) & 0xF))
  {
    hmap->A_crtc.vs_counting = 0;

    if (hmap->A_crtc.delayvs)
      videostartvsyncdelay(hmap);
    hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  }
  return hmap;
}

static inline HOSTMAP* videoendofline(HOSTMAP* hmap)
{
  hmap->endoflineactions[hmap->A_crtc.endframe](hmap);
  hmap->A_vidbuf.linetestflags |= VIDEOSTEPLINETEST0;
  hmap->B_crtc.scan_code |= VIDEOREADLINETESTFLAG;
  return hmap;
}

static inline HOSTMAP* videostarthsync(HOSTMAP* hmap)
{
  hmap->A_crtc.c3h = 0xF;
  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  hmap->A_vidbuf.eventflags |= VIDEOSTEPEVENTHSYNC;
  hmap->B_crtc.scan_code |= VIDEOREADEVENTFLAG;
  return hmap;
}

static inline HOSTMAP* videoincrementscancode(HOSTMAP* hmap)
{
  hmap->B_crtc.scan_code = (hmap->B_crtc.scan_code + 0x40000) & 0xFFFFFFFF;
  return hmap;
}

static inline HOSTMAP* videolinestart(HOSTMAP* hmap)
{
  uint8_t in_display;

  if (hmap->A_crtc.vs_delayed)
    videoendvsyncdelay(hmap);

  if (hmap->A_crtc.vs_counting)
    videocountvsyncline(hmap);

  videoendofline(hmap);

  in_display = hmap->A_crtc.in_vd;

  if (in_display)
  {
    if (hmap->A_crtc.c4 == hmap->A_crtc.r[6] && !hmap->A_crtc.in_firstline)
    {
      videoendvdisplay(hmap);
      in_display = 0;
    }
    else if ((0 == hmap->A_crtc.r[0]) || (0 == hmap->A_crtc.r[1]))
      in_display = 0;
  }

  if (in_display)
  {
    if (!(hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT))
      videostarthdisplay(hmap);
  }
  else if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
  {
    videoendhdisplay(hmap);
  }

  if (hmap->A_crtc.c4 == hmap->A_crtc.r[7] && !hmap->A_crtc.vs_counting && !hmap->A_crtc.vs_thisrow)
    videostartvsync(hmap);

  if (0 == hmap->A_crtc.r[2])
    videostarthsync(hmap);

  return hmap;
}

static inline HOSTMAP* videolineoverflow(HOSTMAP* hmap)
{
  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
  {
    if ((0 == hmap->A_crtc.r[0]) || (0 == hmap->A_crtc.r[1]))
      videoendhdisplay(hmap);
  }

  if (0 == hmap->A_crtc.r[2])
    videostarthsync(hmap);

  return hmap;
}

static inline void videocursorcolumnhit(HOSTMAP* hmap)
{
  uintptr_t cursorsignal;
  int cursordisplay;
  int c9,cstart,cstop;

  cursordisplay = 0;
  switch (hmap->A_crtc.r[10] & 0x60)
  {
    case 0x00:
      cursordisplay = 1;
      break;
    case 0x40:
      if (!(hmap->A_crtc.displaycounter & 8))
        cursordisplay = 1;
      break;
    case 0x60:
      if (!(hmap->A_crtc.displaycounter & 16))
        cursordisplay = 1;
      break;
  }
  if (cursordisplay)
  {
    c9 = hmap->A_crtc.c9;
    cstart = hmap->A_crtc.r[10]&0x1F;
    cstop = hmap->A_crtc.r[11];
    if (c9 >= cstart && c9 <= cstop)
      cursorsignal = VIDEOCURSORSIGNALINPUT;
    else
      cursorsignal = 0;
    if (hmap->A_vidbuf.progressive)
    {
      c9 -= 1;
      if (c9 >= cstart && c9 <= cstop)
      {
        cursorsignal |= (VIDEOCURSORSIGNALINPUT<<VIDEOCURSORSIGNALABOVESHIFT);
      }
      c9 += 2;
      if (c9 >= cstart && c9 <= cstop)
      {
        cursorsignal |= (VIDEOCURSORSIGNALINPUT<<VIDEOCURSORSIGNALBELOWSHIFT);
      }
    }
    if (cursorsignal != 0)
    {
      hmap->B_crtc.cursorbuffer |= cursorsignal;
      hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
    }
  }
}

static inline void videolinestarttagcursorcolumn(HOSTMAP* hmap)
{
  uintptr_t tags;
  intptr_t column = hmap->B_crtc.cursorcolumn;

  if (column > 0)
  {
    column--;
    tags = hmap->crtccolumntags[column] & ~CRTCBEFORECURSORCOLUMNTAG;
    hmap->crtcstep[column] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[column] = tags;
  }

  column = hmap->B_crtc.cursoraddress - (hmap->B_crtc.scan_code>>18);

  if (column > 0 && column <= 256)
  {
    hmap->B_crtc.cursorcolumn = column;
    column--;
    tags = hmap->crtccolumntags[column] | CRTCBEFORECURSORCOLUMNTAG;
    hmap->crtcstep[column] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[column] = tags;
  }
  else
  {
    hmap->B_crtc.cursorcolumn = -1;

    if (column == 0 && (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT))
      videocursorcolumnhit(hmap);
  }
}

static inline HOSTMAP* videoreadop(HOSTMAP* hmap)
{
  uintptr_t scan_code;

  scan_code = hmap->B_crtc.scan_code;
  return hmap->videoreads[((scan_code&0x3F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoupdateTMstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolineoverflow(hmap);
  videotestrowregisters(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTR0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolinestart(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateMstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolineoverflow(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateR0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolinestart(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdatestep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoidlestep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  uintptr_t scan_code = hmap->B_crtc.scan_code;
  return hmap->videoreads[((scan_code&0x03)<<2)|(scan_code>>30)](hmap, scan_code);
}

static inline uintptr_t videoupdatedisplaysignal(HOSTMAP* hmap, uintptr_t displaybuffer)
{
  uintptr_t peripheral_code;

  if (displaybuffer & hmap->B_vidbuf.displayskewmask)
  {
    peripheral_code = hmap->peripheral_code;
    if (!(peripheral_code & VIDEODISPLAYDISPLAY))
    {
      hmap->peripheral_code = peripheral_code | VIDEODISPLAYDISPLAY;
      if (!(hmap->B_crtc.scan_code & VIDEOREADODDFLAG))
        hmap->B_teletext.queue |= (64<<8);
    }
  }
  else
    hmap->peripheral_code &= ~VIDEODISPLAYDISPLAY;
  return displaybuffer;
}

static inline uintptr_t videoupdatecursorsignal(HOSTMAP* hmap, uintptr_t cursorbuffer)
{
  if (cursorbuffer & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~VIDEOCURSORSIGNALSEGMENTS)|VIDEOCURSORSIGNALSEGMENT0;
  if (cursorbuffer & VIDEOCURSORSIGNALSEGMENTS)
    hmap->peripheral_code |= VIDEODISPLAYCURSOR;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYCURSOR;
  return cursorbuffer;
}

static inline uintptr_t videoupdatepcursorsignal(HOSTMAP* hmap, uintptr_t cursorbuffer)
{
  if (cursorbuffer & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~VIDEOCURSORSIGNALSEGMENTS)|VIDEOCURSORSIGNALSEGMENT0;
  if ((cursorbuffer>>VIDEOCURSORSIGNALABOVESHIFT) & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~(VIDEOCURSORSIGNALSEGMENTS<<VIDEOCURSORSIGNALABOVESHIFT))|(VIDEOCURSORSIGNALSEGMENT0<<VIDEOCURSORSIGNALABOVESHIFT);
  if ((cursorbuffer>>VIDEOCURSORSIGNALBELOWSHIFT) & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~(VIDEOCURSORSIGNALSEGMENTS<<VIDEOCURSORSIGNALBELOWSHIFT))|(VIDEOCURSORSIGNALSEGMENT0<<VIDEOCURSORSIGNALBELOWSHIFT);
  if (cursorbuffer & VIDEOCURSORSIGNALPSEGMENTS)
    hmap->peripheral_code |= VIDEODISPLAYCURSOR;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYCURSOR;
  return cursorbuffer;
}

static inline HOSTMAP* videosetskewmasks(HOSTMAP* hmap, uint8_t r8)
{
  if ((r8 & 0x30) == 0x30)
    hmap->B_vidbuf.displayskewmask = 0;
  else
    hmap->B_vidbuf.displayskewmask = (VIDEODISPLAYSIGNALSKEW0>>((r8>>4)&0x3));
  if ((r8 & 0xC0) == 0xC0)
    hmap->B_vidbuf.cursorskewmask = 0;
  else
    hmap->B_vidbuf.cursorskewmask = (VIDEOCURSORSIGNALSKEW0>>((r8>>6)&0x3));
  return hmap;
}

HOSTMAP* videoreadevent(HOSTMAP* hmap, uintptr_t scan_code)
{
  uint8_t r3h;
  uint8_t eventflags = hmap->A_vidbuf.eventflags;

  if (eventflags & VIDEOSTEPEVENTHSYNC)
  {
    hmap->A_crtc.c3h = (hmap->A_crtc.c3h + 1) & 0xF;
    r3h = hmap->A_crtc.r[3] & 0xF;
    if (hmap->A_crtc.c3h == r3h)
    {
      hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
      eventflags &= ~VIDEOSTEPEVENTHSYNC;
      hmap->A_vidbuf.eventflags = eventflags;
    }
  }

  if (eventflags & VIDEOSTEPEVENTLPSTB)
  {
    hmap->A_crtc.lpstbtimer--;
    if (hmap->A_crtc.lpstbtimer == 0)
    {
      hmap->A_crtc.r[16] = scan_code>>26;
      hmap->A_crtc.r[17] = (scan_code>>18)&0xFF;
      eventflags &= ~VIDEOSTEPEVENTLPSTB;
      hmap->A_vidbuf.eventflags = eventflags;
    }
  }

  if (!eventflags)
    scan_code &= ~VIDEOREADEVENTFLAG;

  return hmap->videoreads[((scan_code&0x1F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadlinetest(HOSTMAP* hmap, uintptr_t scan_code)
{
  uint8_t linetestflags = hmap->A_vidbuf.linetestflags;
  uint8_t linetestflagsnext = (linetestflags>>1);

  hmap->A_vidbuf.linetestflags = linetestflagsnext;

  if (!linetestflagsnext)
    scan_code &= ~VIDEOREADLINETESTFLAG;

  if (linetestflags & VIDEOSTEPLINETEST3)
  {
    if (hmap->A_crtc.endframe == ENDFRAMENOADJUST)
      hmap->A_crtc.endframe = ENDFRAMEADJUSTCOMPLETE;
  }

  if (linetestflags & VIDEOSTEPLINETEST2)
  {
    if (hmap->A_crtc.endframe == ENDFRAMESOON)
    {
      if (0 == hmap->A_crtc.r[5])
        hmap->A_crtc.endframe = ENDFRAMENOADJUST;
      else
        hmap->A_crtc.endframe = ENDFRAMEADJUST;
    }
    else if (hmap->A_crtc.endframe == ENDFRAMEADJUSTING)
    {
      if (((hmap->A_crtc.c9 + 1) & 0x1F) == hmap->A_crtc.r[5])
        hmap->A_crtc.endframe = ENDFRAMENOADJUST;
    }
  }

  if (linetestflags & VIDEOSTEPLINETEST1)
  {
    if (hmap->A_crtc.endframe == ENDFRAMEIDLE)
    {
      if ((hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image) && hmap->A_crtc.c4 == hmap->A_crtc.r[4])
      {
        hmap->A_crtc.endframe = ENDFRAMESOON;
      }
    }
  }

  if (linetestflags & VIDEOSTEPLINETEST0)
  {
    if (hmap->A_vidbuf.skip & BEFOREDISPLAYSKIPFLAG)
      hmap->peripheral_code |= VIDEODISPLAYPOSSIBLESTART;
  }
  return hmap->videoreads[((scan_code&0x0F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadcursorsignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t cursorbuffer = hmap->B_crtc.cursorbuffer;

  cursorbuffer = (cursorbuffer>>1) & ~VIDEOCURSORSIGNALSTOPS;
  cursorbuffer = videoupdatecursorsignal(hmap, cursorbuffer);

  if (!cursorbuffer)
    scan_code &= ~VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;
  return hmap->videoreads[((scan_code&0x07)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadpcursorsignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t cursorbuffer = hmap->B_crtc.cursorbuffer;

  cursorbuffer = (cursorbuffer>>1) & ~VIDEOCURSORSIGNALPSTOPS;
  cursorbuffer = videoupdatepcursorsignal(hmap, cursorbuffer);

  if (!cursorbuffer)
    scan_code &= ~VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;
  return hmap->videoreads[((scan_code&0x07)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreaddisplaysignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t displaybuffer = hmap->A_crtc.displaybuffer;

  displaybuffer = (displaybuffer&VIDEODISPLAYSIGNALINPUT) | ((displaybuffer>>1) & ~VIDEOCURSORSIGNALSTOPS);
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer == 0x00000000 || displaybuffer == 0x0000000F)
    scan_code &= ~VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;
  return hmap->videoreads[((scan_code&0x03)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoinactivesetskew(HOSTMAP* hmap, uint8_t r8)
{
  return videosetskewmasks(hmap, r8);
}

HOSTMAP* videosetskew(HOSTMAP* hmap, uint8_t r8)
{
  uintptr_t displaybuffer;
  uintptr_t cursorbuffer;

  videosetskewmasks(hmap, r8);

  displaybuffer = hmap->A_crtc.displaybuffer;
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer != 0x00000000 && displaybuffer != 0x00000007)
    hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorbuffer = videoupdatecursorsignal(hmap, cursorbuffer);

  if (cursorbuffer)
    hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;

  return hmap;
}

HOSTMAP* videoprogressivesetskew(HOSTMAP* hmap, uint8_t r8)
{
  uintptr_t displaybuffer;
  uintptr_t cursorbuffer;

  videosetskewmasks(hmap, r8);

  displaybuffer = hmap->A_crtc.displaybuffer;
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer != 0x00000000 && displaybuffer != 0x00000007)
    hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorbuffer = videoupdatepcursorsignal(hmap, cursorbuffer);

  if (cursorbuffer)
    hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;

  return hmap;
}

static HOSTMAP* videoevenRloadintercept(HOSTMAP* hmap, uintptr_t value)
{
  VIDEOULALOADOP evenloadop = hmap->B_videoula.selectedevenloadop;
  VIDEOULALOADOP evenRloadop = hmap->B_videoula.selectedevenRloadop;

  hmap->B_videoula.selectedevenloadop = evenRloadop;
  hmap->B_videoula.evenloadop(hmap, value);
  hmap->B_videoula.evenloadop = hmap->B_videoula.selectedevenloadop = evenloadop;
  return hmap;
}

static inline void videoapplyevenloadintercept(HOSTMAP* hmap, VIDEOULALOADOP intercept)
{
  hmap->B_videoula.evenloadop = intercept;
  hmap->B_videoula.evenRloadop = videoevenRloadintercept;
}

static inline HOSTMAP* videocallinterceptedevenload(HOSTMAP* hmap, uintptr_t value)
{
  VIDEOULALOADOP evenloadop = hmap->B_videoula.selectedevenloadop;
  VIDEOULALOADOP evenRloadop = hmap->B_videoula.selectedevenRloadop;

  hmap->B_videoula.evenloadop = evenloadop;
  hmap->B_videoula.evenRloadop = evenRloadop;
  return evenloadop(hmap, value);
}

static inline void teletextlinestart(HOSTMAP* hmap)
{
  hmap->B_teletext.colours |= 0x07;
  hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[7];
}

static inline void teletextafteralpha(HOSTMAP* hmap, const int colour)
{
  intptr_t* lutslice;
  uint8_t flipflops = hmap->A_teletext.flipflops;

  if (flipflops&TELETEXTGRAPHICFLAG)
  {
    lutslice = hmap->B_teletext.lutslice;
    if (flipflops&TELETEXTSEPARATEDFLAG)
      lutslice -= 40;
    else
      lutslice -= 20;
    hmap->B_teletext.lutslice = lutslice;
    hmap->B_teletext.holdlue = hmap->teletextlinelut[0];
  }
  flipflops &= (NOTTELETEXTCONCEALFLAG&NOTTELETEXTGRAPHICFLAG);
  hmap->A_teletext.flipflops = flipflops;
  hmap->B_teletext.colours = (hmap->B_teletext.colours & ~0x07) | colour;

  if (flipflops <= TELETEXTCONCEALTHRESHOLD)
    hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[colour];
}

static inline void teletextaftergraphic(HOSTMAP* hmap, const int colour)
{
  intptr_t* lutslice;
  uint8_t flipflops = hmap->A_teletext.flipflops;

  if (!(flipflops&TELETEXTGRAPHICFLAG))
  {
    lutslice = hmap->B_teletext.lutslice;
    if (flipflops&TELETEXTSEPARATEDFLAG)
      lutslice += 40;
    else
      lutslice += 20;
    hmap->B_teletext.lutslice = lutslice;
    hmap->B_teletext.holdlue = hmap->B_teletext.lutslice[0];
    flipflops |= TELETEXTGRAPHICFLAG;
  }
  flipflops &= NOTTELETEXTCONCEALFLAG;
  hmap->A_teletext.flipflops = flipflops;
  hmap->B_teletext.colours = (hmap->B_teletext.colours & ~0x07) | colour;

  if (flipflops <= TELETEXTCONCEALTHRESHOLD)
    hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[colour];
}

static HOSTMAP* teletextafteralphared(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 1);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphagreen(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 2);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphayellow(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 3);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphablue(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 4);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphamagenta(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 5);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphacyan(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 6);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafteralphawhite(HOSTMAP* hmap, uintptr_t value)
{
  teletextafteralpha(hmap, 7);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicred(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 1);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicgreen(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 2);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicyellow(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 3);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicblue(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 4);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicmagenta(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 5);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphiccyan(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 6);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextaftergraphicwhite(HOSTMAP* hmap, uintptr_t value)
{
  teletextaftergraphic(hmap, 7);
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafterflash(HOSTMAP* hmap, uintptr_t value)
{
  uint8_t flipflops = hmap->A_teletext.flipflops | TELETEXTFLASHFLAG;
  hmap->A_teletext.flipflops = flipflops;
  if (flipflops > TELETEXTCONCEALTHRESHOLD)
    hmap->B_teletext.fg1fill = hmap->B_teletext.bg1fill;
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafterdoubleheight(HOSTMAP* hmap, uintptr_t value)
{
  uint8_t flipflops = hmap->A_teletext.flipflops;

  if (!(flipflops&TELETEXTDOUBLEHEIGHTFLAG))
  {
    hmap->A_teletext.flipflops = flipflops | TELETEXTDOUBLEHEIGHTFLAG;
    hmap->B_teletext.lutslice += 60;
    hmap->B_teletext.holdlue = hmap->teletextlinelut[0];
    hmap->A_teletext.lastline = 19;
  }
  return videocallinterceptedevenload(hmap, value);
}

static HOSTMAP* teletextafterreleasegraphics(HOSTMAP* hmap, uintptr_t value)
{
  hmap->A_teletext.flipflops &= NOTTELETEXTHOLDFLAG;
  return videocallinterceptedevenload(hmap, value);
}

static inline HOSTMAP* teletextcontrolcommon(HOSTMAP* hmap)
{
  intptr_t holdlue;

  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;
  if (hmap->A_teletext.flipflops & TELETEXTHOLDFLAG)
    holdlue = hmap->B_teletext.holdlue;
  else
  {
    holdlue = hmap->teletextlinelut[0];
    hmap->B_teletext.holdlue = holdlue;
  }
  hmap->B_teletext.lue1 = holdlue;
  return hmap;
}

static inline HOSTMAP* teletextdisplaypossiblegraphic(HOSTMAP* hmap, const int index)
{
  intptr_t lue;

  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;
  lue = hmap->B_teletext.lutslice[(index<<7)+hmap->A_teletext.line];
  hmap->B_teletext.lue1 = lue;
  if (hmap->A_teletext.flipflops&TELETEXTGRAPHICFLAG)
    hmap->B_teletext.holdlue = lue;
  return hmap;
}

static inline HOSTMAP* teletextdisplaynotgraphic(HOSTMAP* hmap, const int index)
{
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;
  hmap->B_teletext.lue1 = hmap->B_teletext.lutslice[(index<<7)+hmap->A_teletext.line];
  return hmap;
}

HOSTMAP* teletextnoponeslice(HOSTMAP* hmap)
{
  return hmap;
}

HOSTMAP* teletextnoprounding(HOSTMAP* hmap)
{
  hmap->B_teletext.lue1 = hmap->teletextlinelut[0];
  return hmap;
}

HOSTMAP* teletextendofline(HOSTMAP* hmap)
{
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;
  hmap->B_teletext.lue1 = hmap->teletextlinelut[0];
  hmap->B_teletext.holdlue = hmap->teletextlinelut[0];
  hmap->B_teletext.colours &= 0xFF00;
  hmap->B_teletext.bg1fill = hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[0];

  hmap->A_teletext.flipflops &= TELETEXTFLASHTIMEFLAG;
  hmap->B_teletext.lutslice = &hmap->teletextlinelut[0];

  if (hmap->A_teletext.line < hmap->A_teletext.lastline)
    hmap->A_teletext.line++;
  else
  {
    hmap->A_teletext.line = 0;
    hmap->A_teletext.lastline = 9;
  }
  return hmap;
}

HOSTMAP* teletextcodestartofline00(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline01(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphared);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline02(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphagreen);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline03(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphayellow);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline04(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphablue);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline05(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphamagenta);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline06(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafteralphacyan);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline08(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafterflash);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline0D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextafterdoubleheight);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline11(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicred);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline12(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicgreen);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline13(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicyellow);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline14(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicblue);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline15(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicmagenta);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline16(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphiccyan);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline17(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  videoapplyevenloadintercept(hmap, teletextaftergraphicwhite);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline18(HOSTMAP* hmap)
{
  /*conceal*/
  hmap->B_teletext.colours |= 0x07;
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline1A(HOSTMAP* hmap)
{
  /*separated*/
  uint8_t flipflops;
  teletextlinestart(hmap);
  flipflops = hmap->A_teletext.flipflops;
  if (!(flipflops & TELETEXTSEPARATEDFLAG))
  {
    hmap->A_teletext.flipflops = flipflops | TELETEXTSEPARATEDFLAG;
    if (flipflops & TELETEXTGRAPHICFLAG)
      hmap->B_teletext.lutslice += 20;
  }
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline1D(HOSTMAP* hmap)
{
  hmap->B_teletext.colours |= 0x77;
  hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[7];
  hmap->B_teletext.bg1fill = hmap->B_teletext.colourfill[7];
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline1E(HOSTMAP* hmap)
{
  /*hold graphics*/
  /*hold/release graphics actually affects the way colour-change*/
  /*codes are displayed. normally they are blank; when hold graphics*/
  /*is set, the previous character is displayed again. This allows*/
  /*contiguous blocks of colour.*/
  /*Thanks to Tom Seddon for that bit of information...*/
  teletextlinestart(hmap);
  hmap->A_teletext.flipflops |= TELETEXTHOLDFLAG;
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodestartofline20(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x00);
}

HOSTMAP* teletextcodestartofline21(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x01);
}

HOSTMAP* teletextcodestartofline22(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x02);
}

HOSTMAP* teletextcodestartofline23(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x03);
}

HOSTMAP* teletextcodestartofline24(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x04);
}

HOSTMAP* teletextcodestartofline25(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x05);
}

HOSTMAP* teletextcodestartofline26(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x06);
}

HOSTMAP* teletextcodestartofline27(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x07);
}

HOSTMAP* teletextcodestartofline28(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x08);
}

HOSTMAP* teletextcodestartofline29(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x09);
}

HOSTMAP* teletextcodestartofline2A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0A);
}

HOSTMAP* teletextcodestartofline2B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0B);
}

HOSTMAP* teletextcodestartofline2C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0C);
}

HOSTMAP* teletextcodestartofline2D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0D);
}

HOSTMAP* teletextcodestartofline2E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0E);
}

HOSTMAP* teletextcodestartofline2F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x0F);
}

HOSTMAP* teletextcodestartofline30(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x10);
}

HOSTMAP* teletextcodestartofline31(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x11);
}

HOSTMAP* teletextcodestartofline32(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x12);
}

HOSTMAP* teletextcodestartofline33(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x13);
}

HOSTMAP* teletextcodestartofline34(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x14);
}

HOSTMAP* teletextcodestartofline35(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x15);
}

HOSTMAP* teletextcodestartofline36(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x16);
}

HOSTMAP* teletextcodestartofline37(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x17);
}

HOSTMAP* teletextcodestartofline38(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x18);
}

HOSTMAP* teletextcodestartofline39(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x19);
}

HOSTMAP* teletextcodestartofline3A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1A);
}

HOSTMAP* teletextcodestartofline3B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1B);
}

HOSTMAP* teletextcodestartofline3C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1C);
}

HOSTMAP* teletextcodestartofline3D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1D);
}

HOSTMAP* teletextcodestartofline3E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1E);
}

HOSTMAP* teletextcodestartofline3F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x1F);
}

HOSTMAP* teletextcodestartofline40(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x20);
}

HOSTMAP* teletextcodestartofline41(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x21);
}

HOSTMAP* teletextcodestartofline42(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x22);
}

HOSTMAP* teletextcodestartofline43(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x23);
}

HOSTMAP* teletextcodestartofline44(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x24);
}

HOSTMAP* teletextcodestartofline45(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x25);
}

HOSTMAP* teletextcodestartofline46(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x26);
}

HOSTMAP* teletextcodestartofline47(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x27);
}

HOSTMAP* teletextcodestartofline48(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x28);
}

HOSTMAP* teletextcodestartofline49(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x29);
}

HOSTMAP* teletextcodestartofline4A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2A);
}

HOSTMAP* teletextcodestartofline4B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2B);
}

HOSTMAP* teletextcodestartofline4C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2C);
}

HOSTMAP* teletextcodestartofline4D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2D);
}

HOSTMAP* teletextcodestartofline4E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2E);
}

HOSTMAP* teletextcodestartofline4F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x2F);
}

HOSTMAP* teletextcodestartofline50(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x30);
}

HOSTMAP* teletextcodestartofline51(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x31);
}

HOSTMAP* teletextcodestartofline52(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x32);
}

HOSTMAP* teletextcodestartofline53(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x33);
}

HOSTMAP* teletextcodestartofline54(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x34);
}

HOSTMAP* teletextcodestartofline55(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x35);
}

HOSTMAP* teletextcodestartofline56(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x36);
}

HOSTMAP* teletextcodestartofline57(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x37);
}

HOSTMAP* teletextcodestartofline58(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x38);
}

HOSTMAP* teletextcodestartofline59(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x39);
}

HOSTMAP* teletextcodestartofline5A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3A);
}

HOSTMAP* teletextcodestartofline5B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3B);
}

HOSTMAP* teletextcodestartofline5C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3C);
}

HOSTMAP* teletextcodestartofline5D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3D);
}

HOSTMAP* teletextcodestartofline5E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3E);
}

HOSTMAP* teletextcodestartofline5F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaynotgraphic(hmap, 0x3F);
}

HOSTMAP* teletextcodestartofline60(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x40);
}

HOSTMAP* teletextcodestartofline61(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x41);
}

HOSTMAP* teletextcodestartofline62(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x42);
}

HOSTMAP* teletextcodestartofline63(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x43);
}

HOSTMAP* teletextcodestartofline64(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x44);
}

HOSTMAP* teletextcodestartofline65(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x45);
}

HOSTMAP* teletextcodestartofline66(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x46);
}

HOSTMAP* teletextcodestartofline67(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x47);
}

HOSTMAP* teletextcodestartofline68(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x48);
}

HOSTMAP* teletextcodestartofline69(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x49);
}

HOSTMAP* teletextcodestartofline6A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4A);
}

HOSTMAP* teletextcodestartofline6B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4B);
}

HOSTMAP* teletextcodestartofline6C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4C);
}

HOSTMAP* teletextcodestartofline6D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4D);
}

HOSTMAP* teletextcodestartofline6E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4E);
}

HOSTMAP* teletextcodestartofline6F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x4F);
}

HOSTMAP* teletextcodestartofline70(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x50);
}

HOSTMAP* teletextcodestartofline71(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x51);
}

HOSTMAP* teletextcodestartofline72(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x52);
}

HOSTMAP* teletextcodestartofline73(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x53);
}

HOSTMAP* teletextcodestartofline74(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x54);
}

HOSTMAP* teletextcodestartofline75(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x55);
}

HOSTMAP* teletextcodestartofline76(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x56);
}

HOSTMAP* teletextcodestartofline77(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x57);
}

HOSTMAP* teletextcodestartofline78(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x58);
}

HOSTMAP* teletextcodestartofline79(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x59);
}

HOSTMAP* teletextcodestartofline7A(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5A);
}

HOSTMAP* teletextcodestartofline7B(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5B);
}

HOSTMAP* teletextcodestartofline7C(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5C);
}

HOSTMAP* teletextcodestartofline7D(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5D);
}

HOSTMAP* teletextcodestartofline7E(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5E);
}

HOSTMAP* teletextcodestartofline7F(HOSTMAP* hmap)
{
  teletextlinestart(hmap);
  return teletextdisplaypossiblegraphic(hmap, 0x5F);
}

HOSTMAP* teletextcodemidline00(HOSTMAP* hmap)
{
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline01(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphared);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline02(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphagreen);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline03(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphayellow);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline04(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphablue);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline05(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphamagenta);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline06(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphacyan);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline07(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafteralphawhite);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline08(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafterflash);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline09(HOSTMAP* hmap)
{
  /*steady*/
  uint8_t flipflops = hmap->A_teletext.flipflops & NOTTELETEXTFLASHFLAG;
  hmap->A_teletext.flipflops = flipflops;
  if (flipflops <= TELETEXTCONCEALTHRESHOLD)
    hmap->B_teletext.fg1fill = hmap->B_teletext.colourfill[hmap->B_teletext.colours&0x07];
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline0C(HOSTMAP* hmap)
{
  /*normal height*/
  uint8_t flipflops = hmap->A_teletext.flipflops;
  if (flipflops&TELETEXTDOUBLEHEIGHTFLAG)
  {
    hmap->A_teletext.flipflops = flipflops & NOTTELETEXTDOUBLEHEIGHTFLAG;
    hmap->B_teletext.lutslice -= 60;
    hmap->B_teletext.holdlue = hmap->teletextlinelut[0];
  }
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline0D(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextafterdoubleheight);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline11(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicred);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline12(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicgreen);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline13(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicyellow);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline14(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicblue);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline15(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicmagenta);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline16(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphiccyan);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline17(HOSTMAP* hmap)
{
  videoapplyevenloadintercept(hmap, teletextaftergraphicwhite);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline18(HOSTMAP* hmap)
{
  /*conceal*/
  hmap->A_teletext.flipflops |= TELETEXTCONCEALFLAG;
  hmap->B_teletext.fg1fill = hmap->B_teletext.bg1fill;
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline19(HOSTMAP* hmap)
{
  /*contiguous*/
  uint8_t flipflops = hmap->A_teletext.flipflops;
  if (flipflops & TELETEXTSEPARATEDFLAG)
  {
    hmap->A_teletext.flipflops = flipflops & NOTTELETEXTSEPARATEDFLAG;
    if (flipflops & TELETEXTGRAPHICFLAG)
      hmap->B_teletext.lutslice -= 20;
  }
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline1A(HOSTMAP* hmap)
{
  /*separated*/
  uint8_t flipflops = hmap->A_teletext.flipflops;
  if (!(flipflops & TELETEXTSEPARATEDFLAG))
  {
    hmap->A_teletext.flipflops = flipflops | TELETEXTSEPARATEDFLAG;
    if (flipflops & TELETEXTGRAPHICFLAG)
      hmap->B_teletext.lutslice += 20;
  }
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline1C(HOSTMAP* hmap)
{
  hmap->B_teletext.colours &= ~0x70;
  hmap->B_teletext.bg1fill = hmap->B_teletext.colourfill[0];
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline1D(HOSTMAP* hmap)
{
  uintptr_t colours = hmap->B_teletext.colours;
  hmap->B_teletext.colours = (colours&~0x70) | ((colours&0x07)<<4);
  hmap->B_teletext.bg1fill = hmap->B_teletext.colourfill[colours&0x07];
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline1E(HOSTMAP* hmap)
{
  /*hold graphics*/
  /*hold/release graphics actually affects the way colour-change*/
  /*codes are displayed. normally they are blank; when hold graphics*/
  /*is set, the previous character is displayed again. This allows*/
  /*contiguous blocks of colour.*/
  /*Thanks to Tom Seddon for that bit of information...*/
  hmap->A_teletext.flipflops |= TELETEXTHOLDFLAG;
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline1F(HOSTMAP* hmap)
{
  /*release graphics*/
  videoapplyevenloadintercept(hmap, teletextafterreleasegraphics);
  return teletextcontrolcommon(hmap);
}

HOSTMAP* teletextcodemidline20(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x00);
}

HOSTMAP* teletextcodemidline21(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x01);
}

HOSTMAP* teletextcodemidline22(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x02);
}

HOSTMAP* teletextcodemidline23(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x03);
}

HOSTMAP* teletextcodemidline24(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x04);
}

HOSTMAP* teletextcodemidline25(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x05);
}

HOSTMAP* teletextcodemidline26(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x06);
}

HOSTMAP* teletextcodemidline27(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x07);
}

HOSTMAP* teletextcodemidline28(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x08);
}

HOSTMAP* teletextcodemidline29(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x09);
}

HOSTMAP* teletextcodemidline2A(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0A);
}

HOSTMAP* teletextcodemidline2B(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0B);
}

HOSTMAP* teletextcodemidline2C(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0C);
}

HOSTMAP* teletextcodemidline2D(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0D);
}

HOSTMAP* teletextcodemidline2E(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0E);
}

HOSTMAP* teletextcodemidline2F(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x0F);
}

HOSTMAP* teletextcodemidline30(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x10);
}

HOSTMAP* teletextcodemidline31(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x11);
}

HOSTMAP* teletextcodemidline32(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x12);
}

HOSTMAP* teletextcodemidline33(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x13);
}

HOSTMAP* teletextcodemidline34(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x14);
}

HOSTMAP* teletextcodemidline35(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x15);
}

HOSTMAP* teletextcodemidline36(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x16);
}

HOSTMAP* teletextcodemidline37(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x17);
}

HOSTMAP* teletextcodemidline38(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x18);
}

HOSTMAP* teletextcodemidline39(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x19);
}

HOSTMAP* teletextcodemidline3A(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1A);
}

HOSTMAP* teletextcodemidline3B(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1B);
}

HOSTMAP* teletextcodemidline3C(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1C);
}

HOSTMAP* teletextcodemidline3D(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1D);
}

HOSTMAP* teletextcodemidline3E(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1E);
}

HOSTMAP* teletextcodemidline3F(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x1F);
}

HOSTMAP* teletextcodemidline40(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x20);
}

HOSTMAP* teletextcodemidline41(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x21);
}

HOSTMAP* teletextcodemidline42(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x22);
}

HOSTMAP* teletextcodemidline43(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x23);
}

HOSTMAP* teletextcodemidline44(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x24);
}

HOSTMAP* teletextcodemidline45(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x25);
}

HOSTMAP* teletextcodemidline46(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x26);
}

HOSTMAP* teletextcodemidline47(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x27);
}

HOSTMAP* teletextcodemidline48(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x28);
}

HOSTMAP* teletextcodemidline49(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x29);
}

HOSTMAP* teletextcodemidline4A(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2A);
}

HOSTMAP* teletextcodemidline4B(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2B);
}

HOSTMAP* teletextcodemidline4C(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2C);
}

HOSTMAP* teletextcodemidline4D(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2D);
}

HOSTMAP* teletextcodemidline4E(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2E);
}

HOSTMAP* teletextcodemidline4F(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x2F);
}

HOSTMAP* teletextcodemidline50(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x30);
}

HOSTMAP* teletextcodemidline51(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x31);
}

HOSTMAP* teletextcodemidline52(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x32);
}

HOSTMAP* teletextcodemidline53(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x33);
}

HOSTMAP* teletextcodemidline54(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x34);
}

HOSTMAP* teletextcodemidline55(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x35);
}

HOSTMAP* teletextcodemidline56(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x36);
}

HOSTMAP* teletextcodemidline57(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x37);
}

HOSTMAP* teletextcodemidline58(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x38);
}

HOSTMAP* teletextcodemidline59(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x39);
}

HOSTMAP* teletextcodemidline5A(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3A);
}

HOSTMAP* teletextcodemidline5B(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3B);
}

HOSTMAP* teletextcodemidline5C(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3C);
}

HOSTMAP* teletextcodemidline5D(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3D);
}

HOSTMAP* teletextcodemidline5E(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3E);
}

HOSTMAP* teletextcodemidline5F(HOSTMAP* hmap)
{
  return teletextdisplaynotgraphic(hmap, 0x3F);
}

HOSTMAP* teletextcodemidline60(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x40);
}

HOSTMAP* teletextcodemidline61(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x41);
}

HOSTMAP* teletextcodemidline62(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x42);
}

HOSTMAP* teletextcodemidline63(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x43);
}

HOSTMAP* teletextcodemidline64(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x44);
}

HOSTMAP* teletextcodemidline65(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x45);
}

HOSTMAP* teletextcodemidline66(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x46);
}

HOSTMAP* teletextcodemidline67(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x47);
}

HOSTMAP* teletextcodemidline68(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x48);
}

HOSTMAP* teletextcodemidline69(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x49);
}

HOSTMAP* teletextcodemidline6A(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4A);
}

HOSTMAP* teletextcodemidline6B(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4B);
}

HOSTMAP* teletextcodemidline6C(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4C);
}

HOSTMAP* teletextcodemidline6D(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4D);
}

HOSTMAP* teletextcodemidline6E(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4E);
}

HOSTMAP* teletextcodemidline6F(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x4F);
}

HOSTMAP* teletextcodemidline70(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x50);
}

HOSTMAP* teletextcodemidline71(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x51);
}

HOSTMAP* teletextcodemidline72(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x52);
}

HOSTMAP* teletextcodemidline73(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x53);
}

HOSTMAP* teletextcodemidline74(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x54);
}

HOSTMAP* teletextcodemidline75(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x55);
}

HOSTMAP* teletextcodemidline76(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x56);
}

HOSTMAP* teletextcodemidline77(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x57);
}

HOSTMAP* teletextcodemidline78(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x58);
}

HOSTMAP* teletextcodemidline79(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x59);
}

HOSTMAP* teletextcodemidline7A(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5A);
}

HOSTMAP* teletextcodemidline7B(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5B);
}

HOSTMAP* teletextcodemidline7C(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5C);
}

HOSTMAP* teletextcodemidline7D(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5D);
}

HOSTMAP* teletextcodemidline7E(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5E);
}

HOSTMAP* teletextcodemidline7F(HOSTMAP* hmap)
{
  return teletextdisplaypossiblegraphic(hmap, 0x5F);
}
