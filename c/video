/*>video.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Cycle-level video emulation
 *
 * (C) Copyright Crispian Daniels, 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#include <assert.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include "hostmap.h"
#include "beebit.h"
#include "kernel.h"
#include "main.h"
#include "riscos.h"
#include "swis.h"
#include "6502cmap.h"
#include "6502cpu.h"
#include "6522sysvia.h"
#include "6845crtc.h"
#include "video.h"
#include "videoscale.h"
#include "videoula.h"

#ifndef ColourTrans_ReturnColourNumber
#define ColourTrans_ReturnColourNumber 0x040744
#endif
#ifndef ColourTrans_WritePalette
#define ColourTrans_WritePalette 0x04075D
#endif

extern _kernel_swi_regs regs;

#define TIME_25HZ 4 /*CLK_TCK/25*/ /*25 times per second*/
#define TIME_50HZ 2 /*CLK_TCK/50*/ /*50 times per second*/
#define CONCEALFLAG 0x80
#define FLASHFLAG 0x40
#define HOLDFLAG 0x20
#define DOUBLEHEIGHTFLAG 0x08
#define SEPARATEDFLAG 0x02
#define GRAPHICSFLAG 0x01
#define NOTCONCEALFLAG 0x7F
#define NOTFLASHFLAG 0xBF
#define NOTHOLDFLAG 0xDF
#define NOTDOUBLEHEIGHTFLAG 0xF7
#define NOTSEPARATEDFLAG 0xFD
#define NOTGRAPHICSFLAG 0xFE

#define PROGRESSIVECLIPPEDSKIPFLAGS (CLIPPEDBELOWSKIPFLAG|CLIPPEDSKIPFLAG|CLIPPEDABOVESKIPFLAG)
#define TIMINGSKIPFLAGS (FRAMETIMESKIPFLAG|VSYNCSKIPFLAG|HSYNCSKIPFLAG|BEFOREDISPLAYSKIPFLAG|FASTSKIPFLAG)

#define ENDFRAMEIDLE 0
#define ENDFRAMESOON 1
#define ENDFRAMENOADJUST 2
#define ENDFRAMEADJUST 3
#define ENDFRAMEADJUSTING 4
#define ENDFRAMEADJUSTCOMPLETE 5
#define ENDFRAMEDUMMY 6

HOSTMAP* videoendframeidle(HOSTMAP* hmap);
HOSTMAP* videoendframesoon(HOSTMAP* hmap);
HOSTMAP* videoendframenoadjust(HOSTMAP* hmap);
HOSTMAP* videoendframeadjust(HOSTMAP* hmap);
HOSTMAP* videoendframeadjusting(HOSTMAP* hmap);
HOSTMAP* videoendframeadjustcomplete(HOSTMAP* hmap);
HOSTMAP* videoendframedummy(HOSTMAP* hmap);

HOSTMAP* videoslowenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipslowenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoslowleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddleslowleavingvsync(HOSTMAP* hmap);
HOSTMAP* videofastenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipfastenteringvsync(HOSTMAP* hmap);
HOSTMAP* videofastleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddlefastleavingvsync(HOSTMAP* hmap);
HOSTMAP* videoprogressiveenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoframeskipprogressiveenteringvsync(HOSTMAP* hmap);
HOSTMAP* videoprogressiveleavingvsync(HOSTMAP* hmap);
HOSTMAP* videotopmiddleprogressiveleavingvsync(HOSTMAP* hmap);

R6502ZONEMAP* videodisplaysyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplaypossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplaypsyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayppossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code);

R6502ZONEMAP* videodisplayoutleft(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayoutright(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayslowstop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayfaststop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);
R6502ZONEMAP* videodisplayprogressivestop(R6502ZONEMAP* zmap, uintptr_t peripheral_code);

HOSTMAP* videoupdateTMstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTR0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTB0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateTstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateMstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateR0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB2step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB1step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateB0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdateH0step(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoupdatestep(HOSTMAP* hmap, uintptr_t incremented_step_state);
HOSTMAP* videoidlestep(HOSTMAP* hmap, uintptr_t incremented_step_state);

HOSTMAP* videoreadevent(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadlinetest(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadcursorsignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreadpcursorsignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoreaddisplaysignal(HOSTMAP* hmap, uintptr_t scan_code);
HOSTMAP* videoinactivesetskew(HOSTMAP* hmap, uint8_t r8);
HOSTMAP* videosetskew(HOSTMAP* hmap, uint8_t r8);
HOSTMAP* videoprogressivesetskew(HOSTMAP* hmap, uint8_t r8);

/*palette*/
const unsigned int palette_rgb[8] =
{
  0x00000000, /*black*/
  0x0000FF00, /*red*/
  0x00FF0000, /*green*/
  0x00FFFF00, /*yellow*/
  0xFF000000, /*blue*/
  0xFF00FF00, /*magenta*/
  0xFFFF0000, /*cyan*/
  0xFFFFFF00  /*white*/
};
unsigned int palette_specified[8];

int videoupdate_videospeed;
int videoupdate_framerate;

clock_t nclock;

int video_screenstartoffset;
int video_screenstartline;

unsigned char teletextlinemap[192*10];
int nteletextlinepatterns;
const int *teletextlinepatterns;

void* video_workspace = NULL;

void videoinit(void)
{
  HOSTMAP* hmap = &hostmap;
  const int maxhashvalue = 31;
  const int log2collisionallowance = 4;
  const int collisionallowance = 1<<log2collisionallowance;
  const int initialnumberallocation = (1+maxhashvalue)<<log2collisionallowance;
  const int expansionoffset = 8;

  FILE *hfile;
  int i,j,k;
  int updots,dots,downdots,dots8,downdots8;
  int leftxor,rightxor,upxor,downxor;
  int significantupdots,significantdowndots;
  int hashvalue,pattern;
  int startnumber,stopnumber,number;
  unsigned char widedots[8];
  int * const patterns = calloc(2 * initialnumberallocation + 384*10, sizeof(int));
  int * const renumbering = &patterns[initialnumberallocation];
  int * const linenumbers = &patterns[2 * initialnumberallocation];
  int *nextlinenumber = linenumbers;
  int *stoplinenumber;
  unsigned char *nextlineinmap = teletextlinemap;

  hfile = NULL;
  for (k=0; k<2; k++)
  {
    switch (k)
    {
      case 0:
        hfile = fopen("<BeebIt$Dir>.Resources.MODE7A","rb");
        fseek(hfile, 128*10*8, SEEK_CUR);
        break;
      case 1:
        fclose(hfile);

        hfile = fopen("<BeebIt$Dir>.Resources.MODE7G","rb");
        fseek(hfile, 128*10*8, SEEK_CUR);
        break;
    }

    for (j=0; j<96; j++)
    {
      dots = 0;

      fread(widedots, 1, 8, hfile);
      downdots = (widedots[6] & 0x10) | (widedots[5] & 0x08) |
          (widedots[4] & 0x04) | (widedots[3] & 0x02) | (widedots[2] & 0x01);
      downdots8 = (widedots[7] & 0x80) | (widedots[6] & 0x40) | (widedots[5] & 0x20) |
        (widedots[4] & 0x10) | (widedots[3] & 0x08) | (widedots[2] & 0x04) |
        (widedots[1] & 0x02) | (widedots[0] & 0x01);

      for (i=0; i<10; i++)
      {
        updots = dots;
        dots = downdots;
        dots8 = downdots8;

        if (i<9)
        {
          fread(widedots, 1, 8, hfile);
          downdots = (widedots[6] & 0x10) | (widedots[5] & 0x08) |
              (widedots[4] & 0x04) | (widedots[3] & 0x02) | (widedots[2] & 0x01);
          downdots8 = (widedots[7] & 0x80) | (widedots[6] & 0x40) | (widedots[5] & 0x20) |
              (widedots[4] & 0x10) | (widedots[3] & 0x08) | (widedots[2] & 0x04) |
              (widedots[1] & 0x02) | (widedots[0] & 0x01);
        }
        else
        {
          downdots = 0;
        }

        if (((dots8 & 0xF0) == 0xF0 || (dots8 & 0xF0) == 0x00) &&
            ((dots8 & 0x0F) == 0x0F || (dots8 & 0x0F) == 0x00))
        {
          *nextlinenumber = ((dots8>>3)&3)-expansionoffset;
        }
        else
        {
          leftxor = dots ^ (dots<<1);
          rightxor = dots ^ (dots>>1);
          upxor = updots ^ dots;
          downxor = downdots ^ dots;

          significantdowndots = downdots & ((rightxor & (downxor>>1)) | (leftxor & (downxor<<1)));
          significantupdots = updots & ((rightxor & (upxor>>1)) | (leftxor & (upxor<<1)));

          pattern = (significantdowndots << 10) | (dots << 5) | significantupdots;

          hashvalue = dots;
          hashvalue ^= (significantupdots>>3) | ((significantupdots & 0x07)<<2);
          hashvalue ^= (significantdowndots>>2) | ((significantdowndots & 0x03)<<3);

          startnumber = hashvalue << log2collisionallowance;
          stopnumber = startnumber + collisionallowance;

          for (number = startnumber; number < stopnumber; number++)
          {
            if (patterns[number] == pattern)
                break;

            if (patterns[number] == 0)
            {
              patterns[number] = pattern;
              break;
            }
          }

          *nextlinenumber = number == stopnumber ? startnumber : number;
        }

        nextlinenumber++;
      }
    }
  }

  fclose(hfile);

  stoplinenumber = nextlinenumber;
  number = 0;

  for (k = 0; k < initialnumberallocation; k++)
  {
    pattern = patterns[k];

    if (!pattern)
      continue;

    renumbering[k] = expansionoffset + number;

    patterns[number] = pattern;
    number++;
  }

  for (nextlinenumber = linenumbers; nextlinenumber < stoplinenumber; nextlinenumber++)
  {
    if (*nextlinenumber < 0)
      *nextlineinmap = (unsigned char)(expansionoffset + *nextlinenumber);
    else
      *nextlineinmap = (unsigned char)renumbering[*nextlinenumber];
    nextlineinmap++;
  }

  nteletextlinepatterns = number;
  teletextlinepatterns = realloc(patterns, number * sizeof(int));

  hmap->B_crtc.endoflineactions[0] = videoendframeidle;
  hmap->B_crtc.endoflineactions[1] = videoendframesoon;
  hmap->B_crtc.endoflineactions[2] = videoendframenoadjust;
  hmap->B_crtc.endoflineactions[3] = videoendframeadjust;
  hmap->B_crtc.endoflineactions[4] = videoendframeadjusting;
  hmap->B_crtc.endoflineactions[5] = videoendframeadjustcomplete;
  hmap->B_crtc.endoflineactions[6] = videoendframedummy;

  hmap->B_vidbuf.setskewop = videoinactivesetskew;

  videoulainit();
}

void videosetpalette(void)
{
  int i;
  unsigned int u;
  float weights[8],gamma;

  if (beebit_palette == PALETTE_RGB)
  {
    for (i=0; i<8; i++)
    {
      palette_specified[i] = palette_rgb[i];
    }
  }
  else
  {
    weights[0] = 0.0f;
    weights[7] = 1.0f;
    gamma = 1.0f;

    switch (beebit_palette)
    {
      case PALETTE_COLOUR:
        weights[1] = 0.4716f;
        weights[2] = 0.6118f;
        weights[3] = 0.8922f;
        weights[4] = 0.2990f;
        weights[5] = 0.5794f;
        weights[6] = 0.7196f;
        gamma = 0.45f;
        break;
      case PALETTE_GREY:
      case PALETTE_GREEN:
        weights[1] = 0.2657f;
        weights[2] = 0.5845f;
        weights[3] = 0.8501f;
        weights[4] = 0.1499f;
        weights[5] = 0.4155f;
        weights[6] = 0.7343f;
        break;
    }

    for (i=0; i<8; i++)
    {
      u = (unsigned int)nearbyintf(255.0f * powf(weights[i],gamma));
      palette_specified[i] = (u<<24)|(u<<16)|(u<<8);
    }

    switch (beebit_palette)
    {
      case PALETTE_COLOUR:
        for (i=0; i<8; i++)
        {
          palette_specified[i] &= palette_rgb[i];
        }
        break;
      case PALETTE_GREEN:
        for (i=0; i<8; i++)
        {
          palette_specified[i] &= 0x00FF0000;
        }
        break;
    }
  }
}

unsigned int teletextgethalfdots(int dots, int adjacentdots)
{
  int highmask,lowmask,i;
  unsigned int j;
  unsigned int result = 0;

  lowmask = (dots<<1) & adjacentdots & ~(adjacentdots<<1);
  highmask = (dots>>1) & adjacentdots & ~(adjacentdots>>1);

  for (i=0x01,j=0x10; i<=0x10; i<<=1,j<<=2)
  {
    if (dots & i)
      result |= (j<<1)|j;
    else
    {
      if (lowmask & i)
        result |= j;
      if (highmask & i)
        result |= (j<<1);
    }
  }

  return result;
}

unsigned int teletextgetquarterdots(int dots, int adjacentdots)
{
  int highmask,lowmask,i;
  unsigned int j;
  unsigned int result = 0;

  lowmask = (dots<<1) & adjacentdots & ~(adjacentdots<<1);
  highmask = (dots>>1) & adjacentdots & ~(adjacentdots>>1);

  for (i=0x01,j=0x30; i<=0x10; i<<=1,j<<=4)
  {
    if (dots & i)
      result |= (j<<2)|j;
    else
    {
        if (lowmask & i)
          result |= j;
        if (highmask & i)
          result |= (j<<2);
    }
  }

  return result;
}

void teletextadjustquarterdots(unsigned int* dots, unsigned int* upperdots, unsigned int* lowerdots)
{
  int i;

  for (i=0x010; i<=0x100000; i<<=4)
  {
    if (*dots & i)
      continue;

    if (*upperdots & i)
    {
      *upperdots |= (i<<2);
      *dots |= i;
    }
    if (*upperdots & (i<<3))
    {
      *upperdots |= (i<<1);
      *dots |= (i<<3);
    }
    if (*lowerdots & i)
    {
      *lowerdots |= (i<<2);
      *dots |= i;
    }
    if (*lowerdots & (i<<3))
    {
      *lowerdots |= (i<<1);
      *dots |= (i<<3);
    }
  }
}

void teletextwriteslicehalves(intptr_t* address, int stride, int ndivisions, unsigned int subdots)
{
  unsigned int mask = (1U<<(ndivisions>>1))-1;
  *(uint32_t*)*address = subdots & mask;
  *address += (stride>>1);
  *(uint32_t*)*address = (subdots >> (ndivisions>>1)) & mask;
  *address += (stride>>1);
}

void teletextexpandslicehalves(intptr_t address, int ndivisions, int shift, int nslices, int stride)
{
  unsigned int block = (1U<<shift)-1;
  unsigned int d;
  unsigned int v;
  int i,j,f,f2;
  uint32_t* slice;

  for (i=(nslices<<1); i>0; i--, address+=(stride>>1))
  {
    slice = (uint32_t*)address;
    d = *slice;
    v = 0; f = 0;

    for (j=ndivisions; j>0; j-=2,d>>=1)
    {
      if (d&1)
        v |= (block<<f);
      f2 = f + shift;
      if (f2 >= 32)
      {
        *slice++ = v;
        if (d&1)
          v = block>>(32-f);
        else
          v = 0;
        f = f2 - 32;
      }
      else
        f = f2;
    }
    if (f > 0)
      *slice++ = v;
  }
}

void teletextwritelinemap(int slicesize, int nslices, intptr_t teletextaddress)
{
  HOSTMAP* hmap = &hostmap;
  int aline,gline,adoubleline,gdoubleline;
  int linesize = nslices * slicesize;
  intptr_t* p = hmap->teletextlinelut;
  int i,j;

  if (nslices > 1)
  {
    for (i=0; i<960; i+=10, p+=128)
    {
      for (j=0; j<20; j++)
      {
        aline = j<10 ? teletextlinemap[i+j] : 0;
        adoubleline = teletextlinemap[i+(j>>1)];
        gline = j<10 ? teletextlinemap[960+i+j] : 0;
        gdoubleline = teletextlinemap[960+i+(j>>1)];

        p[j] = teletextaddress + aline * linesize;
        p[20+j] = teletextaddress + gline * linesize;
        if (gline < 4)
        {
          if (j==2||j==6||j==9)
            gline = 0;
          else
            gline += 4;
        }
        p[40+j] = teletextaddress + gline * linesize;
        if (adoubleline < 4)
          p[60+j] = teletextaddress + adoubleline * linesize;
        else
          p[60+j] = teletextaddress + (adoubleline + (1+(j&1)) * nteletextlinepatterns) * linesize;
        if (gdoubleline < 4)
        {
          p[80+j] = teletextaddress + gdoubleline * linesize;
          if ((j>>1)==2||(j>>1)==6||(j>>1)==9)
            gdoubleline = 0;
          else
            gdoubleline += 4;
          p[100+j] = teletextaddress + gdoubleline * linesize;
        }
        else
        {
          p[100+j] = p[80+j] = teletextaddress + (gdoubleline + (1+(j&1)) * nteletextlinepatterns) * linesize;
        }
      }
    }
  }
  else
  {
    for (i=0; i<960; i+=10, p+=128)
    {
      for (j=0; j<20; j++)
      {
        aline = j<10 ? teletextlinemap[i+j] : 0;
        adoubleline = teletextlinemap[i+(j>>1)];
        gline = j<10 ? teletextlinemap[960+i+j] : 0;
        gdoubleline = teletextlinemap[960+i+(j>>1)];

        p[j] = teletextaddress + aline * slicesize;
        p[20+j] = teletextaddress + gline * slicesize;
        if (gline < 4)
        {
          if (j==2||j==6||j==9)
            gline = 0;
          else
            gline += 4;
        }
        p[40+j] = teletextaddress + gline * slicesize;
        p[60+j] = teletextaddress + adoubleline * slicesize;
        p[80+j] = teletextaddress + gdoubleline * slicesize;
        if (gdoubleline < 4)
        {
          if ((j>>1)==2||(j>>1)==6||(j>>1)==9)
            gdoubleline = 0;
          else
            gdoubleline += 4;
        }
        p[100+j] = teletextaddress + gdoubleline * slicesize;
      }
    }
  }
}

static inline void videosetdisplayfunctions(VIDEOSCALECHOICE* choice)
{
  HOSTMAP* hmap = &hostmap;
  R6502PERIPHERALOP displaystopop;
  R6502PERIPHERALOP displayvsyncedgeop,displaypossiblestartop;
  R6502PERIPHERALOP teletextblacklevelop,cursorteletextblacklevelop;
  R6502PERIPHERALOP teletextop,cursorteletextop;
  int i;

  if (hmap->A_vidbuf.progressive)
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videoprogressiveenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipprogressiveenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddleprogressiveleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videoprogressiveleavingvsync;
    displaystopop = videodisplayprogressivestop;
  }
  else if (beebit_videospeed == VIDEO_FAST)
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videofastenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipfastenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddlefastleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videofastleavingvsync;
    displaystopop = videodisplayfaststop;
  }
  else
  {
    if (hmap->A_vidbuf.updateframenumber == 0)
      hmap->B_vidbuf.enteringvsyncop = videoslowenteringvsync;
    else
      hmap->B_vidbuf.enteringvsyncop = videoframeskipslowenteringvsync;
    if (beebit_topmiddle)
      hmap->B_vidbuf.leavingvsyncop = videotopmiddleslowleavingvsync;
    else
      hmap->B_vidbuf.leavingvsyncop = videoslowleavingvsync;
    displaystopop = videodisplayslowstop;
  }

  if (hmap->A_vidbuf.progressive)
  {
    displayvsyncedgeop = videodisplaypsyncedge;
    displaypossiblestartop = videodisplayppossiblestart;
  }
  else
  {
    displayvsyncedgeop = videodisplaysyncedge;
    displaypossiblestartop = videodisplaypossiblestart;
  }

  if (beebit_machinetype == MACHINE_MODELB || beebit_machinetype == MACHINE_MODELBPLUS)
  {
    teletextblacklevelop = choice->blacklevelops.teletextb;
    cursorteletextblacklevelop = choice->blacklevelops.cursorteletextb;
    hmap->B_vidbuf.teletextinnerop = choice->writeinnerops.teletextb;
    teletextop = choice->writeops.teletextb;
    cursorteletextop = choice->writeops.cursorteletextb;
  }
  else
  {
    teletextblacklevelop = choice->blacklevelops.teletext;
    cursorteletextblacklevelop = choice->blacklevelops.cursorteletext;
    hmap->B_vidbuf.teletextinnerop = choice->writeinnerops.teletext;
    teletextop = choice->writeops.teletext;
    cursorteletextop = choice->writeops.cursorteletext;
  }

  hmap->B_videoula.blacklevelops[0] = choice->blacklevelops.blank;
  hmap->B_videoula.blacklevelops[1] = choice->blacklevelops.graphics;
  hmap->B_videoula.blacklevelops[2] = teletextblacklevelop;
  hmap->B_videoula.blacklevelops[3] = teletextblacklevelop;
  hmap->B_videoula.blacklevelops[4] = choice->blacklevelops.cursorblank;
  hmap->B_videoula.blacklevelops[5] = choice->blacklevelops.cursorgraphics;
  hmap->B_videoula.blacklevelops[6] = cursorteletextblacklevelop;
  hmap->B_videoula.blacklevelops[7] = cursorteletextblacklevelop;

  hmap->B_vidbuf.graphicsinnerop = choice->writeinnerops.graphics;
  hmap->B_vidbuf.cursorinnerop = choice->writeinnerops.cursor;

  hmap->peripheralops[0] = videodisplayskip;
  hmap->peripheralops[1] = choice->writeops.graphics;
  hmap->peripheralops[2] = teletextop;
  hmap->peripheralops[3] = teletextop;
  hmap->peripheralops[4] = choice->writeops.cursorblank;
  hmap->peripheralops[5] = choice->writeops.cursorgraphics;
  hmap->peripheralops[6] = cursorteletextop;
  hmap->peripheralops[7] = cursorteletextop;
  for (i=0x08; i<0x10; i++)
  {
    hmap->peripheralops[i] = videodisplayskip;
  }
  for (i=0x10; i<0x20; i++)
  {
    hmap->peripheralops[i] = videodisplayoutright;
  }
  for (i=0x20; i<0x30; i++)
  {
    hmap->peripheralops[i] = displaystopop;
  }
  for (i=0x30; i<0x40; i++)
  {
    hmap->peripheralops[i] = videodisplayoutleft;
  }
  for (i=0x40; i<0x80; i++)
  {
    hmap->peripheralops[i] = displaypossiblestartop;
  }
  for (i=0x80; i<0x100; i++)
  {
    hmap->peripheralops[i] = displayvsyncedgeop;
  }

  if (hmap->A_vidbuf.progressive)
    hmap->B_vidbuf.setskewop = videoprogressivesetskew;
  else
    hmap->B_vidbuf.setskewop = videosetskew;
}

static inline void videosetreadfour(HOSTVIDEOREADOP* first, const HOSTVIDEOREADOP* src)
{
  first[0] = src[0];
  first[4] = src[1];
  first[8] = src[2];
  first[12] = src[3];
}

static inline void videosetreadfunctions(void)
{
  HOSTMAP* hmap = &hostmap;
  const VIDEOREADSET* readset;
  const VIDEOREADTWENTY* readgraphicstwenty;
  const VIDEOREADTWENTY* readteletexttwenty;
  int i;

  if (beebit_videospeed == VIDEO_PROGRESSIVE_SLOW)
    readset = &videoreadpset;
  else
    readset = &videoreadset;

  readgraphicstwenty = (*readset)[0];

  if (beebit_machinetype == MACHINE_MODELB)
    readteletexttwenty = (*readset)[1];
  else
    readteletexttwenty = (*readset)[2];

  for (i=0; i<4; i++)
  {
    memcpy(&hmap->videographicswrapreads[i<<2], (*(*readgraphicstwenty)[i+1]), sizeof(VIDEOREADFOUR));
  }
  for (i=0; i<4; i++)
  {
    memcpy(&hmap->videoteletextwrapreads[i<<2], (*(*readteletexttwenty)[i+1]), sizeof(VIDEOREADFOUR));
  }

  videosetreadfour(&hmap->videoreads[0], (*(* readgraphicstwenty)[0]));
  videosetreadfour(&hmap->videoreads[1], &hmap->videographicswrapreads[hmap->screenstartindex<<2]);
  videosetreadfour(&hmap->videoreads[2], (*(* readteletexttwenty)[0]));
  videosetreadfour(&hmap->videoreads[3], &hmap->videoteletextwrapreads[hmap->screenstartindex<<2]);

  for (i=16; i<32; i++)
  {
    hmap->videoreads[i] = videoreaddisplaysignal;
  }
  if (hmap->A_vidbuf.progressive)
  {
    for (i=32; i<64; i++)
    {
      hmap->videoreads[i] = videoreadpcursorsignal;
    }
  }
  else
  {
    for (i=32; i<64; i++)
    {
      hmap->videoreads[i] = videoreadcursorsignal;
    }
  }
  for (i=64; i<128; i++)
  {
    hmap->videoreads[i] = videoreadlinetest;
  }
  for (i=128; i<256; i++)
  {
    hmap->videoreads[i] = videoreadevent;
  }
}

static inline uintptr_t videoupdateskipbit(uintptr_t peripheral_code, uint8_t skip)
{
  if (skip)
    peripheral_code |= VIDEODISPLAYSKIP;
  else
    peripheral_code &= ~VIDEODISPLAYSKIP;
  return peripheral_code;
}

static inline uintptr_t videoupdateadvanceandskipbits(HOSTMAP* hmap, uintptr_t peripheral_code, uint8_t skip)
{
  intptr_t column;

  peripheral_code = videoupdateskipbit(peripheral_code & ~VIDEODISPLAYADVANCEMASK, skip);

  if (skip & HSYNCSKIPFLAG)
    peripheral_code |= VIDEODISPLAYSTOP;
  else
  {
    column = hmap->B_vidbuf.column;

    if (column < 0)
      peripheral_code |= VIDEODISPLAYOUTLEFT;
    else if (column >= hmap->B_vidbuf.limitcolumn)
      peripheral_code |= VIDEODISPLAYSTOP;
    else if (column >= hmap->B_vidbuf.stopcolumn)
      peripheral_code |= VIDEODISPLAYOUTRIGHT;
  }

  return peripheral_code;
}

static inline HOSTMAP* videorefreshclippedskipflag(HOSTMAP* hmap)
{
  if (hmap->B_vidbuf.line < 0 || hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;
  return hmap;
}

static inline uintptr_t videoupdatepskipbit(uintptr_t peripheral_code, uint8_t skip)
{
  if ((skip & TIMINGSKIPFLAGS) || skip >= PROGRESSIVECLIPPEDSKIPFLAGS)
    peripheral_code |= VIDEODISPLAYSKIP;
  else
    peripheral_code &= ~VIDEODISPLAYSKIP;
  return peripheral_code;
}

static inline uintptr_t videoupdatepadvanceandskipbits(HOSTMAP* hmap, uintptr_t peripheral_code, uint8_t skip)
{
  intptr_t column;

  peripheral_code = videoupdatepskipbit(peripheral_code & ~VIDEODISPLAYADVANCEMASK, skip);

  if (skip & HSYNCSKIPFLAG)
    peripheral_code |= VIDEODISPLAYSTOP;
  else
  {
    column = hmap->B_vidbuf.column;

    if (column < 0)
      peripheral_code |= VIDEODISPLAYOUTLEFT;
    else if (column >= hmap->B_vidbuf.limitcolumn)
      peripheral_code |= VIDEODISPLAYSTOP;
    else if (column >= hmap->B_vidbuf.stopcolumn)
      peripheral_code |= VIDEODISPLAYOUTRIGHT;
  }

  return peripheral_code;
}

static inline void videorefreshpclippedskipflag(HOSTMAP* hmap)
{
  if (hmap->B_vidbuf.line < 0 || hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

  if (hmap->B_vidbuf.line < 1 || hmap->B_vidbuf.line > hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDABOVESKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDABOVESKIPFLAG;

  if (hmap->B_vidbuf.line < -1 || hmap->B_vidbuf.line + 1 >= hmap->B_vidbuf.stopline)
    hmap->A_vidbuf.skip |= CLIPPEDBELOWSKIPFLAG;
  else
    hmap->A_vidbuf.skip &= ~CLIPPEDBELOWSKIPFLAG;
}

void videosetscale(void)
{
  HOSTMAP* hmap = &hostmap;
  VIDEOSCALEUPDATEPARAMS uparams;
  VIDEOSCALECHOICE choice;
  int log2bpp,xres,yres,i,j;
  int columnstep, linestep;
  int linelength;
  int columncapacity;
  int columnremainder;
  intptr_t stopcolumn;
  int nstopmarkers;
  int linecapacity;
  int lineremainder;
  intptr_t buffersize;
  int nteletextslices;
  int adjustednteletextslices;
  int nteletextlog2divisionshift;
  int nteletextdivisions;
  int adjustednteletextdivisions;
  int teletextslicesize;
  int teletextlinecount;
  int teletextsize;
  unsigned int graphicleft,graphicright,separationmask;
  unsigned int subdots,uppersubdots,lowersubdots;
  int pattern;
  intptr_t bufferaddress;
  intptr_t teletextaddress;
  intptr_t sliceaddress;
  int workspacesize = 0;
  unsigned int (*getsubdots)(int, int);

  uparams.videospeed = beebit_videospeed;
  uparams.framerate = beebit_framerate;
  videoscalechoose(beebit_graphicsmodespecifier, &uparams, &choice);

  hmap->A_vidbuf.shift = choice.buffershift;
  hmap->A_vidout.linescaletotal = choice.linescale;
  videoscale_updateparameters = uparams;
  videoscale_lutparameters = choice.lutparameters;
  videoscale_init = choice.init;

  videoscalesetops(&choice);

  regs.r[0] = beebit_graphicsmodespecifier;
  regs.r[1] = 9;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  log2bpp = regs.r[2];
  regs.r[1] = 11;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  xres = regs.r[2] + 1;
  regs.r[1] = 12;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  yres = regs.r[2] + 1;

  hmap->B_vidout.nbits = choice.columnpixels<<log2bpp;

  if (choice.format&4)
    hmap->A_videoula.fragmentbits = 8;
  else
    hmap->A_videoula.fragmentbits = 4;

  linestep = choice.linescale;

  columnstep = (choice.columnpixels<<log2bpp)>>3;

  linelength = (xres<<log2bpp)>>3;
  columncapacity = linelength / columnstep;
  columnremainder = linelength % columnstep;

  if (columncapacity & 1)
  {
    video_screenstartoffset = ((columnremainder + columnstep) >> 3) << 2;

    if (video_screenstartoffset > columnremainder)
    {
      columncapacity--;
    }
    else
    {
      video_screenstartoffset = (columnremainder >> 3) << 2;
    }
  }
  else
  {
    video_screenstartoffset = (columnremainder >> 3) << 2;
  }

  hmap->B_vidbuf.synccolumn = beebit_hadjust + (columncapacity - 129) / 2;
  stopcolumn = hmap->B_vidbuf.synccolumn + 128;

  if (stopcolumn > columncapacity)
    stopcolumn = columncapacity;

  if (hmap->B_vidbuf.synccolumn > 0)
  {
    video_screenstartoffset += hmap->B_vidbuf.synccolumn * columnstep;
    stopcolumn -= hmap->B_vidbuf.synccolumn;
    hmap->B_vidbuf.synccolumn = 0;
  }

  hmap->B_vidbuf.limitcolumn = hmap->B_vidbuf.synccolumn + 128;

  linecapacity = yres / linestep;
  lineremainder = yres % linestep;

  if (linecapacity & 1)
  {
    video_screenstartline = ((lineremainder + linestep) >> 1) << 1;

    if (video_screenstartline > lineremainder)
    {
      linecapacity--;
    }
    else
    {
      video_screenstartline = (lineremainder >> 1) << 1;
    }
  }
  else
  {
    video_screenstartline = (lineremainder >> 1) << 1;
  }

  hmap->B_vidbuf.syncline = beebit_vadjust + (linecapacity - 317) / 2;
  hmap->B_vidbuf.stopline = hmap->B_vidbuf.syncline + 312;

  if (hmap->B_vidbuf.stopline > linecapacity)
    hmap->B_vidbuf.stopline = linecapacity;

  if (hmap->B_vidbuf.syncline > 0)
  {
    video_screenstartline += hmap->B_vidbuf.syncline * linestep;
    hmap->B_vidbuf.stopline -= hmap->B_vidbuf.syncline;
    hmap->B_vidbuf.syncline = 0;
  }

  hmap->B_vidbuf.startline = hmap->B_vidbuf.syncline + 30;
  hmap->B_vidbuf.limitline = hmap->B_vidbuf.syncline + 312;

  hmap->B_vidbuf.column += hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.line += hmap->B_vidbuf.syncline;

  hmap->B_vidbuf.stopcolumn = stopcolumn;

  if (columnstep&1)
    nstopmarkers = (-stopcolumn&3)+1;
  else if (columnstep&2)
    nstopmarkers = (-stopcolumn&1)+1;
  else
    nstopmarkers = 1;

  if (choice.format&8)
  {
    hmap->A_vidbuf.distinctfields = 1;
    hmap->A_vidbuf.progressive = (beebit_videospeed == VIDEO_PROGRESSIVE_SLOW);
  }
  else
  {
    hmap->A_vidbuf.distinctfields = 0;
    hmap->A_vidbuf.progressive = 0;
    hmap->A_vidbuf.writecode = 0x30;
  }

  hmap->B_vidbuf.stride = (stopcolumn+nstopmarkers) << hmap->A_vidbuf.shift;
  hmap->B_vidbuf.stride += (-hmap->B_vidbuf.stride&3);

  if (hmap->A_vidbuf.progressive)
  {
    hmap->B_vidbuf.altoffset = hmap->B_vidbuf.stride;
    hmap->B_vidbuf.stride <<= 1;
  }

  hmap->B_vidbuf.stride = sizeof(intptr_t) + hmap->B_vidbuf.stride;

  buffersize = hmap->B_vidbuf.stopline * hmap->B_vidbuf.stride;

  if (choice.format&2)
    nteletextlog2divisionshift = 3;
  else
    nteletextlog2divisionshift = 2;

  if (!(choice.format&3))
  {
    nteletextdivisions = 16;
    graphicleft = 0x00FF;
    graphicright = 0xFF00;
    separationmask = 0xFCFC;
    getsubdots = teletextgethalfdots;
    hmap->B_teletext.bblevelbit = (2<<nteletextlog2divisionshift);
  }
  else
  {
    nteletextdivisions = 24;
    graphicleft = 0x000FFF;
    graphicright = 0xFFF000;
    separationmask = 0xFF0FF0;
    getsubdots = teletextgetquarterdots;
    hmap->B_teletext.bblevelbit = (4<<nteletextlog2divisionshift);
  }

  adjustednteletextdivisions = (((nteletextdivisions<<nteletextlog2divisionshift)+63)&~63)>>nteletextlog2divisionshift;

  teletextslicesize = ((adjustednteletextdivisions>>3)<<nteletextlog2divisionshift);

  nteletextslices = choice.teletextslices;
  if (nteletextslices == 3 && hmap->A_vidbuf.distinctfields)
    adjustednteletextslices = nteletextslices+1;
  else
    adjustednteletextslices = nteletextslices;

  if (nteletextslices > 1)
    teletextlinecount = 8 + 3 * nteletextlinepatterns;
  else
    teletextlinecount = 8 + nteletextlinepatterns;

  teletextsize = teletextlinecount * adjustednteletextslices * teletextslicesize;

  hmap->B_teletext.rightoffset = teletextslicesize>>1;
  if (hmap->A_vidbuf.distinctfields)
  {
    if (nteletextslices < 3)
      hmap->B_teletext.lowoffset = teletextslicesize;
    else
      hmap->B_teletext.lowoffset = (teletextslicesize<<1);
  }
  else
    hmap->B_teletext.lowoffset = 0;

  hmap->B_vidout.lut = workspacesize;
  workspacesize += choice.lutsize + (-choice.lutsize & 3);
  bufferaddress = workspacesize;
  workspacesize += buffersize + (-buffersize & 3);
  teletextaddress = workspacesize;
  workspacesize += teletextsize + (-teletextsize & 3);

  video_workspace = malloc(workspacesize);

  hmap->B_vidout.lut += (intptr_t)video_workspace;
  bufferaddress += (intptr_t)video_workspace;
  teletextaddress += (intptr_t)video_workspace;

  memset((void*)bufferaddress, 0, buffersize);
  bufferaddress += sizeof(intptr_t);

  hmap->B_vidbuf.synclineaddress = bufferaddress + hmap->B_vidbuf.syncline * hmap->B_vidbuf.stride;
  hmap->B_vidbuf.lineaddress = bufferaddress + hmap->B_vidbuf.line * hmap->B_vidbuf.stride;

  for (i=0; i<hmap->B_vidbuf.stopline; i++)
  {
    for (j=0; j<nstopmarkers; j++)
    {
      ((unsigned char*)bufferaddress)[(stopcolumn+j)<<hmap->A_vidbuf.shift] = 0x80;
    }

    if (hmap->A_vidbuf.progressive)
    {
      for (j=0; j<nstopmarkers; j++)
      {
        ((unsigned char*)(bufferaddress+hmap->B_vidbuf.altoffset))[(stopcolumn+j)<<hmap->A_vidbuf.shift] = 0x80;
      }
    }

    bufferaddress += hmap->B_vidbuf.stride;
  }

  sliceaddress = teletextaddress;
  lowersubdots = uppersubdots = subdots = 0;

  for (i=0; i<8; i++)
  {
    subdots = ((i&2)?graphicright:0) | ((i&1)?graphicleft:0);
    if (i>=4)
      subdots &= separationmask;
    for (j=0; j<adjustednteletextslices; j++)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
  }

  for (i=0; i<nteletextlinepatterns; i++)
  {
    pattern = teletextlinepatterns[i];
    if (nteletextslices & 2)
    {
      uppersubdots = getsubdots((pattern>>5)&0x1F, pattern&0x1F);
      lowersubdots = getsubdots((pattern>>5)&0x1F, (pattern>>10)&0x1F);
    }
    if (nteletextslices & 1)
    {
      subdots = getsubdots((pattern>>5)&0x1F, 0);
      if ((nteletextslices & 2) && getsubdots == teletextgetquarterdots)
        teletextadjustquarterdots(&subdots, &uppersubdots, &lowersubdots);
    }
    if (nteletextslices & 2)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, uppersubdots);
    }
    if (nteletextslices & 1)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
    if (nteletextslices & 2)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, lowersubdots);
    }
    if (adjustednteletextslices > nteletextslices)
    {
      teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
    }
  }

  if (nteletextslices > 1)
  {
    for (i=0; i<nteletextlinepatterns; i++)
    {
      pattern = teletextlinepatterns[i];
      subdots = getsubdots((pattern>>5)&0x1F, pattern&0x1F);
      for (j=0; j<adjustednteletextslices; j++)
      {
        teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
      }
    }
    for (i=0; i<nteletextlinepatterns; i++)
    {
      pattern = teletextlinepatterns[i];
      subdots = getsubdots((pattern>>5)&0x1F, (pattern>>10)&0x1F);
      for (j=0; j<adjustednteletextslices; j++)
      {
        teletextwriteslicehalves(&sliceaddress, teletextslicesize, nteletextdivisions, subdots);
      }
    }
  }

  if (nteletextlog2divisionshift > 0)
    teletextexpandslicehalves(teletextaddress, nteletextdivisions, 1<<nteletextlog2divisionshift, teletextlinecount * adjustednteletextslices, teletextslicesize);

  teletextwritelinemap(teletextslicesize, adjustednteletextslices, teletextaddress);

  hmap->A_teletext.roundingdirection2 = hmap->A_teletext.roundingdirection1 = 0;
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1 = hmap->teletextlinelut[0];

  hmap->A_vidbuf.updateframenumber = (1<<beebit_framerate)-1;

  if (hmap->A_vidbuf.updateframecounter > hmap->A_vidbuf.updateframenumber)
    hmap->A_vidbuf.updateframecounter = 0;

  if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
    hmap->A_vidbuf.skip = 0;
  else
    hmap->A_vidbuf.skip = FRAMETIMESKIPFLAG;

  if (beebit_videospeed == VIDEO_FAST)
    hmap->A_vidbuf.skip |= hmap->A_vidbuf.fastskipflipflop;

  hmap->B_crtc.cursorbuffer = 0;

  videoulasetloads();
  videosetdisplayfunctions(&choice);
  videosetreadfunctions();
  if (hmap->A_vidbuf.progressive)
  {
    videorefreshpclippedskipflag(hmap);
    hmap->peripheral_code = videoupdatepadvanceandskipbits(hmap, hmap->peripheral_code, hmap->A_vidbuf.skip);
  }
  else
  {
    videorefreshclippedskipflag(hmap);
    hmap->peripheral_code = videoupdateadvanceandskipbits(hmap, hmap->peripheral_code, hmap->A_vidbuf.skip);
  }

  nclock = clock()+TIME_50HZ;
}

void videohostmodevars(void)
{
  HOSTMAP* hmap = &hostmap;
  int ncolour,log2bpp,i;
  uintptr_t u;
  intptr_t nlineaddress;
  int linescale, steplinelength;
  intptr_t bufferaddress;
  uintptr_t* colournumbers = hmap->D_colour.numbers;
  uintptr_t* colourfill = hmap->D_colour.fill;

  screenstartandlinelength();

  linescale = hmap->A_vidout.linescaletotal;
  hmap->B_vidout.linelength = nhostscreenlinelength;
  hmap->B_vidout.lowoffset = nhostscreenlinelength * ((linescale+1)>>1);

  regs.r[0] = beebit_graphicsmodespecifier;
  regs.r[1] = 3;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  ncolour = regs.r[2];
  regs.r[1] = 9;
  _kernel_swi(OS_ReadModeVariable,&regs,&regs);
  log2bpp = regs.r[2];

  if (ncolour == 15 || ncolour == 255)
  {
    uint32_t fullpalette[256];

    for (i=0; i<8; i++)
    {
      fullpalette[i] = palette_specified[i];
      colournumbers[i+8] = colournumbers[i] = i;
    }
    for (i=8; i<ncolour; i++)
    {
      fullpalette[i] = (i<<24)|(i<<16)|(i<<8);
    }

    regs.r[0] = -1;
    regs.r[1] = -1;
    regs.r[2] = (int)fullpalette;
    regs.r[3] = 0;
    regs.r[4] = 0;
    _kernel_swi(ColourTrans_WritePalette,&regs,&regs);
  }
  else
  {
    for (i=0; i<8; i++)
    {
      regs.r[0] = palette_specified[i];
      _kernel_swi(ColourTrans_ReturnColourNumber,&regs,&regs);
      colournumbers[i+8] = colournumbers[i] = regs.r[0];
    }
  }

  for (i=0; i<8; i++)
  {
    u = colournumbers[i];
    if (log2bpp < 3)
      u |= (u<<4);
    if (log2bpp < 4)
      u |= (u<<8);
    if (log2bpp < 5)
      u |= (u<<16);
    colourfill[i] = u;
  }

  videoscale_init(&videoscale_lutparameters);
  videoulasetcolours();

  nlineaddress = nhostscreen;
  nlineaddress += video_screenstartoffset;
  nlineaddress += video_screenstartline * nhostscreenlinelength;

  steplinelength = nhostscreenlinelength * linescale;

  bufferaddress = hmap->B_vidbuf.synclineaddress - hmap->B_vidbuf.syncline * hmap->B_vidbuf.stride;

  for (i=0; i<hmap->B_vidbuf.stopline; i++)
  {
    ((intptr_t*)bufferaddress)[-1] = nlineaddress;

    nlineaddress += steplinelength;
    bufferaddress += hmap->B_vidbuf.stride;
  }
}

int writeusedcolours(void)
{
  HOSTMAP* hmap = &hostmap;
  const char* const names[8] = {
    "Black",
    "Red",
    "Green",
    "Yellow",
    "Blue",
    "Magenta",
    "Cyan",
    "White"
  };
  const char *columnnames = "\n COLOUR    FILL      VALUE\n";
  int i;
  char buffer[128];
  const unsigned int* colourfill = hmap->D_colour.fill;

  wimpwrite(columnnames,1,strlen(columnnames));

  for (i=0; i<8; i++)
  {
    snprintf(buffer,sizeof(buffer),"%7s  &%08X  &%08X\n",
      names[i],colourfill[i],
      palette_specified[i]);
    wimpwrite(buffer,1,strlen(buffer));
  }

  return 1;
}

void videofreeworkspace(void)
{
  HOSTMAP* hmap = &hostmap;

  hmap->B_vidbuf.column -= hmap->B_vidbuf.offsetsynccolumn;
  hmap->B_vidbuf.line -= hmap->B_vidbuf.syncline;
  hmap->B_vidbuf.setskewop = videoinactivesetskew;

  free(video_workspace);
  video_workspace = NULL;
}

void videoreset(void)
{
  int i;
  HOSTMAP* hmap = &hostmap;
  CRTCSTEPOP crtctaggedops[256] = {
    videoupdatestep, videoupdateH0step, videoupdateB0step, videoupdateB0H0step,
    videoupdateB1step, videoupdateB1H0step, videoupdateB1step, videoupdateB1H0step,
    videoupdateB2step, videoupdateB2H0step, videoupdateB2B0step, videoupdateB2B0H0step,
    videoupdateB2B1step, videoupdateB2B1H0step, videoupdateB2B1step, videoupdateB2B1H0step,

    videoupdateBCstep, videoupdateBCH0step, videoupdateB0step, videoupdateB0H0step,
    videoupdateB1step, videoupdateB1H0step, videoupdateB1step, videoupdateB1H0step,
    videoupdateBCB2step, videoupdateBCB2H0step, videoupdateB2B0step, videoupdateB2B0H0step,
    videoupdateB2B1step, videoupdateB2B1H0step, videoupdateB2B1step, videoupdateB2B1H0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,

    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,
    videoupdateMstep, videoupdateMstep, videoupdateMstep, videoupdateMstep,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,
    videoupdateR0step, videoupdateR0step, videoupdateR0step, videoupdateR0step,

    videoupdateTstep, videoupdateTH0step, videoupdateTB0step, videoupdateTB0H0step,
    videoupdateTB1step, videoupdateTB1H0step, videoupdateTB1step, videoupdateTB1H0step,
    videoupdateTB2step, videoupdateTB2H0step, videoupdateTB2B0step, videoupdateTB2B0H0step,
    videoupdateTB2B1step, videoupdateTB2B1H0step, videoupdateTB2B1step, videoupdateTB2B1H0step,

    videoupdateTBCstep, videoupdateTBCH0step, videoupdateTB0step, videoupdateTB0H0step,
    videoupdateTB1step, videoupdateTB1H0step, videoupdateTB1step, videoupdateTB1H0step,
    videoupdateTBCB2step, videoupdateTBCB2H0step, videoupdateTB2B0step, videoupdateTB2B0H0step,
    videoupdateTB2B1step, videoupdateTB2B1H0step, videoupdateTB2B1step, videoupdateTB2B1H0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,

    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,
    videoupdateTMstep, videoupdateTMstep, videoupdateTMstep, videoupdateTMstep,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,

    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step,
    videoupdateTR0step, videoupdateTR0step, videoupdateTR0step, videoupdateTR0step
  };

  memcpy(hmap->crtctaggedops, crtctaggedops, 256*sizeof(CRTCSTEPOP));

  nclock = clock()+TIME_50HZ;

  hmap->A_crtc.displaycounter = 0;
  hmap->A_crtc.fieldnumber = 0;
  hmap->A_crtc.nextfieldnumber = 0;
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.in_vd = 0;
  hmap->A_crtc.delayvs = 0;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->A_crtc.vs_counting = 0;
  hmap->A_crtc.endframe = ENDFRAMEIDLE;
  hmap->A_crtc.lpstbtimer = 0;

  hmap->A_videoula.shiftregister = 0;

  hmap->A_vidbuf.eventflags = 0;
  hmap->A_vidbuf.fastskipflipflop = 0;
  hmap->A_vidbuf.updateframecounter = 0;
  hmap->A_vidbuf.skip = 0;

  hmap->A_teletext.line = 0;
  hmap->A_teletext.lastline = 9;
  hmap->A_teletext.flipflops = 0;
  hmap->A_teletext.flash = 0;
  hmap->A_teletext.flashstage = 0;
  hmap->A_teletext.flashcounter = 50;

  hmap->B_crtc.step_state = &hmap->crtcstep[VIDEOSTEPIDLEFLAG];
  hmap->B_crtc.cursorcolumn = -1;

  hmap->B_videoula.cursorflags = 0;

  hmap->B_teletext.lookupoffset = 0;
  hmap->B_teletext.holdoffset = 0;
  hmap->B_teletext.queue = 0;
  hmap->B_teletext.colours = 0x00070007;

  hmap->B_vidbuf.displayskewmask = 0x01;
  hmap->B_vidbuf.cursorskewmask = 0x01;
  hmap->B_vidbuf.limitlinecounter = 0;
  hmap->B_vidbuf.column = 0;
  hmap->B_vidbuf.line = 0;
  hmap->B_vidbuf.linelevel = 0;

  for (i=0; i<255; i++)
  {
    hmap->crtccolumntags[i] = 0;
  }
  hmap->crtccolumntags[255] = CRTCMAXCOLUMNTAG;

  for (i=0; i<256; i++)
  {
    hmap->crtcstep[i] = hmap->crtctaggedops[hmap->crtccolumntags[i]];
  }

  for (i=256; i<512; i++)
  {
    hmap->crtcstep[i] = videoidlestep;
  }
}

HOSTMAP* videotopmiddle(HOSTMAP* hmap)
{
  int skew = (hmap->A_crtc.r[8]>>4)&3;
  intptr_t centrecolumn,offset;

  if (skew == 3)
    skew = 0;

  if (hmap->A_videoula.control & 0x10)
    centrecolumn = hmap->B_vidbuf.column + (hmap->A_crtc.r[1]>>1) + skew;
  else
    centrecolumn = hmap->B_vidbuf.column + hmap->A_crtc.r[1] + (skew<<1);

  if (hmap->A_videoula.control & 2)
    centrecolumn += 4;

  offset = (hmap->B_vidbuf.stopcolumn>>1) - centrecolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn + offset;
  hmap->B_vidbuf.column += offset;

  hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.startline - hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
  hmap->B_vidbuf.line = hmap->B_vidbuf.startline;
  hmap->A_vidbuf.skip &= ~BEFOREDISPLAYSKIPFLAG;
  return hmap;
}

HOSTMAP* videofield(HOSTMAP* hmap)
{
  unsigned char fieldnumber = hmap->A_crtc.nextfieldnumber;
  hmap->A_crtc.fieldnumber = fieldnumber;
  hmap->A_crtc.delayvs = hmap->A_crtc.r[8] & (fieldnumber ^ 1);
  hmap->A_crtc.in_vd = 1;
  hmap->A_crtc.endframe = ENDFRAMEIDLE;
  hmap->A_crtc.c4 = 0;
  hmap->A_crtc.vs_thisrow = 0;
  if ((hmap->A_crtc.r[8] & 3) == 3)
    hmap->A_crtc.c9low = hmap->A_crtc.c9 = fieldnumber;
  else
    hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->B_crtc.row_code = hmap->B_crtc.start_code;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoslowblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line < hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
      hmap->B_vidout.lineop(hmap);
    }

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip |= CLIPPEDSKIPFLAG;
  return hmap;
}

HOSTMAP* videofastblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line < hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|FASTSKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
      hmap->B_vidout.lineop(hmap);
    }

    skip ^= FASTSKIPFLAG;

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip = CLIPPEDSKIPFLAG | skip;
  return hmap;
}

void videoyield(void)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)&hostmap;
  int clockdiff;

  r6502startyield(cmap);

  /*if (singletask)
  {*/
  /*sync emulated BBC clock with PC clock*/
  if (beebit_cpuspeed == CPU_2MHZ)
  {
    clockdiff = (int)(clock() - nclock);
    if (clockdiff < 0)
    {
      vsync(); /*wait for native screen vsync*/
      do
      {
        clockdiff = (int)(clock() - nclock);
      } while (clockdiff < 0);
    }
    nclock += clockdiff+TIME_50HZ;
  }
  /*}*/
}

HOSTMAP* videoprogressiveblanklinesdown(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  while (hmap->B_vidbuf.line <= hmap->B_vidbuf.stopline)
  {
    if (!(skip & (CLIPPEDABOVESKIPFLAG|FRAMETIMESKIPFLAG)))
    {
      hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress - hmap->B_vidbuf.stride;
      hmap->B_vidout.lineop(hmap);
    }

    skip &= ~CLIPPEDABOVESKIPFLAG;

    hmap->B_vidbuf.line += 1;
    hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;
  }

  hmap->A_vidbuf.skip = CLIPPEDBELOWSKIPFLAG|CLIPPEDSKIPFLAG|CLIPPEDABOVESKIPFLAG | skip;
  return hmap;
}

static inline HOSTMAP* videoslowenteringvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip |= VSYNCSKIPFLAG;

  systemviasetca1();

  intptr_t offset = hmap->B_vidbuf.offsetsynccolumn - hmap->B_vidbuf.synccolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.column -= offset;

  if (hmap->B_vidbuf.line < 0)
  {
    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
    hmap->B_vidbuf.line = 0;
  }
  return hmap;
}

static inline HOSTMAP* videofastenteringvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip |= VSYNCSKIPFLAG;

  systemviasetca1();

  intptr_t offset = hmap->B_vidbuf.offsetsynccolumn - hmap->B_vidbuf.synccolumn;

  hmap->B_vidbuf.offsetsynccolumn = hmap->B_vidbuf.synccolumn;
  hmap->B_vidbuf.column -= offset;

  if (hmap->B_vidbuf.line < 0)
  {
    if (hmap->B_vidbuf.line & 1)
      hmap->A_vidbuf.skip ^= FASTSKIPFLAG;

    hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
    hmap->B_vidbuf.line = 0;
  }
  return hmap;
}

static inline HOSTMAP* videoupdateframetimeskip(HOSTMAP* hmap)
{
  if (hmap->A_vidbuf.updateframenumber > 0)
  {
    if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
    {
      hmap->A_vidbuf.skip |= FRAMETIMESKIPFLAG;
      hmap->A_vidbuf.updateframecounter = 0;
    }
    else
    {
      hmap->A_vidbuf.updateframecounter++;
      if (hmap->A_vidbuf.updateframecounter == hmap->A_vidbuf.updateframenumber)
      {
        hmap->A_vidbuf.skip &= ~FRAMETIMESKIPFLAG;
      }
    }
  }
  return hmap;
}

static inline HOSTMAP* videoenteringvsynctail(HOSTMAP* hmap)
{
  hmap->B_vidbuf.line = hmap->B_vidbuf.syncline;
  hmap->B_vidbuf.lineaddress = hmap->B_vidbuf.synclineaddress;

  hmap->B_vidbuf.limitlinecounter = 0;

  hmap->A_teletext.line = 0;
  hmap->A_teletext.lastline = 9;

  if (--hmap->A_teletext.flashcounter == 0)
  {
    if (hmap->A_teletext.flashstage & 1)
    {
      hmap->A_teletext.flash = 0;
      hmap->A_teletext.flashcounter = 50;
    }
    else
    {
      hmap->A_teletext.flash = 1;
      if (hmap->A_teletext.flashstage)
        hmap->A_teletext.flashcounter = 17;
      else
        hmap->A_teletext.flashcounter = 16;
    }
    if (++hmap->A_teletext.flashstage == 6)
      hmap->A_teletext.flashstage = 0;
  }
  return hmap;
}

static inline HOSTMAP* videoslowleavingvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip &= ~VSYNCSKIPFLAG;

  systemviaunsetca1();

  hmap->B_vidbuf.linelevel = 54 - (hmap->B_vidbuf.column - hmap->B_vidbuf.synccolumn);
  if (hmap->B_vidbuf.linelevel < 0)
  {
    hmap->B_vidbuf.line -= 1;
    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.stride;
    hmap->B_vidbuf.linelevel += 128;
  }
  return hmap;
}

static inline HOSTMAP* videofastleavingvsynchead(HOSTMAP* hmap)
{
  hmap->A_vidbuf.skip &= ~VSYNCSKIPFLAG;

  systemviaunsetca1();

  hmap->B_vidbuf.linelevel = 54 - (hmap->B_vidbuf.column - hmap->B_vidbuf.synccolumn);
  if (hmap->B_vidbuf.linelevel < 0)
  {
    hmap->A_vidbuf.skip ^= FASTSKIPFLAG;
    hmap->B_vidbuf.line -= 1;
    hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.stride;
    hmap->B_vidbuf.linelevel += 128;
  }
  return hmap;
}

HOSTMAP* videoslowenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoslowblanklinesdown(hmap);
  videoyield();

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipslowenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoslowblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoslowleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videotopmiddleslowleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videofastenteringvsync(HOSTMAP* hmap)
{
  videofastenteringvsynchead(hmap);
  videofastblanklinesdown(hmap);
  videoyield();

  hmap->A_vidbuf.fastskipflipflop ^= FASTSKIPFLAG;

  hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~FASTSKIPFLAG) | hmap->A_vidbuf.fastskipflipflop;

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipfastenteringvsync(HOSTMAP* hmap)
{
  videofastenteringvsynchead(hmap);
  videofastblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  if (!(hmap->A_vidbuf.skip & FRAMETIMESKIPFLAG))
    hmap->A_vidbuf.fastskipflipflop ^= FASTSKIPFLAG;

  hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~FASTSKIPFLAG) | hmap->A_vidbuf.fastskipflipflop;

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videofastleavingvsync(HOSTMAP* hmap)
{
  videofastleavingvsynchead(hmap);
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videotopmiddlefastleavingvsync(HOSTMAP* hmap)
{
  videofastleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  return videorefreshclippedskipflag(hmap);
}

HOSTMAP* videoprogressiveenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoprogressiveblanklinesdown(hmap);
  videoyield();

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoframeskipprogressiveenteringvsync(HOSTMAP* hmap)
{
  videoslowenteringvsynchead(hmap);
  videoprogressiveblanklinesdown(hmap);
  videoyield();
  videoupdateframetimeskip(hmap);

  return videoenteringvsynctail(hmap);
}

HOSTMAP* videoprogressiveleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  videorefreshpclippedskipflag(hmap);
  return hmap;
}

HOSTMAP* videotopmiddleprogressiveleavingvsync(HOSTMAP* hmap)
{
  videoslowleavingvsynchead(hmap);
  hmap->A_vidbuf.skip |= BEFOREDISPLAYSKIPFLAG;
  videorefreshpclippedskipflag(hmap);
  return hmap;
}

static inline int videodummylinerequired(HOSTMAP* hmap)
{
  if (!(hmap->A_crtc.r[8] & 1) || hmap->A_crtc.nextfieldnumber == 0)
    return 0;

  return !(hmap->A_crtc.r[8] & 2) || (hmap->A_crtc.r[9] & 1) == 0 || (hmap->A_crtc.r[4] & 1) != 0;
}

HOSTMAP* videoendframeidle(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  if (hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image)
  {
    if (hmap->A_crtc.r[9] == hmap->A_crtc.r9image)
      hmap->A_crtc.c9 = 0;
    else
    {
      hmap->A_crtc.c9 = hmap->A_crtc.fieldnumber;
      if (!(hmap->A_crtc.r9image&1))
        hmap->A_crtc.c9 ^= (hmap->A_crtc.c4 & 1);
    }
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
    hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
    hmap->A_crtc.vs_thisrow = 0;
  }
  else if (hmap->A_crtc.r[0] > 0)
  {
    hmap->A_crtc.c9 = (hmap->A_crtc.c9 + (hmap->A_crtc.r[9] == hmap->A_crtc.r9image ? 1 : 2)) & 0x1F;
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
  }
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoendframesoon(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  hmap->A_crtc.endframe = ENDFRAMENOADJUST;
  return hmap;
}

HOSTMAP* videoendframenoadjust(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  return hmap;
}

HOSTMAP* videoendframeadjust(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  hmap->A_crtc.c9low = hmap->A_crtc.c9 = 0;
  hmap->A_crtc.c4 = (hmap->A_crtc.c4 + 1) & 0x7F;
  hmap->A_crtc.vs_thisrow = 0;
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  hmap->A_crtc.endframe = ENDFRAMEADJUSTING;
  return hmap;
}

HOSTMAP* videoendframeadjusting(HOSTMAP* hmap)
{
  hmap->A_crtc.in_firstline = 0;
  if (hmap->A_crtc.r[0] > 0)
  {
    hmap->A_crtc.c9 = (hmap->A_crtc.c9 + 1) & 0x1F;
    hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
  }
  hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
  return hmap;
}

HOSTMAP* videoendframeadjustcomplete(HOSTMAP* hmap)
{
  if (videodummylinerequired(hmap))
  {
    hmap->A_crtc.in_firstline = 0;
    if (hmap->A_crtc.r[0] > 0)
    {
      hmap->A_crtc.c9 = (hmap->A_crtc.c9 + 1) & 0x1F;
      hmap->A_crtc.c9low = hmap->A_crtc.c9 & 7;
    }
    hmap->B_crtc.scan_code = (hmap->B_crtc.row_code | (hmap->B_crtc.scan_code&0x3FFFF));
    hmap->A_crtc.endframe = ENDFRAMEDUMMY;
  }
  else
  {
    videofield(hmap);
    hmap->A_crtc.in_firstline = 1;
  }
  return hmap;
}

HOSTMAP* videoendframedummy(HOSTMAP* hmap)
{
  videofield(hmap);
  hmap->A_crtc.in_firstline = 1;
  return hmap;
}

HOSTMAP* teletextafter(HOSTMAP* hmap)
{
  int code = (hmap->B_teletext.queue>>24)&127;

  switch (code)
  {
    case 0x01:
    case 0x02:
    case 0x03:
    case 0x04:
    case 0x05:
    case 0x06:
    case 0x07:
      /*alpha*/
      hmap->A_teletext.flipflops &= NOTCONCEALFLAG;
      if (hmap->A_teletext.flipflops&GRAPHICSFLAG)
      {
        hmap->B_teletext.holdoffset = 0;
        if (hmap->A_teletext.flipflops&SEPARATEDFLAG)
          hmap->B_teletext.lookupoffset -= 40;
        else
          hmap->B_teletext.lookupoffset -= 20;
        hmap->A_teletext.flipflops &= NOTGRAPHICSFLAG;
      }
      hmap->B_teletext.colours = (hmap->B_teletext.colours & ~0xFF)|(code&7);
      break;
    case 0x08:
      /*flash*/
      hmap->A_teletext.flipflops |= FLASHFLAG;
      break;
    case 0x0D:
      /*double height*/
      if (!(hmap->A_teletext.flipflops&DOUBLEHEIGHTFLAG))
      {
        hmap->B_teletext.holdoffset = 0;
        hmap->A_teletext.lastline = 19;
        hmap->B_teletext.lookupoffset += 60;
        hmap->A_teletext.flipflops |= DOUBLEHEIGHTFLAG;
      }
      break;
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
      /*graphic*/
      hmap->A_teletext.flipflops &= NOTCONCEALFLAG;
      if (!(hmap->A_teletext.flipflops&GRAPHICSFLAG))
      {
        hmap->B_teletext.holdoffset = 0;
        if (hmap->A_teletext.flipflops&SEPARATEDFLAG)
          hmap->B_teletext.lookupoffset += 40;
        else
          hmap->B_teletext.lookupoffset += 20;
        hmap->A_teletext.flipflops |= GRAPHICSFLAG;
      }
      hmap->B_teletext.colours = (hmap->B_teletext.colours & ~0xFF)|(code&7);
      break;
    case 0x1F:
      /*release graphics*/
      hmap->A_teletext.flipflops &= NOTHOLDFLAG;
      break;
  }

  return hmap;
}

HOSTMAP* teletextat(HOSTMAP* hmap)
{
  int code = (hmap->B_teletext.queue>>16)&127;
  intptr_t teletextoffset;

  if (code < 32)
  {
    switch (code)
    {
      case 0x09:
        /*steady*/
        hmap->A_teletext.flipflops &= NOTFLASHFLAG;
        break;
      case 0x0C:
        /*normal height*/
        if (hmap->A_teletext.flipflops&DOUBLEHEIGHTFLAG)
        {
          hmap->B_teletext.holdoffset = 0;
          hmap->B_teletext.lookupoffset -= 60;
          hmap->A_teletext.flipflops &= NOTDOUBLEHEIGHTFLAG;
        }
        break;
      case 0x18:
        /*conceal*/
        hmap->A_teletext.flipflops |= CONCEALFLAG;
        break;
      case 0x19:
        /*contiguous*/
        if (hmap->A_teletext.flipflops & SEPARATEDFLAG)
        {
          if (hmap->A_teletext.flipflops & GRAPHICSFLAG)
            hmap->B_teletext.lookupoffset -= 20;
          hmap->A_teletext.flipflops &= NOTSEPARATEDFLAG;
        }
        break;
      case 0x1A:
        /*separated*/
        if (!(hmap->A_teletext.flipflops & SEPARATEDFLAG))
        {
          if (hmap->A_teletext.flipflops & GRAPHICSFLAG)
            hmap->B_teletext.lookupoffset += 20;
          hmap->A_teletext.flipflops |= SEPARATEDFLAG;
        }
        break;
      case 0x1C:
        hmap->B_teletext.colours &= ~0xFF00;
        break;
      case 0x1D:
        hmap->B_teletext.colours = (hmap->B_teletext.colours & ~0xFF00)|((hmap->B_teletext.colours&7)<<8);
        break;
      case 0x1E:
        /*hold graphics*/
        /*hold/release graphics actually affects the way colour-change*/
        /*codes are displayed. normally they are blank; when hold graphics*/
        /*is set, the previous character is displayed again. This allows*/
        /*contiguous blocks of colour.*/
        /*Thanks to Tom Seddon for that bit of information...*/
        hmap->A_teletext.flipflops |= HOLDFLAG;
        break;
    }

    if (!(hmap->A_teletext.flipflops & HOLDFLAG))
      hmap->B_teletext.holdoffset = 0;

    teletextoffset = hmap->B_teletext.holdoffset;
  }
  else
  {
    teletextoffset = hmap->B_teletext.lookupoffset + ((code-32)<<7);

    if ((code & 0x20) && (hmap->A_teletext.flipflops&GRAPHICSFLAG))
      hmap->B_teletext.holdoffset = teletextoffset;
  }

  if ((hmap->A_teletext.flipflops & CONCEALFLAG) || ((hmap->A_teletext.flipflops & FLASHFLAG) && hmap->A_teletext.flash))
    teletextoffset = 0;

  hmap->B_teletext.lue1 = hmap->teletextlinelut[teletextoffset+hmap->A_teletext.line];

  return hmap;
}

HOSTMAP* videoloadteletext(HOSTMAP* hmap, uintptr_t queue)
{
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;

  if (queue&0x8000)
  {
    if (queue&0x800000)
    {
      teletextafter(hmap);
    }
    else
    {
      hmap->B_teletext.colours &= 0xFFFF0000;
      hmap->B_teletext.colours |= 0x00000007;
    }
    teletextat(hmap);
  }
  else
  {
    hmap->B_teletext.lue1 = hmap->teletextlinelut[0];

    if (queue&0x800000)
    {
      hmap->B_teletext.colours &= 0xFFFF0000;
      hmap->A_teletext.flipflops = 0;
      hmap->B_teletext.holdoffset = 0;
      hmap->B_teletext.lookupoffset = 0;

      if (hmap->A_teletext.line < hmap->A_teletext.lastline)
        hmap->A_teletext.line++;
      else
      {
        hmap->A_teletext.line = 0;
        hmap->A_teletext.lastline = 9;
      }
    }
  }

  if (hmap->A_crtc.c9low & 1)
  {
    hmap->A_teletext.roundingdirection1 = 1;
    hmap->B_teletext.lue1 += hmap->B_teletext.lowoffset;
  }
  else
    hmap->A_teletext.roundingdirection1 = 0;
  return hmap;
}

HOSTMAP* videoshiftteletext(HOSTMAP* hmap)
{
  hmap->B_teletext.colours &= 0xFFFF;
  hmap->B_teletext.colours |= (hmap->B_teletext.colours << 16);
  hmap->B_teletext.lue2 = hmap->B_teletext.lue1;
  hmap->A_teletext.roundingdirection2 = hmap->A_teletext.roundingdirection1;
  hmap->B_teletext.lue1 += hmap->B_teletext.rightoffset;
  return hmap;
}

HOSTMAP* videosetscreenstartindex(HOSTMAP* hmap, uint8_t index)
{
  hmap->screenstartindex = index;

  videosetreadfour(&hmap->videoreads[1], &hmap->videographicswrapreads[index<<2]);
  videosetreadfour(&hmap->videoreads[3], &hmap->videoteletextwrapreads[index<<2]);
  return hmap;
}

R6502ZONEMAP* videodisplayoutleft(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  intptr_t column = hmap->B_vidbuf.column + 1;
  hmap->B_vidbuf.column = column;

  if (column >= 0)
    hmap->peripheral_code &= ~VIDEODISPLAYADVANCEMASK;
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

R6502ZONEMAP* videodisplayoutright(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  intptr_t column = hmap->B_vidbuf.column + 1;
  hmap->B_vidbuf.column = column;

  if (column >= hmap->B_vidbuf.limitcolumn)
    hmap->peripheral_code ^= (VIDEODISPLAYSTOP^VIDEODISPLAYOUTRIGHT);
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videoprogressiveleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDABOVESKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress - hmap->B_vidbuf.stride;
    hmap->B_vidout.lineop(hmap);
  }

  if (skip & CLIPPEDSKIPFLAG)
    skip |= CLIPPEDABOVESKIPFLAG;
  else
    skip &= ~CLIPPEDABOVESKIPFLAG;

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
    skip &= ~(CLIPPEDSKIPFLAG|CLIPPEDBELOWSKIPFLAG);
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    skip |= (CLIPPEDSKIPFLAG|CLIPPEDBELOWSKIPFLAG);

  if (hmap->B_vidbuf.line == -1)
    skip &= ~CLIPPEDBELOWSKIPFLAG;
  else if (hmap->B_vidbuf.line + 1 >= hmap->B_vidbuf.stopline)
    skip |= CLIPPEDBELOWSKIPFLAG;
  hmap->A_vidbuf.skip = skip;
  hmap->peripheral_code = videoupdatepskipbit(hmap->peripheral_code, skip);
  return hmap;
}

R6502ZONEMAP* videodisplayprogressivestop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videoprogressiveleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG)|CLIPPEDABOVESKIPFLAG;

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videoprogressiveblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videofastleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG|FASTSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
    hmap->B_vidout.lineop(hmap);
  }

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
    skip &= ~CLIPPEDSKIPFLAG;
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
    skip |= CLIPPEDSKIPFLAG;
  skip ^= FASTSKIPFLAG;
  hmap->A_vidbuf.skip = skip;
  hmap->peripheral_code = videoupdateskipbit(hmap->peripheral_code, skip);
  return hmap;
}

R6502ZONEMAP* videodisplayfaststop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videofastleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        if (hmap->B_vidbuf.line&1)
          hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG)^FASTSKIPFLAG;
        else
          hmap->A_vidbuf.skip = (hmap->A_vidbuf.skip&~CLIPPEDSKIPFLAG);

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videofastblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

static inline HOSTMAP* videoslowleavingline(HOSTMAP* hmap)
{
  uint8_t skip = hmap->A_vidbuf.skip;

  if (!(skip & (CLIPPEDSKIPFLAG|FRAMETIMESKIPFLAG|BEFOREDISPLAYSKIPFLAG)))
  {
    hmap->B_vidbuf.address = hmap->B_vidbuf.lineaddress;
    hmap->B_vidout.lineop(hmap);
  }

  hmap->B_vidbuf.line += 1;
  hmap->B_vidbuf.lineaddress += hmap->B_vidbuf.stride;

  if (hmap->B_vidbuf.line == 0)
  {
    if (skip == CLIPPEDSKIPFLAG)
      hmap->peripheral_code &= ~VIDEODISPLAYSKIP;
    hmap->A_vidbuf.skip = skip & ~CLIPPEDSKIPFLAG;
  }
  else if (hmap->B_vidbuf.line >= hmap->B_vidbuf.stopline)
  {
    if (!skip)
      hmap->peripheral_code |= VIDEODISPLAYSKIP;
    hmap->A_vidbuf.skip = skip | CLIPPEDSKIPFLAG;
  }
  return hmap;
}

R6502ZONEMAP* videodisplayslowstop(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;

  hmap->B_vidbuf.linelevel += 1;
  if (hmap->B_vidbuf.linelevel >= 128)
  {
    hmap->B_vidbuf.linelevel -= 128;
    if (hmap->B_vidbuf.line < hmap->B_vidbuf.limitline)
      videoslowleavingline(hmap);
    else
    {
      hmap->B_vidbuf.limitlinecounter++;
      if (hmap->B_vidbuf.limitlinecounter == 310)
      {
        hmap->A_vidbuf.skip &= ~CLIPPEDSKIPFLAG;

        hmap->B_vidbuf.limitlinecounter = -2;
        hmap->B_vidbuf.lineaddress -= hmap->B_vidbuf.line * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = 0;

        videoslowblanklinesdown(hmap);
        hmap->peripheral_code |= VIDEODISPLAYSKIP;

        hmap->B_vidbuf.lineaddress += (hmap->B_vidbuf.limitline-hmap->B_vidbuf.line) * hmap->B_vidbuf.stride;
        hmap->B_vidbuf.line = hmap->B_vidbuf.limitline;

        videoyield();
      }
    }
  }
  return (R6502ZONEMAP*)(*hmap->B_crtc.step_state)(hmap, (uintptr_t)(hmap->B_crtc.step_state+1));
}

R6502ZONEMAP* videodisplaysyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  uint8_t skip = hmap->A_vidbuf.skip;

  if (skip & VSYNCSKIPFLAG)
  {
    if (!hmap->A_crtc.vs_delayed == !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.leavingvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }
  else
  {
    if (!hmap->A_crtc.vs_delayed != !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.enteringvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }

  if (skip & HSYNCSKIPFLAG)
  {
    if (!(hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC))
    {
      skip &= ~HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_videoula.blacklevelops[peripheral_code&7](zmap, peripheral_code);
    }
  }
  else
  {
    if (hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC)
    {
      skip |= HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_vidbuf.linelevel += hmap->B_vidbuf.column - hmap->B_vidbuf.offsetsynccolumn;
      hmap->B_vidbuf.column = hmap->B_vidbuf.offsetsynccolumn;
    }
  }

  peripheral_code = videoupdateadvanceandskipbits(hmap, peripheral_code & ~VIDEODISPLAYSYNCEDGE, skip);
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplaypsyncedge(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  uint8_t skip = hmap->A_vidbuf.skip;

  if (skip & VSYNCSKIPFLAG)
  {
    if (!hmap->A_crtc.vs_delayed == !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.leavingvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }
  else
  {
    if (!hmap->A_crtc.vs_delayed != !hmap->A_crtc.vs_counting)
    {
      hmap->B_vidbuf.enteringvsyncop(hmap);
      skip = hmap->A_vidbuf.skip;
    }
  }

  if (skip & HSYNCSKIPFLAG)
  {
    if (!(hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC))
    {
      skip &= ~HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_videoula.blacklevelops[peripheral_code&7](zmap, peripheral_code);
    }
  }
  else
  {
    if (hmap->A_vidbuf.eventflags & VIDEOSTEPEVENTHSYNC)
    {
      skip |= HSYNCSKIPFLAG;
      hmap->A_vidbuf.skip = skip;
      hmap->B_vidbuf.linelevel += hmap->B_vidbuf.column - hmap->B_vidbuf.offsetsynccolumn;
      hmap->B_vidbuf.column = hmap->B_vidbuf.offsetsynccolumn;
    }
  }

  peripheral_code = videoupdatepadvanceandskipbits(hmap, peripheral_code & ~VIDEODISPLAYSYNCEDGE, skip);
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplaypossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  if (hmap->A_crtc.in_vd && !(hmap->A_vidbuf.skip & VSYNCSKIPFLAG))
  {
    videotopmiddle(hmap);
    videorefreshclippedskipflag(hmap);
    peripheral_code = videoupdateadvanceandskipbits(hmap, peripheral_code, hmap->A_vidbuf.skip);
  }

  peripheral_code &= ~VIDEODISPLAYPOSSIBLESTART;
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

R6502ZONEMAP* videodisplayppossiblestart(R6502ZONEMAP* zmap, uintptr_t peripheral_code)
{
  HOSTMAP* hmap = (HOSTMAP*)zmap;
  if (hmap->A_crtc.in_vd && !(hmap->A_vidbuf.skip & VSYNCSKIPFLAG))
  {
    videotopmiddle(hmap);
    videorefreshpclippedskipflag(hmap);
    peripheral_code = videoupdatepadvanceandskipbits(hmap, peripheral_code, hmap->A_vidbuf.skip);
  }

  peripheral_code &= ~VIDEODISPLAYPOSSIBLESTART;
  hmap->peripheral_code = peripheral_code;
  return zmap->peripheralops[peripheral_code&0xFF](zmap, peripheral_code);
}

static inline void videostartvsyncdelay(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[0]>>1;

  tags = hmap->crtccolumntags[value] |= CRTCONHALFR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  hmap->A_crtc.vs_delayed = 1;
}

static inline HOSTMAP* videoendvsyncdelay(HOSTMAP* hmap)
{
  uintptr_t tags;
  uint8_t value = hmap->A_crtc.r[0]>>1;

  tags = hmap->crtccolumntags[value] &= ~CRTCONHALFR0COLUMNTAG;
  hmap->crtcstep[value] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[value] = tags;
  hmap->A_crtc.vs_delayed = 0;

  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  return hmap;
}

static inline HOSTMAP* videostartvsync(HOSTMAP* hmap)
{
  hmap->A_crtc.c3v = 0;
  hmap->A_crtc.vs_counting = 1;
  hmap->A_crtc.vs_thisrow = 1;

  if (hmap->A_crtc.delayvs)
    videostartvsyncdelay(hmap);
  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  return hmap;
}

static inline HOSTMAP* videoendvdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.nextfieldnumber = hmap->A_crtc.fieldnumber^1;
  hmap->A_crtc.displaycounter += 1;
  hmap->A_crtc.in_vd = 0;
  return hmap;
}

static inline HOSTMAP* videoendhdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.displaybuffer &= ~VIDEODISPLAYSIGNALINPUT;
  hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  return hmap;
}

static inline HOSTMAP* videoendhdisplaycheckingforendofrow(HOSTMAP* hmap)
{
  if (hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image)
    hmap->B_crtc.row_code = hmap->B_crtc.scan_code & 0xFFFC0000;

  return videoendhdisplay(hmap);
}

static inline HOSTMAP* videostarthdisplay(HOSTMAP* hmap)
{
  hmap->A_crtc.displaybuffer |= VIDEODISPLAYSIGNALINPUT;
  hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  return hmap;
}

static inline HOSTMAP* videoclearrowtestcolumntag(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  uintptr_t tags;
  uint8_t column = (uint8_t)(((CRTCSTEPOP*)incremented_step_state) - 1 - hmap->crtcstep);

  tags = hmap->crtccolumntags[column] & ~CRTCROWTESTCOLUMNTAG;
  hmap->crtcstep[column] = hmap->crtctaggedops[tags];
  hmap->crtccolumntags[column] = tags;
  return hmap;
}

static inline HOSTMAP* videotestrowregisters(HOSTMAP* hmap)
{
  if (hmap->A_crtc.in_vd && hmap->A_crtc.c4 == hmap->A_crtc.r[6] && !hmap->A_crtc.in_firstline)
  {
    videoendvdisplay(hmap);

    if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
      videoendhdisplay(hmap);
  }

  if (hmap->A_crtc.c4 == hmap->A_crtc.r[7] && !hmap->A_crtc.vs_counting && !hmap->A_crtc.vs_thisrow)
    videostartvsync(hmap);

  return hmap;
}

static inline HOSTMAP* videocountvsyncline(HOSTMAP* hmap)
{
  hmap->A_crtc.c3v = (hmap->A_crtc.c3v + 1) & 0xF;
  if (hmap->A_crtc.c3v == ((hmap->A_crtc.r[3]>>4) & 0xF))
  {
    hmap->A_crtc.vs_counting = 0;

    if (hmap->A_crtc.delayvs)
      videostartvsyncdelay(hmap);
    hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  }
  return hmap;
}

static inline HOSTMAP* videoendofline(HOSTMAP* hmap)
{
  hmap->B_crtc.endoflineactions[hmap->A_crtc.endframe](hmap);
  hmap->A_vidbuf.linetestflags |= VIDEOSTEPLINETEST0;
  hmap->B_crtc.scan_code |= VIDEOREADLINETESTFLAG;
  return hmap;
}

static inline HOSTMAP* videostarthsync(HOSTMAP* hmap)
{
  hmap->A_crtc.c3h = 0xF;
  hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
  hmap->A_vidbuf.eventflags |= VIDEOSTEPEVENTHSYNC;
  hmap->B_crtc.scan_code |= VIDEOREADEVENTFLAG;
  return hmap;
}

static inline HOSTMAP* videoincrementscancode(HOSTMAP* hmap)
{
  hmap->B_crtc.scan_code = (hmap->B_crtc.scan_code + 0x40000) & 0xFFFFFFFF;
  return hmap;
}

static inline HOSTMAP* videolinestart(HOSTMAP* hmap)
{
  uint8_t in_display;

  if (hmap->A_crtc.vs_delayed)
    videoendvsyncdelay(hmap);

  if (hmap->A_crtc.vs_counting)
    videocountvsyncline(hmap);

  videoendofline(hmap);

  in_display = hmap->A_crtc.in_vd;

  if (in_display)
  {
    if (hmap->A_crtc.c4 == hmap->A_crtc.r[6] && !hmap->A_crtc.in_firstline)
    {
      videoendvdisplay(hmap);
      in_display = 0;
    }
    else if ((0 == hmap->A_crtc.r[0]) || (0 == hmap->A_crtc.r[1]))
      in_display = 0;
  }

  if (in_display)
  {
    if (!(hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT))
      videostarthdisplay(hmap);
  }
  else if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
  {
    videoendhdisplay(hmap);
  }

  if (hmap->A_crtc.c4 == hmap->A_crtc.r[7] && !hmap->A_crtc.vs_counting && !hmap->A_crtc.vs_thisrow)
    videostartvsync(hmap);

  if (0 == hmap->A_crtc.r[2])
    videostarthsync(hmap);

  return hmap;
}

static inline HOSTMAP* videolineoverflow(HOSTMAP* hmap)
{
  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
  {
    if ((0 == hmap->A_crtc.r[0]) || (0 == hmap->A_crtc.r[1]))
      videoendhdisplay(hmap);
  }

  if (0 == hmap->A_crtc.r[2])
    videostarthsync(hmap);

  return hmap;
}

static inline void videocursorcolumnhit(HOSTMAP* hmap)
{
  uintptr_t cursorsignal;
  int cursordisplay;
  int c9,cstart,cstop;

  cursordisplay = 0;
  switch (hmap->A_crtc.r[10] & 0x60)
  {
    case 0x00:
      cursordisplay = 1;
      break;
    case 0x40:
      if (!(hmap->A_crtc.displaycounter & 8))
        cursordisplay = 1;
      break;
    case 0x60:
      if (!(hmap->A_crtc.displaycounter & 16))
        cursordisplay = 1;
      break;
  }
  if (cursordisplay)
  {
    c9 = hmap->A_crtc.c9;
    cstart = hmap->A_crtc.r[10]&0x1F;
    cstop = hmap->A_crtc.r[11];
    if (c9 >= cstart && c9 <= cstop)
      cursorsignal = VIDEOCURSORSIGNALINPUT;
    else
      cursorsignal = 0;
    if (hmap->A_vidbuf.progressive)
    {
      c9 -= 1;
      if (c9 >= cstart && c9 <= cstop)
      {
        cursorsignal |= (VIDEOCURSORSIGNALINPUT<<VIDEOCURSORSIGNALABOVESHIFT);
      }
      c9 += 2;
      if (c9 >= cstart && c9 <= cstop)
      {
        cursorsignal |= (VIDEOCURSORSIGNALINPUT<<VIDEOCURSORSIGNALBELOWSHIFT);
      }
    }
    if (cursorsignal != 0)
    {
      hmap->B_crtc.cursorbuffer |= cursorsignal;
      hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
    }
  }
}

static inline void videolinestarttagcursorcolumn(HOSTMAP* hmap)
{
  uintptr_t tags;
  intptr_t column = hmap->B_crtc.cursorcolumn;

  if (column > 0)
  {
    column--;
    tags = hmap->crtccolumntags[column] & ~CRTCBEFORECURSORCOLUMNTAG;
    hmap->crtcstep[column] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[column] = tags;
  }

  column = hmap->B_crtc.cursoraddress - (hmap->B_crtc.scan_code>>18);

  if (column > 0 && column <= 256)
  {
    hmap->B_crtc.cursorcolumn = column;
    column--;
    tags = hmap->crtccolumntags[column] | CRTCBEFORECURSORCOLUMNTAG;
    hmap->crtcstep[column] = hmap->crtctaggedops[tags];
    hmap->crtccolumntags[column] = tags;
  }
  else
  {
    hmap->B_crtc.cursorcolumn = -1;

    if (column == 0 && (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT))
      videocursorcolumnhit(hmap);
  }
}

static inline HOSTMAP* videoreadop(HOSTMAP* hmap)
{
  uintptr_t scan_code;

  scan_code = hmap->B_crtc.scan_code;
  return hmap->videoreads[((scan_code&0x3F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoupdateTMstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolineoverflow(hmap);
  videotestrowregisters(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTR0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolinestart(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTB0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videotestrowregisters(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateTstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  videoclearrowtestcolumntag(hmap, incremented_step_state);

  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videotestrowregisters(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateMstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolineoverflow(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateR0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = &hmap->crtcstep[0];

  videoincrementscancode(hmap);
  videolinestart(hmap);
  videolinestarttagcursorcolumn(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videostarthsync(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateBCstep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videocursorcolumnhit(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2B0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB2step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videostarthsync(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB1H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB1step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplaycheckingforendofrow(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB0H0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateB0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  if (hmap->A_crtc.displaybuffer & VIDEODISPLAYSIGNALINPUT)
    videoendhdisplay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdateH0step(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);
  videoendvsyncdelay(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoupdatestep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  hmap->B_crtc.step_state = (CRTCSTEPOP*)incremented_step_state;

  videoincrementscancode(hmap);

  return videoreadop(hmap);
}

HOSTMAP* videoidlestep(HOSTMAP* hmap, uintptr_t incremented_step_state)
{
  uintptr_t scan_code = hmap->B_crtc.scan_code;
  return hmap->videoreads[((scan_code&0x03)<<2)|(scan_code>>30)](hmap, scan_code);
}

static inline uintptr_t videoupdatedisplaysignal(HOSTMAP* hmap, uintptr_t displaybuffer)
{
  if (displaybuffer & hmap->B_vidbuf.displayskewmask)
    hmap->peripheral_code |= VIDEODISPLAYDISPLAY;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYDISPLAY;
  return displaybuffer;
}

static inline uintptr_t videoupdatecursorsignal(HOSTMAP* hmap, uintptr_t cursorbuffer)
{
  if (cursorbuffer & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~VIDEOCURSORSIGNALSEGMENTS)|VIDEOCURSORSIGNALSEGMENT0;
  if (cursorbuffer & VIDEOCURSORSIGNALSEGMENTS)
    hmap->peripheral_code |= VIDEODISPLAYCURSOR;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYCURSOR;
  return cursorbuffer;
}

static inline uintptr_t videoupdatepcursorsignal(HOSTMAP* hmap, uintptr_t cursorbuffer)
{
  if (cursorbuffer & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~VIDEOCURSORSIGNALSEGMENTS)|VIDEOCURSORSIGNALSEGMENT0;
  if ((cursorbuffer>>VIDEOCURSORSIGNALABOVESHIFT) & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~(VIDEOCURSORSIGNALSEGMENTS<<VIDEOCURSORSIGNALABOVESHIFT))|(VIDEOCURSORSIGNALSEGMENT0<<VIDEOCURSORSIGNALABOVESHIFT);
  if ((cursorbuffer>>VIDEOCURSORSIGNALBELOWSHIFT) & hmap->B_vidbuf.cursorskewmask)
    cursorbuffer = (cursorbuffer&~(VIDEOCURSORSIGNALSEGMENTS<<VIDEOCURSORSIGNALBELOWSHIFT))|(VIDEOCURSORSIGNALSEGMENT0<<VIDEOCURSORSIGNALBELOWSHIFT);
  if (cursorbuffer & VIDEOCURSORSIGNALPSEGMENTS)
    hmap->peripheral_code |= VIDEODISPLAYCURSOR;
  else
    hmap->peripheral_code &= ~VIDEODISPLAYCURSOR;
  return cursorbuffer;
}

static inline HOSTMAP* videosetskewmasks(HOSTMAP* hmap, uint8_t r8)
{
  if ((r8 & 0x30) == 0x30)
    hmap->B_vidbuf.displayskewmask = 0;
  else
    hmap->B_vidbuf.displayskewmask = (VIDEODISPLAYSIGNALSKEW0>>((r8>>4)&0x3));
  if ((r8 & 0xC0) == 0xC0)
    hmap->B_vidbuf.cursorskewmask = 0;
  else
    hmap->B_vidbuf.cursorskewmask = (VIDEOCURSORSIGNALSKEW0>>((r8>>6)&0x3));
  return hmap;
}

HOSTMAP* videoreadevent(HOSTMAP* hmap, uintptr_t scan_code)
{
  uint8_t r3h;
  uint8_t eventflags = hmap->A_vidbuf.eventflags;

  if (eventflags & VIDEOSTEPEVENTHSYNC)
  {
    hmap->A_crtc.c3h = (hmap->A_crtc.c3h + 1) & 0xF;
    r3h = hmap->A_crtc.r[3] & 0xF;
    if (hmap->A_crtc.c3h == r3h)
    {
      hmap->peripheral_code |= VIDEODISPLAYSYNCEDGE;
      eventflags &= ~VIDEOSTEPEVENTHSYNC;
      hmap->A_vidbuf.eventflags = eventflags;
    }
  }

  if (eventflags & VIDEOSTEPEVENTLPSTB)
  {
    hmap->A_crtc.lpstbtimer--;
    if (hmap->A_crtc.lpstbtimer == 0)
    {
      hmap->A_crtc.r[16] = scan_code>>26;
      hmap->A_crtc.r[17] = (scan_code>>18)&0xFF;
      eventflags &= ~VIDEOSTEPEVENTLPSTB;
      hmap->A_vidbuf.eventflags = eventflags;
    }
  }

  if (!eventflags)
    scan_code &= ~VIDEOREADEVENTFLAG;

  return hmap->videoreads[((scan_code&0x1F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadlinetest(HOSTMAP* hmap, uintptr_t scan_code)
{
  uint8_t linetestflags = hmap->A_vidbuf.linetestflags;
  uint8_t linetestflagsnext = (linetestflags>>1);

  hmap->A_vidbuf.linetestflags = linetestflagsnext;

  if (!linetestflagsnext)
    scan_code &= ~VIDEOREADLINETESTFLAG;

  if (linetestflags & VIDEOSTEPLINETEST3)
  {
    if (hmap->A_crtc.endframe == ENDFRAMENOADJUST)
      hmap->A_crtc.endframe = ENDFRAMEADJUSTCOMPLETE;
  }

  if (linetestflags & VIDEOSTEPLINETEST2)
  {
    if (hmap->A_crtc.endframe == ENDFRAMESOON)
    {
      if (0 == hmap->A_crtc.r[5])
        hmap->A_crtc.endframe = ENDFRAMENOADJUST;
      else
        hmap->A_crtc.endframe = ENDFRAMEADJUST;
    }
    else if (hmap->A_crtc.endframe == ENDFRAMEADJUSTING)
    {
      if (((hmap->A_crtc.c9 + 1) & 0x1F) == hmap->A_crtc.r[5])
        hmap->A_crtc.endframe = ENDFRAMENOADJUST;
    }
  }

  if (linetestflags & VIDEOSTEPLINETEST1)
  {
    if (hmap->A_crtc.endframe == ENDFRAMEIDLE)
    {
      if ((hmap->A_crtc.c9 == hmap->A_crtc.r[9] || hmap->A_crtc.c9 == hmap->A_crtc.r9image) && hmap->A_crtc.c4 == hmap->A_crtc.r[4])
      {
        hmap->A_crtc.endframe = ENDFRAMESOON;
      }
    }
  }

  if (linetestflags & VIDEOSTEPLINETEST0)
  {
    if (hmap->A_vidbuf.skip & BEFOREDISPLAYSKIPFLAG)
      hmap->peripheral_code |= VIDEODISPLAYPOSSIBLESTART;
  }
  return hmap->videoreads[((scan_code&0x0F)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadcursorsignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t cursorbuffer = hmap->B_crtc.cursorbuffer;

  cursorbuffer = (cursorbuffer>>1) & ~VIDEOCURSORSIGNALSTOPS;
  cursorbuffer = videoupdatecursorsignal(hmap, cursorbuffer);

  if (!cursorbuffer)
    scan_code &= ~VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;
  return hmap->videoreads[((scan_code&0x07)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreadpcursorsignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t cursorbuffer = hmap->B_crtc.cursorbuffer;

  cursorbuffer = (cursorbuffer>>1) & ~VIDEOCURSORSIGNALPSTOPS;
  cursorbuffer = videoupdatepcursorsignal(hmap, cursorbuffer);

  if (!cursorbuffer)
    scan_code &= ~VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;
  return hmap->videoreads[((scan_code&0x07)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoreaddisplaysignal(HOSTMAP* hmap, uintptr_t scan_code)
{
  uintptr_t displaybuffer = hmap->A_crtc.displaybuffer;

  displaybuffer = (displaybuffer&VIDEODISPLAYSIGNALINPUT) | ((displaybuffer>>1) & ~VIDEOCURSORSIGNALSTOPS);
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer == 0x00000000 || displaybuffer == 0x0000000F)
    scan_code &= ~VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;
  return hmap->videoreads[((scan_code&0x03)<<2)|(scan_code>>30)](hmap, scan_code);
}

HOSTMAP* videoinactivesetskew(HOSTMAP* hmap, uint8_t r8)
{
  return videosetskewmasks(hmap, r8);
}

HOSTMAP* videosetskew(HOSTMAP* hmap, uint8_t r8)
{
  uintptr_t displaybuffer;
  uintptr_t cursorbuffer;

  videosetskewmasks(hmap, r8);

  displaybuffer = hmap->A_crtc.displaybuffer;
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer != 0x00000000 && displaybuffer != 0x00000007)
    hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorbuffer = videoupdatecursorsignal(hmap, cursorbuffer);

  if (cursorbuffer)
    hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;

  return hmap;
}

HOSTMAP* videoprogressivesetskew(HOSTMAP* hmap, uint8_t r8)
{
  uintptr_t displaybuffer;
  uintptr_t cursorbuffer;

  videosetskewmasks(hmap, r8);

  displaybuffer = hmap->A_crtc.displaybuffer;
  displaybuffer = videoupdatedisplaysignal(hmap, displaybuffer);

  if (displaybuffer != 0x00000000 && displaybuffer != 0x00000007)
    hmap->B_crtc.scan_code |= VIDEOREADDISPLAYSIGNALFLAG;
  hmap->A_crtc.displaybuffer = displaybuffer;

  cursorbuffer = hmap->B_crtc.cursorbuffer;
  cursorbuffer = videoupdatepcursorsignal(hmap, cursorbuffer);

  if (cursorbuffer)
    hmap->B_crtc.scan_code |= VIDEOREADCURSORSIGNALFLAG;
  hmap->B_crtc.cursorbuffer = cursorbuffer;

  return hmap;
}
