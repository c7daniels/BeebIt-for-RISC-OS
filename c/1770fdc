/*1770fdc.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 */
/*
Type I commands are Restore, Seek, Step, Step In, and Step Out.

   Command      Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
   --------     -----     --     --     --     --     --     --     -----
00 Restore      0         0      0      0      h      V      r1     r0
10 Seek         0         0      0      1      h      V      r1     r0
20 Step         0         0      1      u      h      V      r1     r0
30 Step in      0         1      0      u      h      V      r1     r0
40 Step out     0         1      1      u      h      V      r1     r0

Type II commands are Read Sector and Write Sector.

   Command          Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
   ------------     -----     --     --     --     --     --     --     -----
80 Read Sector      1         0      0      m      h      E      0      0
A0 Write Sector     1         0      1      m      h      E      P      a0

Type III commands are Read Address, Read Track, and Write Track.

   Command          Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
   ------------     -----     --     --     --     --     --     --     -----
C0 Read Address     1         1      0      0      h      E      0      0
E0 Read Track       1         1      1      0      h      E      0      0
F0 Write Track      1         1      1      1      h      E      P      0

The Type IV command is Force Interrupt.
*/

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hostmap.h"
#include "6502cpu.h"
#include "1770fdc.h"
#include "beebit.h"
#include "riscos.h"
#include "kernel.h"
#include "keyboard.h"
#include "swis.h"

/*#define WD1770_DEBUG*/

#define STATUS_MOTORON 0x80
#define STATUS_WRITEPROTECT 0x40
#define STATUS_NOTSPINUP 0x20
#define STATUS_RECORDTYPE 0x20
#define STATUS_NOTFOUND 0x10
#define STATUS_CRCERROR 0x08
#define STATUS_NOTTRACKZERO 0x04
#define STATUS_LOSTDATA 0x04
#define STATUS_INDEX 0x02
#define STATUS_DATAREQUEST 0x02
#define STATUS_BUSY 0x01

#define STATUS_NOTMOTORON 0x7F
#define STATUS_NOTWRITEPROTECT 0xBF
#define STATUS_SPINUP 0xDF
#define STATUS_NOTRECORDTYPE 0xDF
#define STATUS_NOTNOTFOUND 0xEF
#define STATUS_NOTCRCERROR 0xF7
#define STATUS_TRACKZERO 0xFB
#define STATUS_NOTLOSTDATA 0xFB
#define STATUS_NOTINDEX 0xFD
#define STATUS_NOTDATAREQUEST 0xFD
#define STATUS_NOTBUSY 0xFE

#define WD1770_STEPIN 0
#define WD1770_STEPOUT 1
/*single density = 125 Kbits/sec = 1000000*/
#define WD1770_ONEREVOLUTION 200000 /*1000000/5*/

#define SETNMI cmap->nmis |= NMIS_NMI;

#define UNSETNMI cmap->nmis &= (NMIS_NOTNMI & NMIS_NOTOLDNMI);

extern _kernel_swi_regs regs;

char w1770_data[1024]; /*hope we don't get any sectors > 1024 bytes*/

void w1770reset(void)
{
  HOSTMAP* hmap = &hostmap;

  hmap->A_w1770.controlreg = 1;
  hmap->A_w1770.statusreg = 0;
  hmap->A_w1770.trackreg = hmap->A_w1770.track = 0;
  hmap->A_w1770.sectorreg = 0;
  hmap->A_w1770.datareg = 0;
  hmap->A_w1770.commandreg = 0;
  hmap->B_w1770.stepdir = WD1770_STEPIN;
  hmap->B_w1770.steptime = 0;
  hmap->cycles.w1770_togo = 0;
  hmap->B_w1770.lastbyte = FALSE;
  hmap->B_w1770.writegate = FALSE;
}

void w1770readimage(FILE *hfile, int nlocation, int nlength)
{
  if (hfile != NULL)
  {
    fseek(hfile,nlocation,SEEK_SET);
    fread(w1770_data,1,nlength,hfile);
  }
}

void w1770writeimage(FILE *hfile, int nlocation, int nlength)
{
  if (hfile != NULL)
  {
    fseek(hfile,nlocation,SEEK_SET);
    fwrite(w1770_data,1,nlength,hfile);
  }
}

void w1770discread(void)
{
  HOSTMAP* hmap = &hostmap;
  /*ndrive = drive number (0-3)*/
  int ndrive, nlocation, nsize;
  ndrive = hmap->A_w1770.drive+hmap->A_w1770.side;
  if (beebit_imagetype[ndrive] != DFS_NONE)
  {
    switch (beebit_imagetype[ndrive])
    {
      case DFS_SSD:
        nlocation = (hmap->A_w1770.track*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        nsize = DFS_SECTOR_SIZE;
        break;
      case DFS_DSD_TRACK:
        ndrive = hmap->A_w1770.drive;
        nlocation = ((hmap->A_w1770.track*2)*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.side > 0)
          nlocation += DFS_SECTORS_PER_TRACK;
        nsize = DFS_SECTOR_SIZE;
        break;
      case DFS_DSD_SIDE:
        ndrive = hmap->A_w1770.drive;
        nlocation = (hmap->A_w1770.track*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.drive > 0)
          nlocation += beebit_sectorcount[ndrive];
        nsize = DFS_SECTOR_SIZE;
        break;
      case ADFS_NON_INTERLEAVED:
        nlocation = (hmap->A_w1770.track*ADFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        nsize = ADFS_SECTOR_SIZE;
        break;
      case ADFS_INTERLEAVED:
        ndrive = hmap->A_w1770.drive;
        nlocation = ((hmap->A_w1770.track*2)*ADFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.side > 0)
          nlocation += ADFS_SECTORS_PER_TRACK;
        nsize = ADFS_SECTOR_SIZE;
        break;

    }
    #ifdef WD1770_DEBUG
    bbcvdu(68);
    bbcvdu(32);
    inttohex(nlocation);
    #endif

    nlocation = nlocation * nsize;
    #ifdef WD1770_DEBUG
    bbcvdu(32);
    inttohex(nlocation);
    bbcvdu(13);
    bbcvdu(10);
    #endif
    w1770readimage(beebit_driveimage[ndrive], nlocation, nsize);
  }
}

void w1770discwrite(void)
{
  HOSTMAP* hmap = &hostmap;
  /*ndrive = drive number (0-3)*/
  int ndrive, nlocation, nsize;
  ndrive = hmap->A_w1770.drive+hmap->A_w1770.side;
  if (beebit_imagetype[ndrive] != DFS_NONE)
  {
    switch (beebit_imagetype[ndrive])
    {
      case DFS_SSD:
        nlocation = (hmap->A_w1770.track*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        nsize = DFS_SECTOR_SIZE;
        break;
      case DFS_DSD_TRACK:
        ndrive = hmap->A_w1770.drive;
        nlocation = ((hmap->A_w1770.track*2)*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.side > 0)
          nlocation += DFS_SECTORS_PER_TRACK;
        nsize = DFS_SECTOR_SIZE;
        break;
      case DFS_DSD_SIDE:
        ndrive = hmap->A_w1770.drive;
        nlocation = (hmap->A_w1770.track*DFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.drive > 0)
          nlocation += beebit_sectorcount[ndrive];
        nsize = DFS_SECTOR_SIZE;
        break;
      case ADFS_NON_INTERLEAVED:
        nlocation = (hmap->A_w1770.track*ADFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        nsize = ADFS_SECTOR_SIZE;
        break;
      case ADFS_INTERLEAVED:
        ndrive = hmap->A_w1770.drive;
        nlocation = ((hmap->A_w1770.track*2)*ADFS_SECTORS_PER_TRACK)+hmap->A_w1770.sectorreg;
        if (hmap->A_w1770.side > 0)
          nlocation += ADFS_SECTORS_PER_TRACK;
        nsize = ADFS_SECTOR_SIZE;
        break;
    }
    #ifdef WD1770_DEBUG
    bbcvdu(68);
    bbcvdu(32);
    inttohex(nlocation);
    #endif
    nlocation = nlocation * nsize;
    #ifdef WD1770_DEBUG
    bbcvdu(32);
    inttohex(nlocation);
    bbcvdu(13);
    bbcvdu(10);
    #endif
    w1770writeimage(beebit_driveimage[ndrive], nlocation, nsize);
  }
}

HOSTMAP* w1770poll(HOSTMAP* hmap)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  #ifdef WD1770_DEBUG
  bbcvdu(80);
  bbcvdu(32);
  inttohex(hmap->A_w1770.commandreg);
  bbcvdu(32);
  inttohex(hmap->A_w1770.statusreg);
  bbcvdu(13);
  bbcvdu(10);
  #endif
  switch (hmap->A_w1770.commandreg & 0xF0)
  {
    case 0x00:
      /*restore*/
      if (!(hmap->A_w1770.statusreg & STATUS_NOTSPINUP))
      {
        /*disable the motor spin up sequence*/
        hmap->A_w1770.statusreg |= STATUS_NOTSPINUP;
        hmap->A_w1770.statusreg |= STATUS_MOTORON;
        /*verify?*/
      }
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      SETNMI;
      break;
    case 0x10:
      /*seek*/
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      SETNMI;
      break;
    case 0x20:
    case 0x30:
      /*step command*/
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      SETNMI;
    case 0x40:
    case 0x50:
      /*step in command*/
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      SETNMI;
      break;
    case 0x60:
    case 0x70:
      /*step out command*/
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      SETNMI;
      break;
    case 0x80:
    case 0x90:
      /*read sector*/
      if (hmap->B_w1770.lastbyte)
      {
        /*the last byte of the sector has been read*/
        hmap->B_w1770.lastbyte = FALSE;
        if (hmap->A_w1770.commandreg & 0x10)
        {
          /*multiple sector*/
          if (beebit_imagetype[hmap->A_w1770.drive+hmap->A_w1770.side] & ADFS_MASK)
          {
            /*ADFS*/
            if (hmap->A_w1770.sectorreg >= ADFS_SECTORS_PER_TRACK)
              hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
          }
          else
          {
            /*DFS*/
            if (hmap->A_w1770.sectorreg >= DFS_SECTORS_PER_TRACK)
              hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
          }
          hmap->B_w1770.byteinsector = 0;

        }
        else
          hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
        SETNMI
      }
      else
      {
        if (!(hmap->A_w1770.statusreg & STATUS_DATAREQUEST))
        {
          if (hmap->B_w1770.byteinsector == 0)
            w1770discread();
          hmap->A_w1770.datareg = w1770_data[hmap->B_w1770.byteinsector++];
          /*hmap->A_w1770.statusreg &= STATUS_NOTCRCERROR;*/
          hmap->A_w1770.statusreg &= STATUS_NOTRECORDTYPE;
          hmap->A_w1770.statusreg |= STATUS_DATAREQUEST;
          if (beebit_imagetype[hmap->A_w1770.drive+hmap->A_w1770.side] & ADFS_MASK)
            /*ADFS*/
            hmap->B_w1770.lastbyte = (hmap->B_w1770.byteinsector & ADFS_SECTOR_SIZE);
          else
            /*DFS*/
            hmap->B_w1770.lastbyte = (hmap->B_w1770.byteinsector & DFS_SECTOR_SIZE);
          if (hmap->B_w1770.lastbyte)
          {
            /*end of sector*/
            hmap->B_w1770.byteinsector = 0;
            /*hmap->A_w1770.statusreg &= STATUS_NOTBUSY;*/
            hmap->cycles.w1770_togo += (16<<1);
          }
          else
            hmap->cycles.w1770_togo += (64<<1);
          /*hmap->cycles.w1770_togo += (62+(hmap->B_w1770.byteinsector & 1))<<1;*/
          /*SETNMI;*/
        }
        else
          hmap->A_w1770.statusreg |= STATUS_LOSTDATA;
        SETNMI
      }
      break;
    case 0xA0:
    case 0xB0:
      /*write sector*/
      if (!beebit_discwritable[hmap->A_w1770.drive+hmap->A_w1770.side])
      {
        hmap->A_w1770.statusreg |= STATUS_WRITEPROTECT;
        hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
        SETNMI
      }
      else if (!hmap->B_w1770.writegate)
      {
        hmap->cycles.w1770_togo += (64<<1);
        SETNMI
      }
      else
      {
        if (hmap->B_w1770.lastbyte)
        {
          /*the last byte of the sector has been written*/
          hmap->B_w1770.lastbyte = FALSE;
        }
        else
        {
          if (!(hmap->A_w1770.statusreg & STATUS_DATAREQUEST))
          {
            #ifdef WD1770_DEBUG
            bbcvdu(66);
            bbcvdu(32);
            inttohex(hmap->B_w1770.byteinsector);
            bbcvdu(32);
            inttohex(hmap->A_w1770.datareg);
            bbcvdu(13);
            bbcvdu(10);
            #endif
            w1770_data[hmap->B_w1770.byteinsector++] = hmap->A_w1770.datareg;
            /*hmap->A_w1770.statusreg &= STATUS_NOTCRCERROR;*/
            hmap->A_w1770.statusreg &= STATUS_NOTRECORDTYPE;
            hmap->A_w1770.statusreg |= STATUS_DATAREQUEST;

            if (beebit_imagetype[hmap->A_w1770.drive+hmap->A_w1770.side] & ADFS_MASK)
              /*ADFS*/
              hmap->B_w1770.lastbyte = (hmap->B_w1770.byteinsector & ADFS_SECTOR_SIZE);
            else
              /*DFS*/
              hmap->B_w1770.lastbyte = (hmap->B_w1770.byteinsector & DFS_SECTOR_SIZE);
            if (hmap->B_w1770.lastbyte)
            {
              w1770discwrite();
              /*end of sector*/
              hmap->B_w1770.byteinsector = 0;
              /*hmap->A_w1770.statusreg &= STATUS_NOTBUSY;*/
              hmap->cycles.w1770_togo += (16<<1);

              if (hmap->A_w1770.commandreg & 0x10)
              {
                /*multiple sector*/
                if (beebit_imagetype[hmap->A_w1770.drive+hmap->A_w1770.side] & ADFS_MASK)
                {
                  /*ADFS*/
                  if (hmap->A_w1770.sectorreg >= ADFS_SECTORS_PER_TRACK)
                    hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
                }
                else
                {
                  /*DFS*/
                  if (hmap->A_w1770.sectorreg >= DFS_SECTORS_PER_TRACK)
                    hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
                }
                hmap->B_w1770.byteinsector = 0;
              }
              else
                hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
              SETNMI
            }
            else
              hmap->cycles.w1770_togo += (64<<1);
            /*hmap->cycles.w1770_togo += (62+(hmap->B_w1770.byteinsector & 1))<<1;*/
            /*SETNMI;*/
          }
          else
            hmap->A_w1770.statusreg |= STATUS_LOSTDATA;
          SETNMI
        }
      }
      break;
    case 0xC0:
      /*read address*/
      switch (hmap->B_w1770.byteinsector)
      {
        case 0:
          hmap->A_w1770.datareg = hmap->A_w1770.track;
          break;
        case 1:
          hmap->A_w1770.datareg = hmap->A_w1770.side;
          break;
        case 2:
          hmap->A_w1770.datareg = hmap->A_w1770.sectorreg;
          break;
        case 3:
          /*sector length*/
          hmap->A_w1770.datareg = 1;
          break;
        case 4:
        case 5:
          hmap->A_w1770.datareg = 0;
          break;
        default:
          hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      }
      hmap->B_w1770.byteinsector++;
      SETNMI
      break;
    case 0xD0:
    case 0xE0:
    case 0xF0:
      break;
  }

  if ((cmap->nmis & NMIS_NMI) AND !(cmap->nmis & NMIS_OLDNMI))
  {
    r6502startinterrupt(cmap);
  }
  return hmap;
}

void w1770type1flags(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  /*step time*/
  switch (nvalue & 0x03)
  {
    case 0x00:
      hmap->B_w1770.steptime = 6000;
      break;
    case 0x01:
      hmap->B_w1770.steptime = 12000;
      break;
    case 0x02:
      hmap->B_w1770.steptime = 20000;
      break;
    case 0x03:
      hmap->B_w1770.steptime = 30000;
      break;
  }

  /*verify flag*/
  if (nvalue & 0x04)
    hmap->cycles.w1770_togo += (30000<<1); /*30ms*/

  hmap->A_w1770.statusreg |= STATUS_BUSY;
  hmap->A_w1770.statusreg &= STATUS_NOTDATAREQUEST;
  hmap->A_w1770.statusreg &= STATUS_NOTCRCERROR;
  hmap->A_w1770.statusreg &= STATUS_NOTNOTFOUND;
  UNSETNMI

  /*motor on*/
  if (nvalue & 0x08)
  {
    /*disable the motor spin up sequence*/
    hmap->A_w1770.statusreg |= STATUS_NOTSPINUP;
    hmap->cycles.w1770_togo += (WD1770_ONEREVOLUTION<<1);
  }
  else
  {
    if (!(hmap->A_w1770.statusreg & STATUS_MOTORON))
    {
      /*the motor is off*/
      /*turn motor on*/
      hmap->A_w1770.statusreg |= STATUS_MOTORON;
      hmap->A_w1770.statusreg &= STATUS_SPINUP;
      /*wait 6 revolutions*/
      hmap->cycles.w1770_togo += ((WD1770_ONEREVOLUTION<<1)*6);
    }
  }
}

void w1770commandrestore(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type1flags(nvalue);
  if (hmap->A_w1770.track == 0)
    hmap->A_w1770.trackreg = 0;
  else
  {
    if (hmap->A_w1770.track <= 255)
    {
      hmap->A_w1770.track = hmap->A_w1770.trackreg = 0;
      hmap->A_w1770.statusreg &= STATUS_TRACKZERO;
    }
    else
    {
      hmap->A_w1770.track -= 0xFF;
      if (nvalue & 0x04)
        hmap->A_w1770.statusreg |= STATUS_NOTTRACKZERO;
    }
  }
  if (hmap->cycles.w1770_togo <= 0)
    hmap->cycles.w1770_togo = 1;
}

void w1770commandseek(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type1flags(nvalue);
  hmap->A_w1770.trackreg = hmap->A_w1770.track = hmap->A_w1770.datareg;
  if (hmap->cycles.w1770_togo <= 0)
    hmap->cycles.w1770_togo = 1;
}

void w1770commandstep(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type1flags(nvalue);
  switch (hmap->B_w1770.stepdir)
  {
    case WD1770_STEPIN:
      hmap->A_w1770.track++;
      break;
    case WD1770_STEPOUT:
      hmap->A_w1770.track--;
      break;
  }
  /*update track register*/
  if (hmap->A_w1770.commandreg & 0x10)
    hmap->A_w1770.trackreg = hmap->A_w1770.track = hmap->A_w1770.track;

  hmap->cycles.w1770_togo += (hmap->B_w1770.steptime<<1);
}

void w1770commandstepin(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type1flags(nvalue);
  hmap->A_w1770.track++;
  hmap->B_w1770.stepdir = WD1770_STEPIN;
  /*update track register*/
  if (hmap->A_w1770.commandreg & 0x10)
    hmap->A_w1770.trackreg = hmap->A_w1770.track = hmap->A_w1770.track;

  hmap->cycles.w1770_togo += (hmap->B_w1770.steptime<<1);
}

void w1770commandstepout(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type1flags(nvalue);
  hmap->A_w1770.track--;
  hmap->B_w1770.stepdir = WD1770_STEPOUT;
  /*update track register*/
  if (hmap->A_w1770.commandreg & 0x10)
    hmap->A_w1770.trackreg = hmap->A_w1770.track;

  hmap->cycles.w1770_togo += (hmap->B_w1770.steptime<<1);
}

void w1770type2flags(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  hmap->A_w1770.statusreg |= STATUS_BUSY;
  hmap->A_w1770.statusreg &= STATUS_NOTLOSTDATA;
  hmap->A_w1770.statusreg &= STATUS_NOTNOTFOUND;
  hmap->A_w1770.statusreg &= STATUS_NOTRECORDTYPE;
  hmap->A_w1770.statusreg &= STATUS_NOTWRITEPROTECT;
  UNSETNMI

  /*motor on*/
  if (nvalue & 0x08)
  {
    /*disable the motor spin up sequence*/
    hmap->A_w1770.statusreg |= STATUS_NOTSPINUP;
    hmap->cycles.w1770_togo += (WD1770_ONEREVOLUTION<<1);
  }
  else
  {
    if (!(hmap->A_w1770.statusreg & STATUS_MOTORON))
    {
      /*the motor is off*/
      /*turn motor on*/
      hmap->A_w1770.statusreg |= STATUS_MOTORON;
      hmap->A_w1770.statusreg &= STATUS_SPINUP;
      /*wait 6 revolutions*/
      hmap->cycles.w1770_togo += ((WD1770_ONEREVOLUTION<<1)*6);
    }
  }

  if (nvalue & 0x04)
    /*settling delay 30ms*/
    hmap->cycles.w1770_togo += (30000<<1);
}

void w1770commandreadsector(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type2flags(nvalue);
  hmap->A_w1770.statusreg &= STATUS_NOTDATAREQUEST;
  hmap->B_w1770.byteinsector = 0;

  /*an underestimate of the time to recognise and read the first byte in the sector*/
  hmap->cycles.w1770_togo += (320<<1);
}

void w1770commandwritesector(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type2flags(nvalue);

  if (beebit_discwritable[hmap->A_w1770.drive+hmap->A_w1770.side])
    hmap->A_w1770.statusreg |= STATUS_DATAREQUEST;

  hmap->B_w1770.byteinsector = 0;

  hmap->B_w1770.writegate = FALSE;

  /*an underestimate of the time to recognise the first byte in the sector*/
  hmap->cycles.w1770_togo += (256<<1);
}

void w1770type3flags(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  hmap->A_w1770.statusreg |= STATUS_BUSY;
  hmap->A_w1770.statusreg &= STATUS_NOTDATAREQUEST;
  hmap->A_w1770.statusreg &= STATUS_NOTLOSTDATA;
  hmap->A_w1770.statusreg &= STATUS_NOTNOTFOUND;
  hmap->A_w1770.statusreg &= STATUS_NOTRECORDTYPE;
  UNSETNMI

  /*motor on*/
  if (nvalue & 0x08)
  {
    /*disable the motor spin up sequence*/
    hmap->A_w1770.statusreg |= STATUS_NOTSPINUP;
    hmap->cycles.w1770_togo += (WD1770_ONEREVOLUTION<<1);
  }
  else
  {
    if (!(hmap->A_w1770.statusreg & STATUS_MOTORON))
    {
      /*the motor is off*/
      /*turn motor on*/
      hmap->A_w1770.statusreg |= STATUS_MOTORON;
      hmap->A_w1770.statusreg &= STATUS_SPINUP;
      /*wait 6 revolutions*/
      hmap->cycles.w1770_togo += ((WD1770_ONEREVOLUTION<<1)*6);
    }
  }

  if (nvalue & 0x04)
    /*settling delay 30ms*/
    hmap->cycles.w1770_togo += (30000<<1);
}

void w1770commandreadaddress(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  w1770type3flags(nvalue);
  hmap->B_w1770.byteinsector = 0;
  if (hmap->cycles.w1770_togo <= 0)
    hmap->cycles.w1770_togo = 1;
}

void w1770commandreadtrack(char nvalue)
{
  /*bbcvdu(33);
  bbcvdu(33);*/
}

void w1770commandwritetrack(char nvalue)
{
  /*bbcvdu(33);
  bbcvdu(33);*/
}

void w1770forceinterruptcommand(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
  switch (nvalue & 0x0C)
  {
    case 0x00:
      /*stop command*/
      break;
    case 0x04:
      break;
    case 0x08:
      SETNMI
      hmap->A_w1770.commandreg = 0xD0;
      break;
    case 0x0C:
      SETNMI
      hmap->A_w1770.commandreg = 0xD0;
      break;
  }
  hmap->A_w1770.datareg = 0;

  if ((cmap->nmis & NMIS_NMI) AND !(cmap->nmis & NMIS_OLDNMI))
  {
    r6502startinterrupt(cmap);
  }
}

void w1770command(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t cyclecount;
  /*bbcvdu(67);
  bbcvdu(32);
  inttohex(nvalue);
  bbcvdu(32);
  inttohex(hmap->A_w1770.statusreg);
  bbcvdu(32);*/
  /*if a command is issued, it is executed immediately*/
  hmap->cycles.w1770_togo = 0;

  switch (nvalue & 0xF0)
  {
    case 0x00:
      /*restore*/
      w1770commandrestore(nvalue);
      break;
    case 0x10:
      /*seek*/
      w1770commandseek(nvalue);
      break;
    case 0x20:
    case 0x30:
      /*step command*/
      w1770commandstep(nvalue);
    case 0x40:
    case 0x50:
      /*step in command*/
      w1770commandstepin(nvalue);
      break;
    case 0x60:
    case 0x70:
      /*step out command*/
      w1770commandstepout(nvalue);
      break;
    case 0x80:
    case 0x90:
      /*read sector*/
      /*if (nvalue & 0x10)
      {
  bbcvdu(35);
  bbcvdu(35);
  regs.r[0] = 0x81;
  regs.r[1] = 0x40;
  regs.r[2] = 0x01;
  _kernel_swi(OS_Byte,&regs,&regs);
      }*/
      w1770commandreadsector(nvalue);
      break;
    case 0xA0:
    case 0xB0:
      /*write sector*/
      w1770commandwritesector(nvalue);
      break;
    case 0xC0:
      /*read address*/
      w1770commandreadaddress(nvalue);
    case 0xD0:
      /*force interrupt*/
      w1770forceinterruptcommand(nvalue);
      break;
    case 0xE0:
      /*read track*/
      w1770commandreadtrack(nvalue);
      break;
    case 0xF0:
      /*write track*/
      w1770commandwritetrack(nvalue);
      break;
  }
  /*bbcvdu(67);
  bbcvdu(32);
  inttohex(nvalue);
  bbcvdu(32);
  inttohex(hmap->A_w1770.statusreg);
  bbcvdu(32);*/

  if (hmap->cycles.w1770_togo > 0)
  {
    HOSTMAP_GET_TOGO_FROM_WRITE_OFFSET(cyclecount, hmap)
    hmap->cycles.w1770_togo += 1 + cyclecount;
    HOSTMAP_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.w1770_togo)
  }
}

HOSTMAP* w1770controlread(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_w1770.controlreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770controlwrite_bp(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_w1770.controlreg = hmap->m;
  hmap->A_w1770.density = (hmap->m & 0x08);
  hmap->A_w1770.side = ((hmap->m & 0x04) >> 1); /*0 or 2*/
  hmap->A_w1770.drive = ((hmap->m & 0x03) >> 1);
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770controlwrite_m(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_w1770.controlreg = hmap->m;
  hmap->A_w1770.density = (hmap->m & 0x20);
  hmap->A_w1770.side = ((hmap->m & 0x10) >> 3); /*0 or 2*/
  hmap->A_w1770.drive = ((hmap->m & 0x03) >> 1);
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770statusread(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  UNSETNMI;
  hmap->m = hmap->A_w1770.statusreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770trackread(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_w1770.trackreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770sectorread(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_w1770.sectorreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770dataread(HOSTMAP* hmap, uintptr_t address_code)
{
  if (hmap->A_w1770.commandreg & 0x80)
    hmap->A_w1770.statusreg &= STATUS_NOTDATAREQUEST;
  hmap->m = hmap->A_w1770.datareg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770commandwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  UNSETNMI;
  /*command words are only loaded in the command register when the busy status bit is off (status bit 0)*/
  if (hmap->A_w1770.statusreg & STATUS_BUSY)
  {
    if ((hmap->m & 0xF0) == 0xD0)
    {
      hmap->A_w1770.commandreg = hmap->m;
      w1770command(hmap->m);
    }
  }
  else
  {
    if (beebit_imagetype[hmap->A_w1770.drive+hmap->A_w1770.side] == DFS_NONE)
    {
      hmap->A_w1770.statusreg &= STATUS_NOTBUSY;
      hmap->A_w1770.statusreg |= STATUS_NOTFOUND;
    }
    else
    {
      hmap->A_w1770.commandreg = hmap->m;
      w1770command(hmap->m);
    }
  }
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770trackwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_w1770.trackreg = hmap->A_w1770.track = hmap->m;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770sectorwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_w1770.sectorreg = hmap->m;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* w1770datawrite(HOSTMAP* hmap, uintptr_t address_code)
{
  if (hmap->A_w1770.commandreg & 0x80)
  {
    hmap->A_w1770.statusreg &= STATUS_NOTDATAREQUEST;
    hmap->B_w1770.writegate = TRUE;
  }
  hmap->A_w1770.datareg = hmap->m;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}
