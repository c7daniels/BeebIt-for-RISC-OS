/*>8271.c
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * (C) Copyright Michael J Foot, 1998-2024
 *
 * Email: <mjfoot.nz@gmail.com>
 *
 * Addressing optimization contributed by Crispian Daniels in 2024
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

/*reads/writes one byte every 80us (160 2MHz cycles)*/

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hostmap.h"
#include "6502cpu.h"
#include "8271fdc.h"
#include "beebit.h"
#include "riscos.h"
#include "keyboard.h"

#ifdef __DEVELOP__
  extern FILE *htrace;
#else
  #ifdef __DEBUG__
    extern FILE *htrace;
  #endif
#endif

/*Intel 8271*/
char i8271_data[0x1000]; /*hope we don't get any sectors > 4096 bytes*/

/* The following table is used to parse commands from the command number written into
the command register - it can't distinguish between subcommands selected from the
first parameter */
/*command number, mask, number of parameters*/
int acommandlookup[20][2] = {
  {0x00, 5}, /*Scan Data (Variable Length/Multi-Record)*/
  {0x04, 5}, /*Scan Data & deleted data (Variable Length/Multi-Record)*/
  {0x0A, 2}, /*Write Data (128 byte/single record)*/
  {0x0B, 3}, /*Write Data (Variable Length/Multi-Record)*/
  {0x0E, 2}, /*Write Deleted Data*/
  {0x0F, 3}, /*Write Deleted Data*/
  {0x12, 2}, /*Read Data (128 byte/single record)*/
  {0x13, 3}, /*Read Data (Variable Length/Multi-Record)*/
  {0x16, 2},
  {0x17, 3}, /*Read Data and Deleted Data (Variable Length/Multi-Record)*/
  {0x1B, 3}, /*Read ID*/
  {0x1E, 2},
  {0x1F, 3}, /*Verify Data and Deleted Data (Variable Length/Multi-Record)*/
  {0x23, 5}, /*Format*/
  {0x29, 1}, /*Seek*/
  {0x2C, 0}, /*Read drive status*/
  {0x35, 4}, /*Specify*/
  {0x3A, 2}, /*Write special registers*/
  {0x3D, 1}, /*Read special registers*/
  {0,    0}  /*Terminator due to 0 mask matching all*/
};

void i8271setnmi(void)
{
  HOSTMAP* hmap = &hostmap;
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  if (hmap->A_i8271.statusreg & 8)
    cmap->nmis |= NMIS_NMI;
  else
    cmap->nmis &= (NMIS_NOTNMI & NMIS_NOTOLDNMI);
}

static void i8271addtotimer(int cycles)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t cyclesin;

  if (hmap->cycles.i8271_togo > 0)
  {
    hmap->cycles.i8271_togo += cycles;
  }
  else
  {
    cyclesin = hmap->cycles.original - hmap->cycles.togo;

    hmap->cycles.i8271_togo = cyclesin + cycles;

    HOSTMAP_LIMIT_CYCLES_TO_GO(hmap, hmap->cycles.i8271_togo)
  }
}

void i8271reset(void)
{
  HOSTMAP* hmap = &hostmap;
  hmap->A_i8271.resultreg = 0;
  hmap->A_i8271.statusreg = 0;
  hmap->B_i8271.writestart = FALSE;
  i8271setnmi();
  hmap->B_i8271.ncommandid=-1;
  hmap->B_i8271.ncommandparams=0;
  hmap->B_i8271.PresentParam=0;
  hmap->B_i8271.ninerror = FALSE;
  hmap->A_i8271.scansector = 0;
  hmap->A_i8271.scancountmsb = 0;
  hmap->A_i8271.scancountlsb = 0;
  hmap->A_i8271.modereg = 0;
  hmap->A_i8271.outputport = 0;
  hmap->A_i8271.inputport = 0;
  hmap->cycles.i8271_togo = 0;

  /*0/1 for surface number*/
  hmap->A_i8271.currenttrack[0] = 0;
  hmap->A_i8271.currenttrack[1] = 0;
  /*[surface 0/1][badtrack 0/1]*/
  hmap->A_i8271.badtrack[0][0] = 0xFF;
  hmap->A_i8271.badtrack[0][1] = 0xFF;
  hmap->A_i8271.badtrack[1][0] = 0xFF;
  hmap->A_i8271.badtrack[1][1] = 0xFF;
}

void i8271closedown(void)
{
  /*if (i8271_driveimage[0])
    fclose(i8271_driveimage[0]);
  if (i8271_driveimage[1])
    fclose(i8271_driveimage[1]);*/
}

void inerror(int nerror)
{
  HOSTMAP* hmap = &hostmap;
  hmap->B_i8271.ninerror = nerror;
  hmap->A_i8271.statusreg = 0x80;
  i8271setnmi();
  i8271addtotimer(50<<1);
}

void i8271readimage(FILE *hfile, intptr_t nlocation, intptr_t nlength)
{
  if (hfile != NULL)
  {
    fseek(hfile,nlocation,SEEK_SET);
    fread(i8271_data,1,nlength,hfile);
  }
}

int discload(void)
{
  HOSTMAP* hmap = &hostmap;
  /*hmap->B_i8271.ncurrentdrive = drive number (0-3)*/
  intptr_t ndrive, nlocation;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] != DFS_NONE)
  {
    ndrive = hmap->B_i8271.ncurrentdrive;
    switch (beebit_imagetype[ndrive])
    {
      case DFS_SSD:
        nlocation = (hmap->B_i8271.CurrentTrack*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        break;
      case DFS_DSD_TRACK:
        ndrive = ((ndrive>>1) & 1);
        nlocation = ((hmap->B_i8271.CurrentTrack*2)*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        nlocation += (ndrive*DFS_SECTORS_PER_TRACK);
        ndrive = (hmap->B_i8271.ncurrentdrive & 1);
        break;
      case DFS_DSD_SIDE:
        ndrive = ((ndrive>>1) & 1);
        nlocation = (hmap->B_i8271.CurrentTrack*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        if (ndrive > 0)
          nlocation += beebit_sectorcount[hmap->B_i8271.ncurrentdrive];
        ndrive = (hmap->B_i8271.ncurrentdrive & 1);
        break;
    }
    nlocation = nlocation*hmap->B_i8271.SectorLength;
    /*inttohex8(hmap->B_i8271.CurrentTrack);
    bbcvdu(32);
    inttohex8(hmap->B_i8271.CurrentSector);
    bbcvdu(32);
    inttohex8(hmap->B_i8271.SectorLength);
    bbcvdu(32);
    inttohex8(nlocation);
    bbcvdu(13);
    bbcvdu(10);*/
    /*if (nlocation > 0x32000)
      return (FALSE);
    else
    {*/
      i8271readimage(beebit_driveimage[ndrive], nlocation, hmap->B_i8271.SectorLength);
      return (TRUE);
    /*}*/
  }
  else
    return (FALSE);
}

void discsave(void)
{
  HOSTMAP* hmap = &hostmap;
  /*hmap->B_i8271.ncurrentdrive = drive number (0-3)*/
  intptr_t ndrive;
  intptr_t nlocation;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] != DFS_NONE)
  {
    ndrive = hmap->B_i8271.ncurrentdrive;
    switch (beebit_imagetype[ndrive])
    {
      case DFS_SSD:
        nlocation = (hmap->B_i8271.CurrentTrack*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        break;
      case DFS_DSD_TRACK:
        ndrive = ((ndrive>>1) & 1);
        nlocation = ((hmap->B_i8271.CurrentTrack*2)*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        nlocation += (ndrive*DFS_SECTORS_PER_TRACK);
        ndrive = (hmap->B_i8271.ncurrentdrive & 1);
        break;
      case DFS_DSD_SIDE:
        ndrive = ((ndrive>>1) & 1);
        nlocation = (hmap->B_i8271.CurrentTrack*DFS_SECTORS_PER_TRACK)+hmap->B_i8271.CurrentSector;
        if (ndrive > 0)
          nlocation += beebit_sectorcount[hmap->B_i8271.ncurrentdrive];
        ndrive = (hmap->B_i8271.ncurrentdrive & 1);
        break;
    }
    nlocation = nlocation*hmap->B_i8271.SectorLength;
    fseek(beebit_driveimage[ndrive],nlocation,SEEK_SET);
    fwrite(i8271_data,1,hmap->B_i8271.SectorLength,beebit_driveimage[ndrive]);
  }
}

/* write data interrupt
 */
void i8271interrupt0B(void)
{
  HOSTMAP* hmap = &hostmap;
  int nlastbyte;
  if (hmap->B_i8271.SectorsToGo < 0)
  {
    /*result and interrupt*/
    hmap->A_i8271.statusreg = 0x18;
    i8271setnmi();
    return;
  }
  hmap->A_i8271.resultreg = 0;
  nlastbyte = FALSE;
  if (hmap->B_i8271.writestart)
    hmap->B_i8271.writestart = FALSE;
  else
  {
    i8271_data[hmap->B_i8271.ByteWithinSector++] = hmap->A_i8271.datareg;
    if (hmap->B_i8271.ByteWithinSector >= hmap->B_i8271.SectorLength)
    {
      hmap->B_i8271.ByteWithinSector = 0;
      /* I don't know if this can cause the thing to step - I presume not for the moment */
      /*fprintf(htrace,"writeinterrupt1 STG=%u\n",hmap->B_i8271.SectorsToGo);*/
      /*fprintf(htrace,"WRITE %u %u %u\n",hmap->B_i8271.CurrentTrack,hmap->B_i8271.CurrentSector,hmap->B_i8271.SectorsToGo);*/
      discsave();
      /*hmap->B_i8271.SectorsToGo--;*/
      if (--hmap->B_i8271.SectorsToGo)
      {
        hmap->B_i8271.CurrentSector++;
      }
      else
      {
        /*last sector done*/
        nlastbyte = TRUE;
        /*turn drive select off*/
        /*hmap->A_i8271.select = (hmap->A_i8271.select & !(1<<hmap->B_i8271.ncurrentdrive));*/
        hmap->A_i8271.statusreg = 0x10;
        hmap->B_i8271.SectorsToGo = -1; /* To let us bail out */
        i8271setnmi();
        /*i8271_timer += hmap->B_i8271.steprate;*/
        hmap->cycles.i8271_togo += (80<<1);
      }
    }
  }
  /*fprintf(htrace,"LAST BYTE=&%X\n",nlastbyte);
  fprintf(htrace,"writeinterrupt2 STG=%u\n",hmap->B_i8271.SectorsToGo);*/
  if (!nlastbyte)
  {
    hmap->A_i8271.statusreg = 0x8C; /* Command busy, */
    i8271setnmi();
    hmap->cycles.i8271_togo += (80<<1);
  }
  /*fprintf(htrace,"RESULTREG=%u\n",hmap->A_i8271.resultreg);*/
}

/* read interrupt
 */
void i8271interrupt13(void)
{
  HOSTMAP* hmap = &hostmap;
  int nlastbyte;
  if (hmap->B_i8271.SectorsToGo < 0)
  {
    hmap->A_i8271.statusreg = 0x18; /* Result and interrupt */
    i8271setnmi();
    return;
  }

  nlastbyte = FALSE;
  hmap->A_i8271.datareg = i8271_data[hmap->B_i8271.ByteWithinSector++];
  hmap->A_i8271.resultreg = 0;
  if (hmap->B_i8271.ByteWithinSector >= hmap->B_i8271.SectorLength)
  {
    hmap->B_i8271.ByteWithinSector = 0;
    /*I don't know if this can cause the thing to step - I presume not for the moment*/
    if (--hmap->B_i8271.SectorsToGo)
    {
      hmap->B_i8271.CurrentSector++;
      /*fprintf(htrace,"READ %u %u\n",hmap->B_i8271.CurrentTrack,hmap->B_i8271.CurrentSector);*/
      discload();
    }
    else
    {
      /* Last sector done */
      nlastbyte = TRUE;
      /*turn drive select off*/
      hmap->A_i8271.select = (hmap->A_i8271.select & !(1<<hmap->B_i8271.ncurrentdrive));
      hmap->A_i8271.statusreg = 0x9C;
      hmap->B_i8271.SectorsToGo = -1; /* To let us bail out */
      i8271setnmi();
      /*i8271_timer += hmap->B_i8271.steprate;*/
      hmap->cycles.i8271_togo += (80<<1);
    }
  }

  if (!nlastbyte)
  {
    hmap->A_i8271.statusreg = 0x8C; /* Command busy, */
    i8271setnmi();
    hmap->cycles.i8271_togo += (80<<1);
  }
}

/* verify data and deleted data
 */
void i8271interrupt1F(void)
{
  HOSTMAP* hmap = &hostmap;
  /*result with interrupt*/
  hmap->A_i8271.statusreg = 0x18;
  i8271setnmi();
  /*all ok*/
  hmap->A_i8271.resultreg = 0;
}

/*format interrupt
 */
void i8271interrupt23(void)
{
  HOSTMAP* hmap = &hostmap;
  int nlastbyte;
  if (hmap->B_i8271.SectorsToGo < 0)
  {
    /*result and interrupt*/
    hmap->A_i8271.statusreg = 0x18;
    i8271setnmi();
    return;
  }
  hmap->A_i8271.resultreg = 0;
  nlastbyte = FALSE;
  if (hmap->B_i8271.writestart)
    hmap->B_i8271.writestart = FALSE;
  else
  {
    i8271_data[hmap->B_i8271.ByteWithinSector++] = 0xE5;
    if (hmap->B_i8271.ByteWithinSector >= hmap->B_i8271.SectorLength)
    {
      hmap->B_i8271.ByteWithinSector = 0;
      /* I don't know if this can cause the thing to step - I presume not for the moment */
      /*fprintf(htrace,"writeinterrupt1 STG=%u\n",hmap->B_i8271.SectorsToGo);*/
      /*fprintf(htrace,"WRITE %u %u %u\n",hmap->B_i8271.CurrentTrack,hmap->B_i8271.CurrentSector,hmap->B_i8271.SectorsToGo);*/
      discsave();
      /*hmap->B_i8271.SectorsToGo--;*/
      if (--hmap->B_i8271.SectorsToGo)
      {
        hmap->B_i8271.CurrentSector++;
      }
      else
      {
        /*last sector done*/
        nlastbyte = TRUE;
        /*turn drive select off*/
        /*hmap->A_i8271.select = (hmap->A_i8271.select & !(1<<hmap->B_i8271.ncurrentdrive));*/
        hmap->A_i8271.statusreg = 0x10;
        hmap->B_i8271.SectorsToGo = -1; /* To let us bail out */
        i8271setnmi();
        /*i8271_timer += hmap->B_i8271.steprate;*/
        hmap->cycles.i8271_togo += (80<<1);
      }
    }
  }
  /*fprintf(htrace,"LAST BYTE=&%X\n",nlastbyte);
  fprintf(htrace,"writeinterrupt2 STG=%u\n",hmap->B_i8271.SectorsToGo);*/
  if (!nlastbyte)
  {
    hmap->A_i8271.statusreg = 0x8C; /* Command busy, */
    i8271setnmi();
    hmap->cycles.i8271_togo += (80<<1);
  }
  /*fprintf(htrace,"RESULTREG=%u\n",hmap->A_i8271.resultreg);*/
}

/* seek interrupt
 */
void i8271interrupt29(void)
{
  HOSTMAP* hmap = &hostmap;
  /*result with interrupt*/
  hmap->A_i8271.statusreg = 0x18;
  i8271setnmi();
  /*all ok*/
  hmap->A_i8271.resultreg = 0;
}

HOSTMAP* i8271poll(HOSTMAP* hmap)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  /*fprintf(htrace,"POLL &%X\n",acommandlookup[hmap->B_i8271.ncommandid][0]);*/
  hmap->A_i8271.statusreg |= 8;
  if (hmap->B_i8271.ninerror)
  {
    hmap->A_i8271.resultreg = hmap->B_i8271.ninerror;
    hmap->A_i8271.statusreg = 0x18;
    i8271setnmi();
    hmap->B_i8271.ninerror = 0;
  }
  else
  {
    i8271setnmi();
    #ifdef __DEBUG__
      fprintf(htrace,"8271poll &%X\n",acommandlookup[hmap->B_i8271.ncommandid][0]);
    #endif
    switch (acommandlookup[hmap->B_i8271.ncommandid][0])
    {
      case 0x00:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 00\n");
        #endif
        break;
      case 0x04:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 04\n");
        #endif
        break;
      case 0x0A:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 0A\n");
        #endif
        break;
      case 0x0B:
        /*write data interrupt*/
        i8271interrupt0B();
        break;
      case 0x0E:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 0E\n");
        #endif
        break;
      case 0x0F:
        /*write deleted data*/
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 0F\n");
        #endif
        break;
      case 0x12:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 12\n");
        #endif
        break;
      case 0x13:
        /*read data*/
        i8271interrupt13();
        break;
      case 0x16:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 16\n");
        #endif
        break;
      case 0x17:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 17\n");
        #endif
        break;
      case 0x1B:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 1B\n");
        #endif
         break;
      case 0x1E:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 1E\n");
        #endif
        break;
      case 0x1F:
        /*verify data and deleted data*/
        i8271interrupt1F();
        break;
      case 0x23:
        /*format interrupt*/
        i8271interrupt23();
        break;
      case 0x29:
        /*seek interrupt*/
        i8271interrupt29();
        break;
      case 0x2C:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 2C\n");
        #endif
        break;
      case 0x35:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 35\n");
        #endif
        break;
      case 0x3A:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 3A\n");
        #endif
        break;
      case 0x3D:
        #ifdef __DEVELOP__
          fprintf(htrace,"NOT DONE YET! 3D\n");
        #endif
        break;
      default:
        #ifdef __DEVELOP__
          fprintf(htrace,"UNKNOWN &%X\n",hmap->B_i8271.ncommandid);
        #endif
        break;
    }
  }

  if ((cmap->nmis & NMIS_NMI) AND !(cmap->nmis & NMIS_OLDNMI))
  {
    r6502startinterrupt(cmap);
  }

  return hmap;
}

/* scan data var len
 *
 * param 0 = track number
 * param 1 = sector number
 * param 2 = length/no. of sectors
 * param 3 = scan type
 * param 4 = field length
 */
void i8271command00(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*sector not found*/
    inerror(0x1E);
    return;
  }

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);
}

/* write data
 */
void i8271command0B(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*drive not ready*/
    inerror(0x10);
    return;
  }
  /*check write protect*/
  if (!beebit_discwritable[ndrive])
  {
    /*drive write protected*/
    inerror(0x12);
    return;
  }

  hmap->A_i8271.currenttrack[hmap->B_i8271.ncurrentdrive] = hmap->A_i8271.parameter[0];

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  hmap->B_i8271.CurrentTrack = hmap->A_i8271.parameter[0];
  hmap->B_i8271.CurrentSector = hmap->A_i8271.parameter[1];
  hmap->B_i8271.SectorsToGo = hmap->A_i8271.parameter[2] & 31;
  hmap->B_i8271.SectorLength = 1<<(7+((hmap->A_i8271.parameter[2] >> 5) & 7));
  hmap->B_i8271.ByteWithinSector=0;
  hmap->B_i8271.writestart = TRUE;
  /*command busy*/
  hmap->A_i8271.statusreg = 0x80;
  i8271setnmi();
  i8271addtotimer(160<<1);
}

/* readdatavarlen
 *
 * param 0 = track number
 * param 1 = sector number
 * param 2 = length/no. of sectors
 */
void i8271command13(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*sector not found*/
    inerror(0x1E);
    return;
  }

  hmap->A_i8271.currenttrack[hmap->B_i8271.ncurrentdrive] = hmap->B_i8271.CurrentTrack;

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  hmap->B_i8271.CurrentTrack = hmap->A_i8271.parameter[0];
  hmap->B_i8271.CurrentSector = hmap->A_i8271.parameter[1];
  hmap->B_i8271.SectorsToGo = hmap->A_i8271.parameter[2] & 31;
  hmap->B_i8271.SectorLength = 1<<(7+((hmap->A_i8271.parameter[2] >> 5) & 7));

  /*fprintf(htrace,"TR: &%X SR: &%X\n",hmap->B_i8271.CurrentTrack,hmap->B_i8271.CurrentSector);*/
  /*fprintf(htrace,"SL: &%X STG: &%X\n",hmap->B_i8271.SectorLength,hmap->B_i8271.SectorsToGo);*/

  if (!discload())
  {
    /*sector not found*/
    inerror(0x1E);
    return;
  }

  /*if (ValidateSector(CommandStatus.hmap->B_i8271.CurrentSectorPtr,CommandStatus.TrackAddr,CommandStatus.hmap->B_i8271.SectorLength))
  {*/
    hmap->B_i8271.ByteWithinSector = 0;
    hmap->A_i8271.statusreg = 0x80; /* Command busy */
    i8271setnmi();
    i8271addtotimer(160<<1);
  /*}
  else
  {
    DoErr(0x1e);*/ /* Sector not found */
  /*}*/
}

/* verify data and deleted data
 *
 * param 0 = track number
 * param 1 = sector number
 * param 2 = length/no. of sectors
 */
void i8271command1F(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*sector not found*/
    inerror(0x1E);
    return;
  }

  hmap->A_i8271.currenttrack[hmap->B_i8271.ncurrentdrive] = hmap->A_i8271.parameter[0];

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  /*check track and sector range*/

  /*command busy*/
  hmap->A_i8271.statusreg = 0x80;
  i8271setnmi();
  i8271addtotimer(160<<1);
}

/* format command
 * param 0 = track number
 * param 1 = sector number
 * param 2 = length/no. of sectors
 */
void i8271command23(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*drive not ready*/
    inerror(0x10);
    return;
  }
  /*check write protect*/
  if (!beebit_discwritable[ndrive])
  {
    /*drive write protected*/
    inerror(0x12);
    return;
  }

  hmap->A_i8271.currenttrack[hmap->B_i8271.ncurrentdrive] = hmap->A_i8271.parameter[0];

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  hmap->B_i8271.CurrentTrack = hmap->A_i8271.parameter[0];
  hmap->B_i8271.CurrentSector = 0; /*hmap->A_i8271.parameter[1];*/
  hmap->B_i8271.SectorsToGo = hmap->A_i8271.parameter[2] & 31;
  hmap->B_i8271.SectorLength = 1<<(7+((hmap->A_i8271.parameter[2] >> 5) & 7));
  hmap->B_i8271.ByteWithinSector=0;
  hmap->B_i8271.writestart = TRUE;
  /*command busy*/
  hmap->A_i8271.statusreg = 0x80;
  i8271setnmi();
  i8271addtotimer(160<<1);
}

/* seek command
 */
void i8271command29(void)
{
  HOSTMAP* hmap = &hostmap;
  intptr_t ndrive;

  switch (hmap->A_i8271.select)
  {
    case 0:
      /*drive not ready*/
      inerror(0x10);
      return;
      break;
    case 1:
      hmap->B_i8271.ncurrentdrive = 0;
      break;
    case 2:
      hmap->B_i8271.ncurrentdrive = 1;
      break;
    default:
      /*sector not found*/
      inerror(0x1E);
      return;
      break;
  }

  ndrive = hmap->B_i8271.ncurrentdrive;
  if (beebit_imagetype[hmap->B_i8271.ncurrentdrive] == DFS_SSD)
    ndrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  if (!beebit_driveimage[ndrive])
  {
    /*sector not found*/
    inerror(0x1E);
    return;
  }

  hmap->A_i8271.currenttrack[hmap->B_i8271.ncurrentdrive] = hmap->A_i8271.parameter[0];

  hmap->B_i8271.ncurrentdrive += ((hmap->A_i8271.outputport & 0x20)>>4);

  hmap->A_i8271.statusreg = 0x80; /*command busy*/
  i8271setnmi();
  i8271addtotimer(160<<1);
}

/* read drive status command
 * b0 = count/optional
 * b1 = track 0
 * b2 = ready 0
 * b3 = write protect
 * b4 = index
 * b5 = write fault
 * b6 = ready 1
 */
void i8271command2C(void)
{
  HOSTMAP* hmap = &hostmap;
  int Track0,WriteProt;
  switch (hmap->A_i8271.select)
  {
    case 1:
      Track0 = (hmap->A_i8271.currenttrack[0] == 0);
      WriteProt = (!beebit_discwritable[0]);
      break;
    case 2:
      Track0 = (hmap->A_i8271.currenttrack[1] == 0);
      WriteProt = (!beebit_discwritable[1]);
      break;
    default:
      Track0 = TRUE;
      WriteProt = TRUE;
      break;
  }
  hmap->A_i8271.resultreg = 0x80;
  if (hmap->A_i8271.select & 0x02)
    hmap->A_i8271.resultreg |= 0x40;
  if (WriteProt)
    hmap->A_i8271.resultreg |= 0x08;
  if (hmap->A_i8271.select & 0x01)
    hmap->A_i8271.resultreg |= 0x04;
  if (Track0)
    hmap->A_i8271.resultreg |= 0x02;

  /*fprintf(htrace,"RES:&%X\n",hmap->A_i8271.resultreg);*/
  hmap->A_i8271.statusreg |= 0x10; /* Result */
}

void i8271command35(void)
{
  HOSTMAP* hmap = &hostmap;
  /*specify command*/
  /*fprintf(htrace,"SPECIFY &%X &%X\n",hmap->A_i8271.parameter[0],hmap->A_i8271.parameter[1]);*/
  switch (hmap->A_i8271.parameter[0])
  {
    case 0x0D:
      /*specify initialization*/
      hmap->B_i8271.steprate = (hmap->A_i8271.parameter[1] << 1); /*2MHz clock*/
      hmap->B_i8271.headsettletime = (hmap->A_i8271.parameter[2] << 1); /*2MHz clock*/
      hmap->B_i8271.indexcount = ((hmap->A_i8271.parameter[3] & 0xF0) >> 4);
      hmap->B_i8271.headloadtime = ((hmap->A_i8271.parameter[3] & 0x0F) << 3); /*2MHz clock*/
      break;
    case 0x10:
      /*load bad tracks surface 0*/
      hmap->A_i8271.badtrack[0][0] = hmap->A_i8271.parameter[1];
      hmap->A_i8271.badtrack[0][1] = hmap->A_i8271.parameter[2];
      break;
    case 0x18:
      /*load bad tracks surface 1*/
      hmap->A_i8271.badtrack[1][0] = hmap->A_i8271.parameter[1];
      hmap->A_i8271.badtrack[1][1] = hmap->A_i8271.parameter[2];
      break;
  }
}

/* write special command
 */
void i8271command3A(void)
{
  HOSTMAP* hmap = &hostmap;
  /*fprintf(htrace,"WS:&%X &%X\n",hmap->A_i8271.parameter[0],hmap->A_i8271.parameter[1]);*/
  switch (hmap->A_i8271.parameter[0])
  {
    case 0x06:
      hmap->A_i8271.scansector = hmap->A_i8271.parameter[1];
      break;
    case 0x14:
      hmap->A_i8271.scancountmsb = hmap->A_i8271.parameter[1];
      break;
    case 0x13:
      hmap->A_i8271.scancountlsb = hmap->A_i8271.parameter[1];
      break;
    case 0x12:
      hmap->A_i8271.currenttrack[0]=hmap->A_i8271.parameter[1];
      break;
    case 0x1a:
      hmap->A_i8271.currenttrack[1]=hmap->A_i8271.parameter[1];
      break;
    case 0x17:
      hmap->A_i8271.modereg = hmap->A_i8271.parameter[1];
      break;
    case 0x23:
      /*drive control output port*/
      /*b0 = write enable
       *b1 = seek/step
       *b2 = direction
       *b3 = load head
       *b4 = low head current
       *b5 = write fault reset (used to indicate head)
       *b6 = select 0
       *b7 = select 1*/
      /*drive 0 = &48
       *drive 1 = &88
       *drive 2 = &68
       *drive 3 = &A8*/
      hmap->A_i8271.outputport = hmap->A_i8271.parameter[1];
      hmap->A_i8271.select = (hmap->A_i8271.outputport & 0xC0)>>6;
      break;
    case 0x22:
      hmap->A_i8271.inputport = hmap->A_i8271.parameter[1];
      break;
    case 0x10:
      hmap->A_i8271.badtrack[0][0] = hmap->A_i8271.parameter[1];
      break;
    case 0x11:
      hmap->A_i8271.badtrack[0][1] = hmap->A_i8271.parameter[1];
      break;
    case 0x18:
      hmap->A_i8271.badtrack[1][0] = hmap->A_i8271.parameter[1];
      break;
    case 0x19:
      hmap->A_i8271.badtrack[1][1] = hmap->A_i8271.parameter[1];
      break;
  }
}

void i8271command3D(void)
{
  HOSTMAP* hmap = &hostmap;
  /*read special command*/
  switch(hmap->A_i8271.parameter[0])
  {
    case 0x06:
      hmap->A_i8271.resultreg = hmap->A_i8271.scansector;
      break;
    case 0x14:
      hmap->A_i8271.resultreg = hmap->A_i8271.scancountmsb;
      break;
    case 0x13:
      hmap->A_i8271.resultreg = hmap->A_i8271.scancountlsb;
      break;
    case 0x12:
      hmap->A_i8271.resultreg = hmap->A_i8271.currenttrack[0];
      break;
    case 0x1a:
      hmap->A_i8271.resultreg = hmap->A_i8271.currenttrack[1];
      break;
    case 0x17:
      hmap->A_i8271.resultreg = hmap->A_i8271.modereg;
      break;
    case 0x23:
      hmap->A_i8271.resultreg = hmap->A_i8271.outputport;
      break;
    case 0x22:
      hmap->A_i8271.resultreg = hmap->A_i8271.inputport;
      break;
    case 0x10:
      hmap->A_i8271.resultreg = hmap->A_i8271.badtrack[0][0];
      break;
    case 0x11:
      hmap->A_i8271.resultreg = hmap->A_i8271.badtrack[0][1];
      break;
    case 0x18:
      hmap->A_i8271.resultreg = hmap->A_i8271.badtrack[1][0];
      break;
    case 0x19:
      hmap->A_i8271.resultreg = hmap->A_i8271.badtrack[1][1];
      break;
  }

  hmap->A_i8271.statusreg |= 16; /* Result reg full */
  i8271setnmi();
}

void callcommand(void)
{
  HOSTMAP* hmap = &hostmap;
  #ifdef __DEBUG__
  #endif
  switch (acommandlookup[hmap->B_i8271.ncommandid][0])
  {
    case 0x00:
      /*Scan Data (Variable Length/Multi-Record)*/
      hmap->A_i8271.select = (hmap->A_i8271.commandreg & 0xC0)>>6;
      i8271command00();
      break;
    case 0x04:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 04\n");
      #endif
      break;
    case 0x0A:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 0A\n");
      #endif
      break;
    case 0x0B:
      /*write data*/
      hmap->A_i8271.select = (hmap->A_i8271.commandreg & 0xC0)>>6;
      i8271command0B();
      break;
    case 0x0E:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 0E\n");
      #endif
      break;
    case 0x0F:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 0F\n");
      #endif
      break;
    case 0x12:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 12\n");
      #endif
      break;
    case 0x13:
      /*read data*/
      hmap->A_i8271.select = (hmap->A_i8271.commandreg & 0xC0)>>6;
      i8271command13();
      break;
    case 0x16:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 16\n");
      #endif
      break;
    case 0x17:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 17\n");
      #endif
      break;
    case 0x1B:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 1B\n");
      #endif
      break;
    case 0x1E:
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 1E\n");
      #endif
      break;
    case 0x1F:
      /*verify data and deleted data*/
      hmap->A_i8271.select = (hmap->A_i8271.commandreg & 0xC0)>>6;
      i8271command1F();
      break;
    case 0x23:
      /*format*/
      #ifdef __DEVELOP__
        fprintf(htrace,"NOT DONE YET! 23\n");
      #endif
      i8271command23();
      break;
    case 0x29:
      /*seek*/
      hmap->A_i8271.select = (hmap->A_i8271.commandreg & 0xC0)>>6;
      i8271command29();
      break;
    case 0x2C:
      /*read drive status*/
      i8271command2C();
      break;
    case 0x35:
      /*specify*/
      i8271command35();
      break;
    case 0x3A:
      i8271command3A();
      break;
    case 0x3D:
      /*readspecialcommand*/
      i8271command3D();
      break;
    default:
      #ifdef __DEVELOP__
        fprintf(htrace,"UNKNOWN &%X\n",hmap->B_i8271.ncommandid);
      #endif
      break;
  }
}

void i8271commandregwrite(char nvalue)
{
  /*command register
   *b0-b5=command
   *b6-b7=drive select
   */
  HOSTMAP* hmap = &hostmap;
  int i;
  hmap->A_i8271.commandreg = nvalue;
  i = 0;
  while (i < 20 AND acommandlookup[i][0] != (hmap->A_i8271.commandreg & 0x3F))
    i++;
  if (i < 20)
  {
    #ifdef __DEBUG__
      fprintf(htrace,"LU: &%X\n",acommandlookup[i][0]);
    #endif
    hmap->B_i8271.ncommandid = i;
    hmap->B_i8271.ncommandparams = acommandlookup[i][1];
    hmap->B_i8271.PresentParam = 0;
    hmap->A_i8271.statusreg |= 0x90; /*Observed on beeb for read special*/
    i8271setnmi();
    if (hmap->B_i8271.ncommandparams == 0)
    {
      hmap->A_i8271.statusreg &= 0x7E;
      i8271setnmi();
      callcommand();
    }
  }
}

void i8271paramregwrite(char nvalue)
{
  HOSTMAP* hmap = &hostmap;
  if (hmap->B_i8271.PresentParam < hmap->B_i8271.ncommandparams)
  {
    #ifdef __DEBUG__
      fprintf(htrace,"PA: &%X &%X\n",hmap->B_i8271.PresentParam,nvalue);
    #endif
    hmap->A_i8271.parameter[hmap->B_i8271.PresentParam++] = nvalue;
    hmap->A_i8271.statusreg &= 0xFE; /* Observed on beeb */
    i8271setnmi();
    if (hmap->B_i8271.PresentParam >= hmap->B_i8271.ncommandparams)
    {
      hmap->A_i8271.statusreg &= 0x7E; /* Observed on beeb */
      i8271setnmi();
      callcommand();
    }
  }
}

HOSTMAP* i8271statusread(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->m = hmap->A_i8271.statusreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271resultread(HOSTMAP* hmap, uintptr_t address_code)
{
  /* Clear interrupt request, result reg full and non-dma request flags*/
  hmap->A_i8271.statusreg &= ~0x1C;
  i8271setnmi();
  hmap->m = hmap->A_i8271.resultreg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271dataread(HOSTMAP* hmap, uintptr_t address_code)
{
  /* Clear interrupt and non-dma request - not stated but DFS never looks at result reg!*/
  hmap->A_i8271.statusreg &= ~0x0C;
  i8271setnmi();
  hmap->m = hmap->A_i8271.datareg;
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271commandwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*command register
   *b0-b5=command
   *b6-b7=drive select
   */
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;
  int i;
  hmap->A_i8271.commandreg = hmap->m;
  i = 0;
  while (i < 20 AND acommandlookup[i][0] != (hmap->A_i8271.commandreg & 0x3F))
    i++;
  if (i < 20)
  {
    #ifdef __DEBUG__
      fprintf(htrace,"LU: &%X\n",acommandlookup[i][0]);
    #endif
    hmap->B_i8271.ncommandid = i;
    hmap->B_i8271.ncommandparams = acommandlookup[i][1];
    hmap->B_i8271.PresentParam = 0;
    hmap->A_i8271.statusreg |= 0x90; /*Observed on beeb for read special*/
    if (hmap->B_i8271.ncommandparams == 0)
    {
      hmap->A_i8271.statusreg &= 0x7C;
      callcommand();

      if ((cmap->nmis & NMIS_NMI) AND !(cmap->nmis & NMIS_OLDNMI))
      {
        r6502startinterrupt(cmap);
      }
    }
  }
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271parameterwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  R6502CPUMAP* cmap = (R6502CPUMAP*)hmap;

  if (hmap->B_i8271.PresentParam < hmap->B_i8271.ncommandparams)
  {
    #ifdef __DEBUG__
      fprintf(htrace,"PA: &%X &%X\n",hmap->B_i8271.PresentParam,nvalue);
    #endif
    hmap->A_i8271.parameter[hmap->B_i8271.PresentParam++] = hmap->m;
    if (hmap->B_i8271.PresentParam >= hmap->B_i8271.ncommandparams)
    {
      hmap->A_i8271.statusreg &= 0x7C; /* Observed on beeb */
      callcommand();

      if ((cmap->nmis & NMIS_NMI) AND !(cmap->nmis & NMIS_OLDNMI))
      {
        r6502startinterrupt(cmap);
      }
    }
  }
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271resetwrite(HOSTMAP* hmap, uintptr_t address_code)
{
  /*The caller should write a 1 and then >10 cycles later a 0 - but I'm just going to reset on both edges*/
  i8271reset();
  R6502_JUMP_FROM_HIGH_OP(hmap)
}

HOSTMAP* i8271datawrite(HOSTMAP* hmap, uintptr_t address_code)
{
  hmap->A_i8271.datareg = hmap->m;
  hmap->A_i8271.statusreg &= ~0x0C;
  i8271setnmi();
  R6502_JUMP_FROM_HIGH_OP(hmap)
}
