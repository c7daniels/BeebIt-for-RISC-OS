/*>hostmap.h
 *
 * BeebIt - BBC Micro Model B Emulator
 *
 * Cycle-level CPU emulation
 *
 * (C) Copyright Crispian Daniels, 2024-2025
 *
 * Email: <convertedgames@3insdale.me.uk>
 */

#ifndef __BEEBIT_HOSTMAP_H__
#define __BEEBIT_HOSTMAP_H__

#include "6502zmap.h"

#define CYCLES_TO_GO_IN_REGISTER_FLAG   1

#define R6502_JUMP_FROM_HIGH_OP(HMAP) \
  return (HOSTMAP*)HMAP->peripheralops[HMAP->peripheral_code&0xFF]((R6502ZONEMAP*)HMAP, HMAP->peripheral_code);

#define HOSTMAP_LIMIT_CYCLES_TO_GO(MAP, LIMIT) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    intptr_t excess = cy->original - (LIMIT); \
    if (excess > 0) \
    { \
      cy->original -= excess; \
      cy->togo -= excess; \
    } \
  }

#define HOSTMAP_LIMIT_PERIPHERAL_CYCLES_TO_GO(MAP, P, LIMIT) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    intptr_t excess = cy->P##_original - (LIMIT); \
    if (excess > 0) \
    { \
      cy->P##_original -= excess; \
      cy->P##_togo -= excess; \
      excess = cy->original - cy->P##_togo; \
      if (excess > 0) \
      { \
        cy->original -= excess; \
        cy->togo -= excess; \
      } \
    } \
  }

#define HOSTMAP_GET_PERIPHERAL_CYCLE_COUNT(OUT, MAP, P) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    OUT = cy->original - cy->togo + cy->P##_original - cy->P##_togo; \
  }

#define HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FOR_SNAPSHOT_OFFSET(OUT, MAP, P) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    OUT = cy->original - cy->togo; \
    OUT += (cy->odd^OUT^1)&1; \
    OUT += cy->P##_original - cy->P##_togo; \
  }

#define HOSTMAP_GET_TOGO_FROM_WRITE_OFFSET(OUT, MAP) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    OUT = 1 + cy->original - cy->togo; \
  }

#define HOSTMAP_GET_1MHZ_PERIPHERAL_TOGO_FROM_WRITE_OFFSET(OUT, MAP, P) \
  { \
    HOSTMAPCYCLES *cy = &(MAP)->cycles; \
    OUT = 2 + cy->original - cy->togo; \
    OUT += cy->P##_original - cy->P##_togo; \
  }

struct HOSTMAP;

typedef struct HOSTMAP* (*HOSTHIGHOP)(struct HOSTMAP *hmap, uintptr_t address_code); /*returning the first parameter leaves it in r0 for the next call from AArch32 assembly language*/

typedef struct HOSTMAP* (*HOSTSWAPOP)(struct HOSTMAP *hmap); /*returning the first parameter leaves it in r0 for the next call from AArch32 assembly language*/

typedef struct HOSTMAP* (*HOSTKEYBOARDOP)(struct HOSTMAP *hmap, uintptr_t incremented_state);

typedef struct HOSTMAP* (*HOSTVIDEOOP)(struct HOSTMAP *hmap); /*returning the first parameter leaves it in r0 for the next call from AArch32 assembly language*/

typedef struct HOSTMAP* (*CRTCSTEPOP)(struct HOSTMAP *hmap, uintptr_t incremented_step_state);

typedef struct HOSTMAP* (*HOSTVIDEOREADOP)(struct HOSTMAP *hmap, uintptr_t scan_code);


typedef struct HOSTMAP* (*VIDEOULAFRAGMENTREFRESHOP)(struct HOSTMAP *hmap, uintptr_t* fill);

typedef struct HOSTMAP* (*VIDEOULALOADOP)(struct HOSTMAP *hmap, uintptr_t value);

typedef struct HOSTMAP* (*VIDEOSETSKEWOP)(struct HOSTMAP *hmap, uint8_t r8);

typedef uintptr_t HOSTMAPUEFFILEPOINTERAREA[1];
typedef uintptr_t HOSTMAPVIDOUTOPMAPAREA[64];

typedef struct
{
  uintptr_t monotonic; /*used by zeribeepwrite*/
  intptr_t odd;
  intptr_t togo;
  intptr_t original;
  intptr_t sysvia_togo;
  intptr_t sysvia_original;
  intptr_t usrvia_togo;
  intptr_t usrvia_original;
  intptr_t i8271_togo;
  intptr_t w1770_togo;
  intptr_t adc_togo;
  intptr_t m6850_togo;
} HOSTMAPCYCLES;

typedef struct
{
  R6502BUSOP read3000, write3000;
  R6502BUSOP read3000_ram, write3000_ram;
  R6502BUSOP read3000_ramram, write3000_ramram;
  R6502BUSOP read3000_e, write3000_e;
  R6502BUSOP read3000_x, write3000_x;
  R6502BUSOP read8000_ram, write8000_ram;
  R6502BUSOP readC000_y, writeC000_y;
  HOSTSWAPOP swapintomemory, swapoutofmemory;
} HOSTMAPPAGING;

typedef struct
{
  uint8_t orb; /*output register B*/
  uint8_t irb; /*input register B*/
  uint8_t ora; /*output register A*/
  uint8_t ira; /*input register A*/
  uint8_t ddrb; /*0 bit means input, 1 means output*/
  uint8_t ddra; /*0 bit means input, 1 means output*/
  /*these variables contain the actual values on the lines...*/
  uint8_t porta;
  uint8_t portb;
  uint8_t t1ll; /*T1 low order latch*/
  uint8_t t1lh; /*T1 high order latch*/
  uint8_t t2ll; /*T2 low order latch*/
  uint8_t sr; /*status register*/
  uint8_t acr;
  uint8_t pcr;
  uint8_t ifr;
  uint8_t ier;
  uint8_t t1setint; /*set interrupt when timer1 reaches 0*/
  uint8_t t2setint; /*set interrupt when timer2 reaches 0*/
  uint8_t aftert1; /*when timer1 has passed through 0*/
  uint8_t padding[1];
} HOSTMAPAVIA;

typedef struct
{
  uint8_t readwrite;
  uint8_t datastrobe;
  uint8_t addrstrobe;
  uint8_t chipselect;
} HOSTMAPRTC;

typedef struct
{
  intptr_t t1doubled; /*left-shifted timer 1 (used for speed)*/
  intptr_t t2doubled; /*left-shifted timer 2 (used for speed)*/
} HOSTMAPBVIA;

typedef struct
{
  intptr_t timer; /*amx mouse timer*/
  intptr_t buttons;
  intptr_t currentx;
  intptr_t currenty;
  intptr_t targetx;
  intptr_t targety;
} HOSTMAPAMX;

typedef struct
{
  uint8_t m6850_controlreg;
  uint8_t m6850_rxdatareg; /*receive data reg*/
  uint8_t m6850_txdatareg; /*transmit data reg*/
  uint8_t m6850_rxdatashiftreg; /*receive data shift reg*/
  uint8_t m6850_txdatashiftreg; /*transmit data shift reg*/
  uint8_t m6850_statusreg;
  uint8_t ula_reg;
  uint8_t uef_data;
} HOSTMAPASERIAL;

typedef struct
{
  intptr_t m6850_CTS,m6850_RTS,m6850_DCD;
  intptr_t m6850_counterdivide;
  intptr_t m6850_bits, m6850_parity, m6850_stop;
  intptr_t m6850_transmittingRTS;
  intptr_t m6850_transmittingIRQ;
  intptr_t m6850_cleardcd;
  intptr_t m6850_firstreset;
  intptr_t m6850_timerreset;
  intptr_t ula_txbaud;
  intptr_t ula_rxbaud;
  intptr_t uef_version;
  HOSTMAPUEFFILEPOINTERAREA uef_filepointerarea;
  char* uef_buffer;
  intptr_t uef_bufferpointer;
  intptr_t uef_chunk;
  intptr_t uef_chunklen;
  intptr_t uef_chunkstart;
  intptr_t uef_tone;
} HOSTMAPBSERIAL;

typedef struct
{
  uint8_t commandreg;
  uint8_t statusreg;
  uint8_t resultreg;
  uint8_t datareg;
  uint8_t select;
  uint8_t scansector;
  uint8_t scancountmsb;
  uint8_t scancountlsb;
  uint8_t currenttrack[2];
  uint8_t modereg;
  uint8_t outputport;
  uint8_t inputport;
  uint8_t badtrack[2][2]; /*drive,track*/
  uint8_t parameter[16]; /*heaps more than we need*/
  uint8_t _padding[3];
} HOSTMAPAI8271;

typedef struct
{
  intptr_t steprate;
  intptr_t headsettletime;
  intptr_t indexcount;
  intptr_t headloadtime;
  intptr_t writestart;
  intptr_t ncurrentdrive,CurrentTrack, CurrentSector, SectorsToGo, SectorLength, ByteWithinSector;
  intptr_t ncommandid,ncommandparams;
  intptr_t PresentParam; /* From 0 */
  intptr_t ninerror;
} HOSTMAPBI8271;

typedef struct
{
  uint8_t controlreg;
  uint8_t statusreg;
  uint8_t trackreg;
  uint8_t sectorreg;
  uint8_t datareg;
  uint8_t commandreg;
  uint8_t track;
  uint8_t reset;
  uint8_t density;
  uint8_t drive;
  uint8_t side;
  uint8_t padding[1];
} HOSTMAPAW1770;

typedef struct
{
  intptr_t stepdir;
  intptr_t steptime;
  intptr_t byteinsector;
  intptr_t writegate;
  intptr_t lastbyte;
} HOSTMAPBW1770;

typedef struct
{
  uint8_t channel;
  uint8_t flag;
  uint8_t resolution;
  uint8_t status;
  uint8_t highbyte;
  uint8_t lowbyte;
  uint8_t suppressfirst;
  uint8_t padding[1];
} HOSTMAPAADC;

typedef struct
{
  intptr_t input_x_high;
  intptr_t input_y_low;
} HOSTMAPBADC;

typedef struct
{
  uintptr_t numbers[16];
  uintptr_t outputfill[16];
  uintptr_t absolutefill[16];
  uintptr_t normalfill[16];
  uintptr_t inversefill[16];
  uintptr_t normalfragment[16];
  uintptr_t inversefragment[16];
  uintptr_t fragment[16];
} HOSTMAPDCOLOUR;

typedef struct
{
  uint8_t r[18]; /*18 registers*/
  uint8_t addressreg;
  uint8_t r9image;
  uint8_t c3h;
  uint8_t c3v;
  uint8_t c4;
  uint8_t c9;
  uint8_t c9low;
  uint8_t displaycounter;
  uint8_t fieldnumber;
  uint8_t nextfieldnumber;
  uint8_t in_firstline;
  uint8_t in_vd;
  uint8_t delayvs;
  uint8_t vs_thisrow;
  uint8_t vs_counting;
  uint8_t vs_delayed;
  uint8_t endframe;
  uint8_t lpstbtimer;
  uint8_t displaybuffer;
  uint8_t padding[3];
} HOSTMAPACRTC;

typedef struct
{
  CRTCSTEPOP *step_state;
  uintptr_t start_code;
  uintptr_t row_code;
  uintptr_t scan_code;
  uintptr_t cursoraddress;
  intptr_t cursorcolumn;
  uintptr_t cursorbuffer;
} HOSTMAPBCRTC;

typedef struct
{
  uint8_t palette[16];
  uint32_t shiftregister;
  uint8_t control;
  uint8_t blacklevelnphys;
  uint8_t fragmentbits;
  uint8_t padding[1];
} HOSTMAPAVIDEOULA;

typedef struct
{
  VIDEOULAFRAGMENTREFRESHOP fragmentrefreshaction;
  VIDEOULALOADOP evenloadop;
  VIDEOULALOADOP evenRloadop;
  VIDEOULALOADOP oddloadop;
  VIDEOULALOADOP oddRloadop;
  VIDEOULALOADOP selectedevenloadop;
  VIDEOULALOADOP selectedevenRloadop;
  const uint32_t* bytelut;
  uintptr_t bytecolours;
  uintptr_t flashing;
  uintptr_t cursorfill;
  uintptr_t normalblank;
  uintptr_t inverseblank;
  uintptr_t cursorflags;
} HOSTMAPBVIDEOULA;

typedef struct
{
  uint8_t roundingdirection1;
  uint8_t roundingdirection2;
  uint8_t line;
  uint8_t lastline;
  uint8_t flipflops;
  uint8_t flashstage;
  uint8_t flashcounter;
  uint8_t padding[1];
} HOSTMAPATELETEXT;

typedef struct
{
  uintptr_t colourfill[8];
  uintptr_t fg1fill;
  uintptr_t bg1fill;
  uintptr_t fg2fill;
  uintptr_t bg2fill;
  uintptr_t rightoffset;
  uintptr_t lowoffset;
  uintptr_t bblevelbit;
  uintptr_t queue;
  uintptr_t colours;
  intptr_t* lutslice;
  intptr_t holdlue;
  intptr_t lue1;
  intptr_t lue2;
} HOSTMAPBTELETEXT;

typedef struct
{
  uint8_t shift;
  uint8_t flags0,flags1;
  uint8_t writecode;
  uint8_t eventflags;
  uint8_t linetestflags;
  uint8_t skip;
  uint8_t distinctfields;
  uint8_t progressive;
  uint8_t updateframecounter;
  uint8_t updateframenumber;
  uint8_t fastskipflipflop;
} HOSTMAPAVIDBUF;

typedef struct
{
  intptr_t altoffset;
  intptr_t synclineaddress;
  intptr_t lineaddress;
  intptr_t address;
  intptr_t stride;
  uintptr_t displayskewmask;
  uintptr_t cursorskewmask;
  intptr_t synccolumn;
  intptr_t offsetsynccolumn;
  intptr_t limitcolumn;
  intptr_t stopcolumn;
  intptr_t syncline;
  intptr_t startline;
  intptr_t stopline;
  intptr_t limitline;
  intptr_t limitlinecounter;
  intptr_t column;
  intptr_t line;
  intptr_t linelevel;
  HOSTVIDEOOP enteringvsyncop;
  HOSTVIDEOOP leavingvsyncop;
  HOSTVIDEOOP graphicsinnerop;
  HOSTVIDEOOP teletextinnerop;
  HOSTVIDEOOP cursorinnerop;
  VIDEOSETSKEWOP setskewop;
} HOSTMAPBVIDBUF;

typedef struct
{
  uint8_t linescaletotal;
  uint8_t linescale;
  uint8_t lutshift;
  uint8_t padding[1];
} HOSTMAPAVIDOUT;

typedef struct
{
  HOSTVIDEOOP lineop;
  intptr_t nbits;
  intptr_t nlutbits;
  intptr_t linelength;
  intptr_t lowoffset;
  intptr_t address;
  intptr_t lut;
} HOSTMAPBVIDOUT;

typedef struct
{
  HOSTMAPVIDOUTOPMAPAREA opmaparea;
  HOSTVIDEOOP opfork[16];
} HOSTMAPDVIDOUT;

/*storage map specialized for peripheral emulation*/
typedef struct HOSTMAP
{
  // AArch32 offsets &00 - &FF
  R6502_AC_ZONE AC;
  uint8_t keystatus[16];
  int8_t romwritable[16];
  uint8_t romsel; /*ROMSELect*/
  uint8_t acccon;  /*ACCCON*/
  uint8_t lsoundlatch;
  uint8_t screenstartindex; /*screen start index (system via)*/
  uint8_t yield; /*yield control on a vsync*/
  uint8_t yield_unused[3];
  HOSTMAPAVIA A_sysvia;
  HOSTMAPAVIA A_usrvia;
  HOSTMAPRTC rtc;
  HOSTMAPASERIAL A_serial;
  HOSTMAPAI8271 A_i8271;
  HOSTMAPAW1770 A_w1770;
  HOSTMAPAADC A_adc;
  HOSTMAPACRTC A_crtc;
  HOSTMAPAVIDEOULA A_videoula;
  HOSTMAPATELETEXT A_teletext;
  HOSTMAPAVIDBUF A_vidbuf;
  HOSTMAPAVIDOUT A_vidout;
  uint8_t AP_unused[63*sizeof(uintptr_t)-236];

  // AArch32 offsets &100 - &3FF
  uintptr_t peripheral_code;
  R6502BYTESHIFT m_shift; uint8_t m; /*value on data bus*/
  R6502_BC_ZONE BC;
  HOSTKEYBOARDOP *keyboard_state;
  void *zeribeep_writebyte;
  void *zeribeep_workspace;
  HOSTMAPCYCLES cycles;
  HOSTMAPPAGING paging;
  HOSTMAPBVIA B_sysvia;
  HOSTMAPBVIA B_usrvia;
  HOSTMAPAMX amx;
  HOSTMAPBSERIAL B_serial;
  HOSTMAPBI8271 B_i8271;
  HOSTMAPBW1770 B_w1770;
  HOSTMAPBADC B_adc;
  HOSTMAPBCRTC B_crtc;
  HOSTMAPBVIDEOULA B_videoula;
  HOSTMAPBTELETEXT B_teletext;
  HOSTMAPBVIDBUF B_vidbuf;
  HOSTMAPBVIDOUT B_vidout;
  uintptr_t B_unused[5];

  // AArch32 offsets &400 - &FFF
  R6502PERIPHERALOPTABLE peripheralops;
  R6502_CC_ZONE CC;
  HOSTVIDEOREADOP videoreads[256];
  VIDEOULALOADOP videoulaloads[32];
  HOSTVIDEOREADOP videographicswrapreads[16];
  HOSTVIDEOREADOP videoteletextwrapreads[16];
  uintptr_t CP_unused[64];

  // AArch32 offsets &1000 - &1BFF
  R6502_DC_ZONE DC;
  R6502BUSOP read8000s[16];
  R6502BUSOP write8000s[16];
  HOSTMAPDCOLOUR D_colour;
  HOSTMAPDVIDOUT D_vidout;
  uintptr_t DP_unused[240];

  // AArch32 offsets &1C00 - &3FFF
  R6502_EC_ZONE EC;

  // AArch32 offsets &4000 - &7FFF
  HOSTHIGHOP readhigh[1024];
  HOSTHIGHOP writehigh[1024];
  HOSTHIGHOP stretchedreadhigh[1024];
  HOSTHIGHOP stretchedwritehigh[1024];

  // AArch32 offsets &8000 - &FFFF
  HOSTHIGHOP bridgedreadhigh[1024];
  HOSTHIGHOP bridgedwritehigh[1024];
  HOSTKEYBOARDOP keyboardops[1024];
  HOSTVIDEOOP teletextops[512];
  CRTCSTEPOP crtcstep[512];
  uintptr_t crtccolumntags[256];
  CRTCSTEPOP crtctaggedops[256];
  HOSTVIDEOOP endoflineactions[7];
  uintptr_t endoflineactions_unused[249];
  R6502PERIPHERALOP blacklevelops[8];
  uintptr_t high_unused[3320];

  // AArch32 offsets &10000 - &1FFFF
  uint8_t memory[0x10000];

  // AArch32 offsets &20000 - &27FFF
  uint8_t shadow[0x8000];

  // AArch32 offsets &28000 - &67FFF
  uint8_t roms[0x10][0x4000];

  // AArch32 offsets &68000 - &6BFFF
  uint32_t shiftedbytecolours[1024];

  // AArch32 offsets &6C000 - &77FFF
  intptr_t teletextlinelut[96*128];

} HOSTMAP;

extern HOSTMAP hostmap;

extern HOSTMAP* h6502startreadstretch(HOSTMAP* hmap, uintptr_t address_code);
extern HOSTMAP* h6502startwritestretch(HOSTMAP* hmap, uintptr_t address_code);

extern int h6502getplacementinregisters(void);
extern HOSTMAP* h6502cyclestogobridgeread(HOSTMAP* hmap, uintptr_t address_code);
extern HOSTMAP* h6502cyclestogobridgewrite(HOSTMAP* hmap, uintptr_t address_code);

extern void swappages(uint8_t *block1, uint8_t *block2, int npagecount);

extern void hostmapinit(void);
extern void hostmapapplysoundoption(void);
extern int hostmapresetcpu(void);
extern void hostmapresetperipherals(void);
extern void hostmapexecute(void);
extern void hostmapbeforesnapshot(void);
extern void hostmapaftersnapshot(void);

#endif //__BEEBIT_6502CMAP_H__
